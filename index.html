<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- This meta tag makes the app responsive on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DXF Parser</title>
  <style>
    /* Base Styles */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    *, *:before, *:after {
      box-sizing: border-box;
    }
    body {
      font-family: sans-serif;
    }
    .main-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 1em;
    }
    /* Header container for logo and top-right buttons */
    .header-container {
      display: flex;
      flex-wrap: wrap; /* allow header items to wrap onto new lines */
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1em;
    }
    /* File input row (for file input and parse button on the same line) */
    .file-input-row {
      display: inline-flex;
      align-items: center;
      gap: 0.5em;
      margin-bottom: 1em;
    }
    /* Make the parse button only as wide as its text */
    #parseBtn {
      padding: 0.3em 0.6em;
      white-space: nowrap;
    }
    /* Top-right buttons (now inside the header) */
    .top-right-buttons {
      display: flex;
      gap: 0.5em;
      flex-wrap: wrap;
    }
    /* Navigation history container with controls */
    #navHistoryContainer {
      margin-bottom: 1em;
      padding: 0.5em;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #navHistoryControls {
      margin-bottom: 0.5em;
    }
    #navHistoryControls button {
      margin-right: 4px;
    }
    #navHistoryList {
      overflow-x: auto;
      white-space: nowrap;
    }
    /* Tabs */
    #tabContainer {
      display: flex;
      flex-wrap: wrap;
      border-bottom: 1px solid #ccc;
      margin: 0.5em 0; /* reduced spacing */
    }
    .tab {
      padding: 0.5em 1em;
      border: 1px solid #ccc;
      border-bottom: none;
      cursor: pointer;
      margin-right: 2px;
      margin-bottom: 2px;
      background: #eee;
      position: relative;
    }
    .tab.active {
      background: #fff;
      font-weight: bold;
    }
    .tab .close-tab {
      position: absolute;
      top: 0;
      right: 2px;
      cursor: pointer;
      padding: 0 4px;
    }
    /* Tree Grid Header */
    /* --- Modified CSS for header --- */
    #treeGridHeader {
      display: flex;
      align-items: center;
      height: 24px;
      font-weight: bold;
      border-bottom: 1px solid #ccc;
      background: #eee;
      user-select: none;
      /* Keep the header in view and allow horizontal transform */
      position: sticky;
      top: 0;
      z-index: 2;
      will-change: transform;
    }
    .header-cell {
      display: flex;
      align-items: center;
      height: 100%;
      position: relative;
      padding: 0 4px;
      border-right: 1px solid #ccc;
      cursor: pointer;
    }
    .header-cell.flex-fixed {
      flex: none;
    }
    .header-cell.flex-grow {
      flex: 1;
    }
    .header-cell:last-child {
      border-right: none;
    }
    .header-cell .resizer {
      position: absolute;
      right: 0;
      top: 0;
      width: 5px;
      height: 100%;
      cursor: col-resize;
    }
    .header-cell .sort-indicator {
      margin-left: 4px;
      font-size: 0.8em;
    }
    .tree-line,
    .tree-code,
    .tree-object-count,
    .tree-data-size {
      flex: none;
      padding: 0 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: left;
      border-right: 1px solid #ccc;
      height: 100%;
    }
    .tree-data {
      flex: 1;
      padding: 0 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border-right: 1px solid #ccc;
      height: 100%;
    }
    .tree-line:last-child,
    .tree-code:last-child,
    .tree-data:last-child,
    .tree-object-count:last-child,
    .tree-data-size:last-child {
      border-right: none;
    }
    /* --- Updated container and row clipping styles --- */
    #treeViewContainer {
      position: relative;
      flex: 1;
      overflow: auto; /* allow scrolling */
      border: 1px solid #ccc;
      clip-path: inset(0);
    }
    #treeViewContent {
      position: relative;
      overflow: hidden; /* clip any overflowing content */
    }
    .tree-row {
      display: flex;
      align-items: center;
      height: 24px;
      border-bottom: 1px solid #eee;
      overflow: hidden; /* clip row contents when scrolled */
    }
    .toggle {
      display: inline-block;
      width: 16px;
      text-align: center;
      user-select: none;
      cursor: pointer;
    }
    .copy-button {
      margin-left: 8px;
      font-size: 0.8em;
      display: none;
    }
    .tree-row:hover .copy-button {
      display: inline;
    }
    /* Filter Panel */
    .filter-panel {
      border: 1px solid #ccc;
      border-radius: 4px;
      margin: 0.5em 0;  /* reduced margin between tabs and filter panel */
      overflow: hidden;
    }
    .filter-toggle {
      background: #eee;
      padding: 0.5em;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .filter-toggle .toggle-icon {
      font-size: 1em;
    }
    /* The filter content is hidden unless the panel has the "expanded" class.
       We add the "expanded" class by default in the HTML so the filters are visible on load. */
    .filter-panel .filter-content {
      display: none;
    }
    .filter-panel.expanded .filter-content {
      display: block;
    }
    /* Each row in the filter content */
    .filter-row {
      margin-bottom: 0.5em;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.5em;
    }
    .filter-row label,
    .filter-row input,
    .filter-row button {
      margin-right: 0.5em;
    }
    /* Tag container */
    .tag-container {
      display: inline-block;
      border: 1px solid #ccc;
      padding: 2px;
      min-width: 200px;
      margin-right: 8px;
      border-radius: 4px;
      vertical-align: middle;
    }
    .tag-container input {
      border: none;
      outline: none;
      font-family: inherit;
    }
    .tag {
      display: inline-block;
      background: #ddd;
      padding: 2px 6px;
      margin: 2px;
      border-radius: 4px;
      font-size: 0.9em;
    }
    .tag .remove {
      margin-left: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    /* Overlays */
    #cloudOverlay,
    #statsOverlay,
    #depsOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
    }
    .overlay-content {
      background: #fff;
      margin: 20px;
      padding: 1em;
      width: calc(100% - 40px);
      height: calc(100% - 40px);
      border: 4px solid rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      position: relative;
      overflow-y: auto;
    }
    #closeCloudOverlay,
    #closeStatsOverlay,
    #closeDepsOverlay {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
    }
    .cloud-tag {
      display: inline-block;
      margin: 4px;
      padding: 2px 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #f9f9f9;
    }
    #overlayStatsContent ul,
    #overlayDepsContent ul {
      list-style: none;
      padding: 0;
    }
    #overlayStatsContent li,
    #overlayDepsContent li {
      padding: 0.5em 0;
      border-bottom: 1px solid #eee;
    }
    /* Responsive adjustments for mobile */
    @media (max-width: 600px) {
      .filter-panel .filter-content > * {
        margin-bottom: 0.5em;
        width: 100%;
      }
      .tag-container {
        min-width: 100%;
      }
      #treeGridHeader .header-cell {
        padding: 0 2px;
      }
      .tree-row {
        height: 32px;
      }
      .tree-row .toggle {
        width: 20px;
      }
      .header-container {
        flex-direction: column;  /* stack logo and buttons vertically */
        align-items: flex-start;
      }
      .top-right-buttons {
        margin-top: 0.5em;  /* add some spacing between logo and buttons */
      }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <!-- Header container for logo and top-right buttons -->
    <div class="header-container">
      <h1>DXF Parser</h1>
      <div class="top-right-buttons">
        <button id="expandAllBtn">Expand All</button>
        <button id="collapseAllBtn">Collapse All</button>
        <button id="showCloudOverlayBtn">Show Cloud Data</button>
        <button id="showStatsOverlayBtn">Show DXF Statistics</button>
        <button id="showDepsOverlayBtn">Show DXF Dependencies</button>
      </div>
    </div>
    <!-- File input and parse button on the same line -->
    <div class="file-input-row">
      <input type="file" id="fileInput" accept=".dxf" multiple>
      <button id="parseBtn">Parse File(s)</button>
    </div>
    <!-- Navigation history container with controls and list -->
    <div id="navHistoryContainer">
      <div id="navHistoryControls">
        <button id="backBtn" disabled>Back</button>
        <button id="forwardBtn" disabled>Forward</button>
        <button id="clearHistoryBtn">Clear</button>
      </div>
      <div id="navHistoryList"></div>
    </div>
    <div id="tabContainer"></div>

    <!-- Filter Panel – filtering controls (visible by default via the "expanded" class) -->
    <div class="filter-panel expanded" id="filterPanel">
      <div class="filter-toggle">
        <span>Filters</span>
        <span class="toggle-icon">▲</span>
      </div>
      <div class="filter-content">
        <!-- First row: tag inputs and checkboxes -->
        <div class="filter-row">
          <div id="codeSearchTags" class="tag-container">
            <input type="text" id="codeSearchInput" placeholder="Search by Code">
          </div>
          <div id="dataSearchTags" class="tag-container">
            <input type="text" id="dataSearchInput" placeholder="Search by Data value">
          </div>
          <label>
            <input type="checkbox" id="dataExactCheckbox"> Exact Data Match
          </label>
          <label>
            <input type="checkbox" id="dataCaseCheckbox"> Case Sensitive
          </label>
        </div>
        <!-- Second row: line filters and go-to-handle input/button -->
        <div class="filter-row">
          <label for="minLineInput">Min Line:</label>
          <input type="number" id="minLineInput" style="width:80px;">
          <label for="maxLineInput">Max Line:</label>
          <input type="number" id="maxLineInput" style="width:80px;">
          <input type="text" id="handleSearchInput" placeholder="Go to Handle">
          <button id="goToHandleBtn">Go</button>
        </div>
        <!-- Third row: search and clear buttons -->
        <div class="filter-row">
          <button id="searchBtn">Search</button>
          <button id="clearSearchBtn">Clear Search</button>
        </div>
      </div>
    </div>
    <!-- Tree Grid Header -->
    <div id="treeGridHeader" class="tree-header">
      <div class="tree-line header-cell flex-fixed" data-field="line" data-sort="none" style="width: 100px; text-align: left;">
        Line <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
      <div class="tree-code header-cell flex-fixed" data-field="code" data-sort="none" style="width: 100px; text-align: left;">
        Code <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
      <div class="tree-data header-cell flex-grow" data-field="type" data-sort="none" style="flex: 1;">
        Data <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
      <div class="tree-object-count header-cell flex-fixed" data-field="objectCount" data-sort="none" style="width: 100px; text-align: right;">
        Object Count <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
      <div class="tree-data-size header-cell flex-fixed" data-field="dataSize" data-sort="none" style="width: 100px; text-align: right;">
        Data Size <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
    </div>
    <div id="treeViewContainer">
      <div id="treeViewContent"></div>
    </div>
  </div>

  <!-- Overlays -->
  <div id="cloudOverlay">
    <div class="overlay-content">
      <button id="closeCloudOverlay">Close</button>
      <h2>Cloud Data</h2>
      <h3>Object Cloud</h3>
      <div id="overlayObjectCloud"></div>
      <h3>Code Cloud</h3>
      <div id="overlayCodeCloud"></div>
    </div>
  </div>

  <div id="statsOverlay">
    <div class="overlay-content">
      <button id="closeStatsOverlay">Close</button>
      <h2>DXF Statistics</h2>
      <div id="overlayStatsContent"></div>
    </div>
  </div>

  <div id="depsOverlay">
    <div class="overlay-content">
      <button id="closeDepsOverlay">Close</button>
      <h2>DXF Dependencies</h2>
      <div id="overlayDepsContent"></div>
    </div>
  </div>

  <!-- DXF Parser, VirtualTreeView, and App classes -->
  <script>
    class DxfParser {
      constructor() {
        this.containerMapping = {
          "SECTION": "ENDSEC",
          "BLOCK":   "ENDBLK",
          "TABLE":   "ENDTAB",
          "OBJECT":  "ENDOBJ",
          "POLYLINE": "SEQEND"
        };
        this.nextId = 1;
        // List of DXF handle codes we consider.
        this.handleCodes = [5, 105, 330, 350, 360];
      }
      parse(text) {
        const tags = this.parseDxf(text);
        const grouped = this.groupObjects(tags, 0);
        return grouped.objects;
      }
      parseDxf(text) {
        const lines = text.split(/\r?\n/);
        const tags = [];
        for (let i = 0; i < lines.length; i++) {
          const codeLine = lines[i].trim();
          if (!codeLine) continue;
          const code = parseInt(codeLine, 10);
          if (isNaN(code)) continue;
          let value = "";
          if (i + 1 < lines.length) {
            value = lines[i + 1].trim();
          }
          i++;
          tags.push({ line: i, code, value });
        }
        return tags;
      }
      groupObjects(tags, startIndex, endMarker = null) {
        const objects = [];
        let i = startIndex;
        while (i < tags.length) {
          if (endMarker && tags[i].code === 0 && tags[i].value.toUpperCase() === endMarker) {
            i++;
            return { objects, nextIndex: i };
          }
          if (tags[i].code !== 0) {
            i++;
            continue;
          }
          const obj = {
            id: this.nextId++,
            type: tags[i].value,
            line: tags[i].line,
            properties: [],
            children: [],
            isContainer: this.containerMapping.hasOwnProperty(tags[i].value.toUpperCase()),
            expanded: false
          };
          i++;
          while (i < tags.length && tags[i].code !== 0) {
            obj.properties.push(tags[i]);
            i++;
          }
          const handleProp = obj.properties.find(prop => this.handleCodes.includes(prop.code));
          if (handleProp) {
            obj.handle = handleProp.value;
          }
          if (obj.isContainer) {
            const marker = this.containerMapping[obj.type.toUpperCase()];
            const result = this.groupObjects(tags, i, marker);
            obj.children = result.objects;
            i = result.nextIndex;
          }
          objects.push(obj);
        }
        return { objects, nextIndex: i };
      }
      findNodeById(tree, id) {
        for (const obj of tree) {
          if (String(obj.id) === String(id)) return obj;
          if (obj.children && obj.children.length) {
            const result = this.findNodeById(obj.children, id);
            if (result) return result;
          }
        }
        return null;
      }
      serializeNode(node) {
        let lines = [];
        lines.push("0");
        lines.push(node.type);
        node.properties.forEach(prop => {
          lines.push(prop.code.toString());
          lines.push(prop.value);
        });
        if (node.isContainer && node.children && node.children.length) {
          node.children.forEach(child => {
            lines.push(this.serializeNode(child));
          });
          const endMarker = this.containerMapping[node.type.toUpperCase()];
          if (endMarker) {
            lines.push("0");
            lines.push(endMarker);
          }
        }
        return lines.join("\n");
      }
    }
  </script>

  <script>
    class VirtualTreeView {
      constructor(container, content, options = {}) {
        this.container = container;
        this.content = content;
        this.itemHeight = options.itemHeight || 24;
        this.copyCallback = options.copyCallback || null;
        this.onToggleExpand = options.onToggleExpand || null;
        this.onHandleClick = options.onHandleClick || null;
        this.getLineWidth = options.getLineWidth || (() => 100);
        this.getCodeWidth = options.getCodeWidth || (() => 100);
        this.getDataWidth = options.getDataWidth || (() => null);
        this.columnWidths = options.columnWidths;
        this.flatData = [];
        this.treeData = [];
        this.container.addEventListener("scroll", () => {
          requestAnimationFrame(() => this.updateVisibleNodes());
        });
        this.content.addEventListener("click", (e) => {
          if (e.target.classList.contains("toggle")) {
            const row = e.target.closest(".tree-row");
            if (row) {
              const nodeId = row.dataset.id;
              if (this.onToggleExpand) {
                this.onToggleExpand(nodeId);
              }
            }
          }
        });
      }
      setData(treeData) {
        this.treeData = treeData || [];
        this.refresh();
      }
      refresh() {
        this.flatData = this.flattenTree(this.treeData);
        console.log("Total rows:", this.flatData.length);
        this.updateVisibleNodes();
      }
      flattenTree(nodes, level = 0) {
        let flat = [];
        for (let node of nodes) {
          flat.push({ node, level });
          if (node.expanded) {
            if (node.properties && node.properties.length) {
              for (let prop of node.properties) {
                flat.push({
                  node: {
                    id: `prop-${node.id}-${prop.line}-${prop.code}`,
                    isProperty: true,
                    line: prop.line,
                    code: prop.code,
                    data: prop.value
                  },
                  level: level + 1
                });
              }
            }
            if (node.children && node.children.length) {
              flat = flat.concat(this.flattenTree(node.children, level + 1));
            }
          }
        }
        return flat;
      }
      computeObjectCount(node) {
        if (!node.children || node.children.length === 0) return 0;
        let count = 0;
        for (let child of node.children) {
          if (!child.isProperty) {
            count++;
            if (child.children && child.children.length) {
              count += this.computeObjectCount(child);
            }
          }
        }
        return count;
      }
      computeDataSize(node) {
        let size = 0;
        if (node.isProperty) {
          size += node.data ? node.data.length : 0;
        } else {
          size += node.type ? node.type.length : 0;
          if (node.properties && node.properties.length) {
            for (let prop of node.properties) {
              size += prop.value ? prop.value.length : 0;
            }
          }
          if (node.children && node.children.length) {
            for (let child of node.children) {
              size += this.computeDataSize(child);
            }
          }
        }
        return size;
      }
      updateVisibleNodes() {
        const scrollTop = this.container.scrollTop;
        const containerHeight = this.container.clientHeight;
        const totalRows = this.flatData.length;
        const fullHeight = totalRows * this.itemHeight;
        this.content.style.height = fullHeight + "px";
        const startIndex = Math.floor(scrollTop / this.itemHeight);
        const visibleCount = Math.ceil(containerHeight / this.itemHeight) + 1;
        const endIndex = Math.min(startIndex + visibleCount, totalRows);
        const containerElem = document.createElement("div");
        const topSpacer = document.createElement("div");
        topSpacer.style.height = (startIndex * this.itemHeight) + "px";
        containerElem.appendChild(topSpacer);
        const fragment = document.createDocumentFragment();
        for (let i = startIndex; i < endIndex; i++) {
          const { node, level } = this.flatData[i];
          const row = document.createElement("div");
          row.className = "tree-row tree-node";
          row.style.display = "flex";
          row.style.position = "relative";
          row.style.height = this.itemHeight + "px";
          row.dataset.id = node.id;
          const lineDiv = document.createElement("div");
          lineDiv.className = "tree-line";
          const lineWidth = this.getLineWidth();
          if (lineWidth) { lineDiv.style.width = lineWidth + "px"; }
          lineDiv.style.textAlign = "left";
          const lineContent = document.createElement("div");
          lineContent.style.display = "flex";
          lineContent.style.alignItems = "center";
          lineContent.style.marginLeft = (level * 20) + "px";
          if (!node.isProperty && ((node.properties && node.properties.length) || (node.children && node.children.length))) {
            const toggleSpan = document.createElement("span");
            toggleSpan.className = "toggle";
            toggleSpan.textContent = node.expanded ? "▼" : "►";
            lineContent.appendChild(toggleSpan);
          } else {
            const spacer = document.createElement("span");
            spacer.style.width = "16px";
            spacer.style.display = "inline-block";
            lineContent.appendChild(spacer);
          }
          const lineNumberSpan = document.createElement("span");
          lineNumberSpan.textContent = node.line || "";
          lineContent.appendChild(lineNumberSpan);
          lineDiv.appendChild(lineContent);
          row.appendChild(lineDiv);
          const codeDiv = document.createElement("div");
          codeDiv.className = "tree-code";
          const codeWidth = this.getCodeWidth();
          if (codeWidth) { codeDiv.style.width = codeWidth + "px"; }
          codeDiv.style.textAlign = "left";
          if (node.isProperty) {
            codeDiv.textContent = node.code;
          } else {
            codeDiv.textContent = ((node.properties && node.properties.length) || (node.children && node.children.length)) ? "0" : "";
          }
          row.appendChild(codeDiv);
          const dataDiv = document.createElement("div");
          dataDiv.className = "tree-data";
          const dataWidth = this.getDataWidth();
          if (dataWidth) {
            dataDiv.style.width = dataWidth + "px";
            dataDiv.style.flex = "0 0 auto";
          } else {
            dataDiv.style.flex = "1";
          }
          const handleCodes = [5, 105, 330, 350, 360];
          if (node.isProperty) {
            if (handleCodes.includes(Number(node.code))) {
              const a = document.createElement("a");
              a.href = "#";
              a.textContent = node.data;
              a.style.textDecoration = "underline";
              a.style.color = "blue";
              a.addEventListener("click", (e) => {
                e.preventDefault();
                if (this.onHandleClick) {
                  this.onHandleClick(node.data);
                }
              });
              dataDiv.appendChild(a);
            } else {
              dataDiv.textContent = node.data;
            }
          } else {
            dataDiv.textContent = node.type || "";
            if (node.handle) {
              const spanHandle = document.createElement("span");
              spanHandle.textContent = " (" + node.handle + ")";
              spanHandle.style.textDecoration = "underline";
              spanHandle.style.color = "blue";
              spanHandle.style.cursor = "pointer";
              spanHandle.addEventListener("click", (e) => {
                e.preventDefault();
                if (this.onHandleClick) {
                  this.onHandleClick(node.handle);
                }
              });
              dataDiv.appendChild(spanHandle);
            }
            if (this.copyCallback && !node.isProperty) {
              const copyButton = document.createElement("button");
              copyButton.textContent = "Copy";
              copyButton.className = "copy-button";
              copyButton.addEventListener("click", (e) => {
                e.stopPropagation();
                this.copyCallback(node.id);
              });
              dataDiv.appendChild(copyButton);
            }
          }
          row.appendChild(dataDiv);
          const objectCountDiv = document.createElement("div");
          objectCountDiv.className = "tree-object-count";
          objectCountDiv.style.width = this.columnWidths.objectCount + "px";
          objectCountDiv.style.textAlign = "right";
          if (!node.isProperty && node.children && node.children.length) {
            objectCountDiv.textContent = this.computeObjectCount(node);
          } else {
            objectCountDiv.textContent = "";
          }
          row.appendChild(objectCountDiv);
          const dataSizeDiv = document.createElement("div");
          dataSizeDiv.className = "tree-data-size";
          dataSizeDiv.style.width = this.columnWidths.dataSize + "px";
          dataSizeDiv.style.textAlign = "right";
          dataSizeDiv.textContent = this.computeDataSize(node);
          row.appendChild(dataSizeDiv);
          fragment.appendChild(row);
        }
        containerElem.appendChild(fragment);
        const bottomSpacer = document.createElement("div");
        const bottomHeight = Math.max(0, fullHeight - (startIndex + visibleCount) * this.itemHeight);
        bottomSpacer.style.height = bottomHeight + "px";
        containerElem.appendChild(bottomSpacer);
        this.content.innerHTML = "";
        this.content.appendChild(containerElem);
      }
    }
  </script>

  <script>
    class App {
      constructor() {
        this.columnWidths = { line: 100, code: 100, type: null, objectCount: 100, dataSize: 100 };
        this.dxfParser = new DxfParser();
        this.treeViewContainer = document.getElementById("treeViewContainer");
        this.treeViewContent = document.getElementById("treeViewContent");
        this.tabs = [];
        this.activeTabId = null;
        this.myTreeView = new VirtualTreeView(this.treeViewContainer, this.treeViewContent, {
          itemHeight: 24,
          copyCallback: (nodeId) => this.handleCopy(nodeId),
          onToggleExpand: (nodeId) => this.handleToggleExpand(nodeId),
          onHandleClick: (handle) => this.handleLinkToHandle(handle),
          getLineWidth: () => this.columnWidths.line,
          getCodeWidth: () => this.columnWidths.code,
          getDataWidth: () => this.columnWidths.type,
          columnWidths: this.columnWidths
        });
        // Removed global navigation history in favor of per‑tab history.
        this.initEventListeners();
      }
      initEventListeners() {
        document.getElementById("parseBtn").addEventListener("click", () => this.handleParse());
        document.getElementById("expandAllBtn").addEventListener("click", () => this.handleExpandAll());
        document.getElementById("collapseAllBtn").addEventListener("click", () => this.handleCollapseAll());
        document.querySelectorAll('.header-cell').forEach(headerCell => {
          headerCell.addEventListener('click', (e) => {
            if (e.target.classList.contains('resizer')) return;
            this.handleHeaderClick(headerCell);
          });
        });
        document.querySelectorAll('.header-cell .resizer').forEach(resizer => {
          resizer.addEventListener('mousedown', (e) => this.handleResizerMouseDown(e));
        });
        this.setupTagInput("codeSearchInput", "code");
        this.setupTagInput("dataSearchInput", "data");
        document.getElementById("searchBtn").addEventListener("click", () => this.handleSearch());
        document.getElementById("clearSearchBtn").addEventListener("click", () => this.handleClearSearch());
        document.getElementById("showCloudOverlayBtn").addEventListener("click", () => {
          this.updateClouds();
          document.getElementById("cloudOverlay").style.display = "block";
        });
        document.getElementById("closeCloudOverlay").addEventListener("click", () => {
          document.getElementById("cloudOverlay").style.display = "none";
        });
        document.getElementById("showStatsOverlayBtn").addEventListener("click", () => {
          this.updateStats();
          document.getElementById("statsOverlay").style.display = "block";
        });
        document.getElementById("closeStatsOverlay").addEventListener("click", () => {
          document.getElementById("statsOverlay").style.display = "none";
        });
        document.getElementById("showDepsOverlayBtn").addEventListener("click", () => {
          this.updateDependencies();
          document.getElementById("depsOverlay").style.display = "block";
        });
        document.getElementById("closeDepsOverlay").addEventListener("click", () => {
          document.getElementById("depsOverlay").style.display = "none";
        });
        document.getElementById("dataExactCheckbox").addEventListener("change", () => this.handleSearchOptionChange());
        document.getElementById("dataCaseCheckbox").addEventListener("change", () => this.handleSearchOptionChange());
        document.getElementById("codeSearchInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("dataSearchInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("minLineInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("maxLineInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("goToHandleBtn").addEventListener("click", () => this.handleGoToHandle());
        // Navigation controls from the history area.
        document.getElementById("backBtn").addEventListener("click", () => this.navigateBack());
        document.getElementById("forwardBtn").addEventListener("click", () => this.navigateForward());
        document.getElementById("clearHistoryBtn").addEventListener("click", () => this.clearNavigationHistory());
        const filterToggle = document.querySelector('.filter-toggle');
        if(filterToggle) {
          filterToggle.addEventListener('click', () => {
            const panel = filterToggle.parentElement;
            panel.classList.toggle('expanded');
            const icon = filterToggle.querySelector('.toggle-icon');
            icon.textContent = panel.classList.contains('expanded') ? '▲' : '▼';
          });
        }
        // --- Sync header horizontal position on scroll ---
        this.treeViewContainer.addEventListener("scroll", (e) => {
          const scrollLeft = e.target.scrollLeft;
          document.getElementById("treeGridHeader").style.transform = "translateX(-" + scrollLeft + "px)";
        });
        // --- Update row layouts on window resize ---
        window.addEventListener("resize", () => {
          this.myTreeView.updateVisibleNodes();
        });
      }
      updateEffectiveSearchTerms() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const codeInput = document.getElementById("codeSearchInput");
        const dataInput = document.getElementById("dataSearchInput");
        const codeText = codeInput.value.trim();
        const dataText = dataInput.value.trim();
        const effectiveCodeSearchTerms = activeTab.codeSearchTerms.slice();
        const effectiveDataSearchTerms = activeTab.dataSearchTerms.slice();
        if (codeText !== "" && !effectiveCodeSearchTerms.includes(codeText)) {
          effectiveCodeSearchTerms.push(codeText);
        }
        if (dataText !== "" && !effectiveDataSearchTerms.includes(dataText)) {
          effectiveDataSearchTerms.push(dataText);
        }
        const minLineInputVal = document.getElementById("minLineInput").value.trim();
        const maxLineInputVal = document.getElementById("maxLineInput").value.trim();
        const minLine = minLineInputVal !== "" ? parseInt(minLineInputVal, 10) : null;
        const maxLine = maxLineInputVal !== "" ? parseInt(maxLineInputVal, 10) : null;
        activeTab.minLine = minLine;
        activeTab.maxLine = maxLine;
        activeTab.dataExact = document.getElementById("dataExactCheckbox").checked;
        activeTab.dataCase = document.getElementById("dataCaseCheckbox").checked;
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          minLine,
          maxLine
        );
        this.myTreeView.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      handleSearchOptionChange() {
        this.updateEffectiveSearchTerms();
      }
      getActiveTab() {
        return this.tabs.find(t => t.id === this.activeTabId);
      }
      updateTabUI() {
        const tabContainer = document.getElementById("tabContainer");
        tabContainer.innerHTML = "";
        this.tabs.forEach(tab => {
          const tabElem = document.createElement("div");
          tabElem.className = "tab" + (tab.id === this.activeTabId ? " active" : "");
          tabElem.textContent = tab.name;
          tabElem.dataset.tabId = tab.id;
          tabElem.addEventListener("click", () => {
            this.activeTabId = tab.id;
            // Update global inputs from this tab’s filter state.
            document.getElementById("codeSearchInput").value = "";
            document.getElementById("dataSearchInput").value = "";
            this.updateTagContainer("codeSearchTags", tab.codeSearchTerms, "code");
            this.updateTagContainer("dataSearchTags", tab.dataSearchTerms, "data");
            document.getElementById("minLineInput").value = tab.minLine !== null ? tab.minLine : "";
            document.getElementById("maxLineInput").value = tab.maxLine !== null ? tab.maxLine : "";
            document.getElementById("dataExactCheckbox").checked = tab.dataExact || false;
            document.getElementById("dataCaseCheckbox").checked = tab.dataCase || false;
            this.myTreeView.setData(tab.currentTreeData);
            this.updateTabUI();
          });
          const closeBtn = document.createElement("span");
          closeBtn.className = "close-tab";
          closeBtn.textContent = "×";
          closeBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            this.tabs = this.tabs.filter(t => t.id !== tab.id);
            if (this.activeTabId === tab.id) {
              this.activeTabId = this.tabs.length ? this.tabs[0].id : null;
            }
            this.updateTabUI();
            if (this.activeTabId) {
              this.myTreeView.setData(this.getActiveTab().currentTreeData);
            } else {
              this.myTreeView.setData([]);
            }
          });
          tabElem.appendChild(closeBtn);
          tabContainer.appendChild(tabElem);
        });
        // Update navigation UI based on the active tab.
        this.updateNavHistoryUI();
        this.updateNavButtons();
      }
      expandAllNodes(nodes) {
        nodes.forEach(node => {
          if ((node.properties && node.properties.length) || (node.children && node.children.length)) {
            node.expanded = true;
            this.expandAllNodes(node.children);
          }
        });
      }
      collapseAllNodes(nodes) {
        nodes.forEach(node => {
          node.expanded = false;
          this.collapseAllNodes(node.children);
        });
      }
      handleExpandAll() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        this.expandAllNodes(activeTab.originalTreeData);
        if (activeTab.currentSortField) {
          this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
        }
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeView.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      handleCollapseAll() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        this.collapseAllNodes(activeTab.originalTreeData);
        if (activeTab.currentSortField) {
          this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
        }
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeView.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      handleToggleExpand(nodeId) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const node = this.dxfParser.findNodeById(activeTab.originalTreeData, nodeId);
        if (node) {
          node.expanded = !node.expanded;
          if (activeTab.currentSortField) {
            this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
          }
          activeTab.currentTreeData = this.filterTree(
            activeTab.originalTreeData,
            activeTab.codeSearchTerms,
            activeTab.dataSearchTerms,
            activeTab.dataExact,
            activeTab.dataCase,
            activeTab.minLine,
            activeTab.maxLine
          );
          this.myTreeView.setData(activeTab.currentTreeData);
        }
      }
      getSortValue(node, field) {
        if (field === "line") {
          return node.line ? Number(node.line) : 0;
        } else if (field === "code") {
          if (node.isProperty) {
            const c = parseInt(node.code, 10);
            return isNaN(c) ? Number.MAX_SAFE_INTEGER : c;
          }
          return 0;
        } else if (field === "type") {
          return node.isProperty ? (node.data || "") : (node.type || "");
        } else if (field === "objectCount") {
          if (node.isProperty) return 0;
          function countDescendants(n) {
            if (!n.children || n.children.length === 0) return 0;
            let count = 0;
            for (let child of n.children) {
              if (!child.isProperty) {
                count++;
                if (child.children && child.children.length) {
                  count += countDescendants(child);
                }
              }
            }
            return count;
          }
          return countDescendants(node);
        } else if (field === "dataSize") {
          function computeSize(n) {
            if (n.isProperty) {
              return n.data ? n.data.length : 0;
            } else {
              let size = n.type ? n.type.length : 0;
              if (n.properties && n.properties.length) {
                for (let prop of n.properties) {
                  size += prop.value ? prop.value.length : 0;
                }
              }
              if (n.children && n.children.length) {
                for (let child of n.children) {
                  size += computeSize(child);
                }
              }
              return size;
            }
          }
          return computeSize(node);
        }
        return "";
      }
      sortTreeNodes(nodes, field, ascending) {
        nodes.sort((a, b) => {
          const aVal = this.getSortValue(a, field);
          const bVal = this.getSortValue(b, field);
          if (field === "code" || field === "line" || field === "objectCount" || field === "dataSize") {
            return (aVal - bVal) * (ascending ? 1 : -1);
          } else {
            return aVal.localeCompare(bVal) * (ascending ? 1 : -1);
          }
        });
        nodes.forEach(node => {
          if (node.properties && node.properties.length) {
            node.properties.sort((aProp, bProp) => {
              if (field === "code") {
                const aC = parseInt(aProp.code, 10) || 0;
                const bC = parseInt(bProp.code, 10) || 0;
                return (aC - bC) * (ascending ? 1 : -1);
              } else if (field === "line") {
                const aL = aProp.line || 0;
                const bL = bProp.line || 0;
                return (aL - bL) * (ascending ? 1 : -1);
              } else if (field === "type") {
                const aV = aProp.value || "";
                const bV = bProp.value || "";
                return aV.localeCompare(bV) * (ascending ? 1 : -1);
              }
              return 0;
            });
          }
          if (node.children && node.children.length) {
            this.sortTreeNodes(node.children, field, ascending);
          }
        });
      }
      handleHeaderClick(headerCell) {
        const field = headerCell.getAttribute('data-field');
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        let currentSort = headerCell.getAttribute('data-sort');
        let ascending = true;
        if (currentSort === 'asc') {
          ascending = false;
          headerCell.setAttribute('data-sort', 'desc');
          headerCell.querySelector('.sort-indicator').textContent = ' ▼';
        } else {
          ascending = true;
          headerCell.setAttribute('data-sort', 'asc');
          headerCell.querySelector('.sort-indicator').textContent = ' ▲';
        }
        activeTab.currentSortField = field;
        activeTab.currentSortAscending = ascending;
        document.querySelectorAll('.header-cell').forEach(cell => {
          if (cell !== headerCell) {
            cell.setAttribute('data-sort', 'none');
            cell.querySelector('.sort-indicator').textContent = '';
          }
        });
        this.sortTreeNodes(activeTab.originalTreeData, field, ascending);
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeView.setData(activeTab.currentTreeData);
      }
      handleResizerMouseDown(e) {
        e.stopPropagation();
        const headerCell = e.target.parentElement;
        const field = headerCell.getAttribute('data-field');
        const startX = e.clientX;
        const startWidth = headerCell.offsetWidth;
        const onMouseMove = (eMove) => {
          const newWidth = startWidth + (eMove.clientX - startX);
          this.columnWidths[field] = newWidth;
          headerCell.style.width = newWidth + "px";
          headerCell.style.flex = "none";
          this.myTreeView.updateVisibleNodes();
        };
        const onMouseUp = () => {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        };
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      }
      filterTree(objects, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine) {
        const filtered = [];
        objects.forEach(obj => {
          const filteredObj = this.filterObject(obj, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine);
          if (filteredObj !== null) {
            filtered.push(filteredObj);
          }
        });
        return filtered;
      }
      filterObject(obj, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine) {
        // 1. Check if the node’s own line number is within bounds.
        let nodeLine = parseInt(obj.line, 10);
        let lineMatches = true;
        if (minLine != null && !isNaN(minLine)) {
          if (isNaN(nodeLine) || nodeLine < minLine) lineMatches = false;
        }
        if (maxLine != null && !isNaN(maxLine)) {
          if (isNaN(nodeLine) || nodeLine > maxLine) lineMatches = false;
        }
        // 2. Filter the node’s properties.
        const filteredProperties = obj.properties.filter(prop => {
          let propLine = parseInt(prop.line, 10);
          if (minLine != null && !isNaN(minLine)) {
            if (isNaN(propLine) || propLine < minLine) return false;
          }
          if (maxLine != null && !isNaN(maxLine)) {
            if (isNaN(propLine) || propLine > maxLine) return false;
          }
          // Code filter – if active, require a property’s code to match.
          const codeMatch = (codeTerms.length === 0) ||
            codeTerms.some(term => String(prop.code) === term);
          // Data filter – if active, test the property value.
          let dataMatch = true;
          if (dataTerms.length > 0) {
            if (dataExact) {
              dataMatch = dataTerms.some(term =>
                dataCase ? (prop.value === term)
                         : (prop.value.toLowerCase() === term.toLowerCase())
              );
            } else {
              dataMatch = dataTerms.some(term =>
                dataCase ? prop.value.includes(term)
                         : prop.value.toLowerCase().includes(term.toLowerCase())
              );
            }
          }
          return codeMatch && dataMatch;
        });
        // 3. Recursively filter child objects.
        const filteredChildren = obj.children
          .map(child => this.filterObject(child, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine))
          .filter(child => child !== null);
        // 4. Determine which search filters are “active.”
        const codeFilterActive = codeTerms.length > 0;
        const dataFilterActive = dataTerms.length > 0;
        // For the node’s own type, check it only if the data filter is active.
        let typeMatchesData = false;
        if (dataFilterActive) {
          if (dataExact) {
            typeMatchesData = dataTerms.some(term =>
              dataCase ? (obj.type === term)
                       : (obj.type.toLowerCase() === term.toLowerCase())
            );
          } else {
            typeMatchesData = dataTerms.some(term =>
              dataCase ? obj.type.includes(term)
                       : obj.type.toLowerCase().includes(term.toLowerCase())
            );
          }
        }
        // 5. Now decide whether to keep the node.
        // If no search filters are active, fall back to line-matching:
        if (!codeFilterActive && !dataFilterActive) {
          if (!lineMatches && filteredProperties.length === 0 && filteredChildren.length === 0) {
            return null;
          }
          return {
            ...obj,
            properties: filteredProperties,
            children: filteredChildren
          };
        }
        // If a code filter is active but no property or descendant matches, drop this node.
        if (codeFilterActive && filteredProperties.length === 0 && filteredChildren.length === 0) {
          return null;
        }
        // If a data filter is active but neither the node’s type nor any property/child matches, drop it.
        if (dataFilterActive && !(typeMatchesData || filteredProperties.length > 0 || filteredChildren.length > 0)) {
          return null;
        }
        // (Optionally, you may still want to drop the node if it fails the line filter and has no matches.)
        if (!lineMatches && filteredProperties.length === 0 && filteredChildren.length === 0) {
          return null;
        }
        // If the node passes all checks, return it with its filtered properties and children.
        return {
          ...obj,
          properties: filteredProperties,
          children: filteredChildren
        };
      }
      handleCopy(nodeId) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const node = this.dxfParser.findNodeById(activeTab.originalTreeData, nodeId);
        if (!node) {
          alert("Node not found in original data.");
          return;
        }
        const serialized = this.dxfParser.serializeNode(node);
        navigator.clipboard.writeText(serialized).then(() => {
          alert("Copied node to clipboard as valid DXF tags.");
        }, () => {
          alert("Failed to copy to clipboard.");
        });
      }
      handleParse() {
        const fileInput = document.getElementById("fileInput");
        if (!fileInput.files || fileInput.files.length === 0) {
          alert("Please select at least one DXF file.");
          return;
        }
        Array.from(fileInput.files).forEach(file => {
          const reader = new FileReader();
          reader.onload = (event) => {
            const text = event.target.result;
            const objects = this.dxfParser.parse(text);
            const newTab = {
              id: Date.now() + Math.random(),
              name: file.name,
              originalTreeData: objects,
              currentTreeData: objects,
              codeSearchTerms: [],
              dataSearchTerms: [],
              currentSortField: "line",
              currentSortAscending: true,
              minLine: null,
              maxLine: null,
              dataExact: false,
              dataCase: false,
              // NEW per‑tab navigation history:
              navigationHistory: [],
              currentHistoryIndex: -1
            };
            this.tabs.push(newTab);
            this.activeTabId = newTab.id;
            this.updateTabUI();
            this.myTreeView.setData(newTab.currentTreeData);
          };
          reader.readAsText(file, "ascii");
        });
      }
      createTagElement(text, type) {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = text;
        const removeBtn = document.createElement("span");
        removeBtn.className = "remove";
        removeBtn.textContent = "×";
        removeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          const activeTab = this.getActiveTab();
          if (!activeTab) return;
          if (type === "code") {
            activeTab.codeSearchTerms = activeTab.codeSearchTerms.filter(term => term !== text);
            this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
          } else if (type === "data") {
            activeTab.dataSearchTerms = activeTab.dataSearchTerms.filter(term => term !== text);
            this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
          }
          activeTab.currentTreeData = this.filterTree(
            activeTab.originalTreeData,
            activeTab.codeSearchTerms,
            activeTab.dataSearchTerms,
            activeTab.dataExact,
            activeTab.dataCase,
            activeTab.minLine,
            activeTab.maxLine
          );
          this.myTreeView.setData(activeTab.currentTreeData);
          this.treeViewContainer.scrollTop = 0;
        });
        tag.appendChild(removeBtn);
        return tag;
      }
      updateTagContainer(containerId, termsArray, type) {
        const container = document.getElementById(containerId);
        Array.from(container.querySelectorAll(".tag")).forEach(tag => tag.remove());
        termsArray.forEach(term => {
          const tagElem = this.createTagElement(term, type);
          container.insertBefore(tagElem, container.querySelector("input"));
        });
      }
      setupTagInput(inputId, type) {
        const input = document.getElementById(inputId);
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === ",") {
            e.preventDefault();
            const text = input.value.trim();
            if (text !== "") {
              const activeTab = this.getActiveTab();
              if (!activeTab) return;
              if (type === "code") {
                if (!activeTab.codeSearchTerms.includes(text)) {
                  activeTab.codeSearchTerms.push(text);
                }
                this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
              } else {
                if (!activeTab.dataSearchTerms.includes(text)) {
                  activeTab.dataSearchTerms.push(text);
                }
                this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
              }
              input.value = "";
              this.updateEffectiveSearchTerms();
            }
          }
        });
        input.addEventListener("blur", () => {
          const text = input.value.trim();
          if (text !== "") {
            const activeTab = this.getActiveTab();
            if (!activeTab) return;
            if (type === "code") {
              if (!activeTab.codeSearchTerms.includes(text)) {
                activeTab.codeSearchTerms.push(text);
              }
              this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
            } else {
              if (!activeTab.dataSearchTerms.includes(text)) {
                activeTab.dataSearchTerms.push(text);
              }
              this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
            }
            input.value = "";
            this.updateEffectiveSearchTerms();
          }
        });
      }
      handleSearch() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const codeInput = document.getElementById("codeSearchInput");
        const dataInput = document.getElementById("dataSearchInput");
        if (codeInput.value.trim() !== "") {
          const text = codeInput.value.trim();
          if (!activeTab.codeSearchTerms.includes(text)) {
            activeTab.codeSearchTerms.push(text);
          }
          this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
          codeInput.value = "";
        }
        if (dataInput.value.trim() !== "") {
          const text = dataInput.value.trim();
          if (!activeTab.dataSearchTerms.includes(text)) {
            activeTab.dataSearchTerms.push(text);
          }
          this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
          dataInput.value = "";
        }
        this.updateEffectiveSearchTerms();
      }
      handleClearSearch() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        activeTab.codeSearchTerms = [];
        activeTab.dataSearchTerms = [];
        activeTab.minLine = null;
        activeTab.maxLine = null;
        this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
        this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
        document.getElementById("codeSearchInput").value = "";
        document.getElementById("dataSearchInput").value = "";
        document.getElementById("dataExactCheckbox").checked = false;
        document.getElementById("dataCaseCheckbox").checked = false;
        document.getElementById("minLineInput").value = "";
        document.getElementById("maxLineInput").value = "";
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          false,
          false,
          null,
          null
        );
        this.myTreeView.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      findPathByHandle(nodes, handle) {
        for (const node of nodes) {
          if (node.handle && node.handle.toUpperCase() === handle.toUpperCase()) {
            return [node];
          }
          if (node.children && node.children.length) {
            const subPath = this.findPathByHandle(node.children, handle);
            if (subPath) {
              return [node, ...subPath];
            }
          }
        }
        return null;
      }
      // Navigation by handle with history tracking.
      navigateToHandle(handle, addHistory = true) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const path = this.findPathByHandle(activeTab.originalTreeData, handle);
        if (!path) {
          alert("Definition not found for handle: " + handle);
          return;
        }
        // Expand the path to ensure the target is visible.
        path.forEach(node => node.expanded = true);
        activeTab.currentTreeData = activeTab.originalTreeData;
        this.myTreeView.setData(activeTab.currentTreeData);
        setTimeout(() => {
          const targetNodeId = path[path.length - 1].id;
          const flatData = this.myTreeView.flatData;
          const targetIndex = flatData.findIndex(item => String(item.node.id) === String(targetNodeId));
          if (targetIndex >= 0) {
            this.treeViewContainer.scrollTop = targetIndex * this.myTreeView.itemHeight;
            const element = this.treeViewContent.querySelector(`[data-id="${targetNodeId}"]`);
            if (element) {
              element.style.backgroundColor = "yellow";
              setTimeout(() => { element.style.backgroundColor = ""; }, 2000);
            }
          }
        }, 300);
        if (addHistory) {
          // If not at the end of history, remove forward history.
          if (activeTab.currentHistoryIndex < activeTab.navigationHistory.length - 1) {
            activeTab.navigationHistory.splice(activeTab.currentHistoryIndex + 1);
          }
          activeTab.navigationHistory.push(handle);
          activeTab.currentHistoryIndex = activeTab.navigationHistory.length - 1;
          this.updateNavHistoryUI();
          this.updateNavButtons();
        }
      }
      handleGoToHandle() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const handleValue = document.getElementById("handleSearchInput").value.trim();
        if (!handleValue) return;
        this.navigateToHandle(handleValue, true);
      }
      handleLinkToHandle(handle) {
        // This method is now simply a proxy to navigateToHandle.
        this.navigateToHandle(handle, true);
      }
      // Navigation history UI updates.
      updateNavHistoryUI() {
        const activeTab = this.getActiveTab();
        const listContainer = document.getElementById("navHistoryList");
        listContainer.innerHTML = "";
        if (!activeTab) return;
        activeTab.navigationHistory.forEach((handle, index) => {
          const span = document.createElement("span");
          span.textContent = handle;
          span.style.cursor = "pointer";
          span.style.marginRight = "8px";
          if (index === activeTab.currentHistoryIndex) {
            span.style.fontWeight = "bold";
            span.style.textDecoration = "underline";
          }
          span.addEventListener("click", () => {
            activeTab.currentHistoryIndex = index;
            this.navigateToHandle(handle, false);
            this.updateNavHistoryUI();
            this.updateNavButtons();
          });
          listContainer.appendChild(span);
        });
      }
      updateNavButtons() {
        const activeTab = this.getActiveTab();
        const backBtn = document.getElementById("backBtn");
        const forwardBtn = document.getElementById("forwardBtn");
        if (!activeTab) {
          backBtn.disabled = true;
          forwardBtn.disabled = true;
          return;
        }
        backBtn.disabled = activeTab.currentHistoryIndex <= 0;
        forwardBtn.disabled = activeTab.currentHistoryIndex >= activeTab.navigationHistory.length - 1;
      }
      navigateBack() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        if (activeTab.currentHistoryIndex > 0) {
          activeTab.currentHistoryIndex--;
          const handle = activeTab.navigationHistory[activeTab.currentHistoryIndex];
          this.navigateToHandle(handle, false);
          this.updateNavHistoryUI();
          this.updateNavButtons();
        }
      }
      navigateForward() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        if (activeTab.currentHistoryIndex < activeTab.navigationHistory.length - 1) {
          activeTab.currentHistoryIndex++;
          const handle = activeTab.navigationHistory[activeTab.currentHistoryIndex];
          this.navigateToHandle(handle, false);
          this.updateNavHistoryUI();
          this.updateNavButtons();
        }
      }
      clearNavigationHistory() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        activeTab.navigationHistory = [];
        activeTab.currentHistoryIndex = -1;
        this.updateNavHistoryUI();
        this.updateNavButtons();
      }
      updateClouds() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayObjectCloud").innerHTML = "";
          document.getElementById("overlayCodeCloud").innerHTML = "";
          return;
        }
        const objectCounts = {};
        const codeCounts = {};
        function traverse(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty) {
              objectCounts[node.type] = (objectCounts[node.type] || 0) + 1;
              node.properties.forEach(prop => {
                codeCounts[prop.code] = (codeCounts[prop.code] || 0) + 1;
              });
              if (node.children && node.children.length > 0) {
                traverse(node.children);
              }
            }
          });
        }
        traverse(activeTab.originalTreeData);
        const populateCloud = (element, counts, minFont, maxFont, cloudType) => {
          element.innerHTML = "";
          const maxCount = Math.max(...Object.values(counts), 1);
          for (const key in counts) {
            const count = counts[key];
            const fontSize = minFont + ((count / maxCount) * (maxFont - minFont));
            const span = document.createElement("span");
            span.className = "cloud-tag";
            span.style.fontSize = fontSize + "px";
            span.textContent = `${key} (${count})`;
            span.addEventListener("click", () => {
              this.handleCloudTagClick(cloudType, key);
            });
            element.appendChild(span);
          }
        };
        const minFont = 12, maxFont = 36;
        const overlayObjectCloudElem = document.getElementById("overlayObjectCloud");
        const overlayCodeCloudElem = document.getElementById("overlayCodeCloud");
        populateCloud(overlayObjectCloudElem, objectCounts, minFont, maxFont, "object");
        populateCloud(overlayCodeCloudElem, codeCounts, minFont, maxFont, "code");
      }
      updateStats() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayStatsContent").innerHTML = "No DXF data loaded.";
          return;
        }
        function computeStats(nodes, depth = 1) {
          let stats = {
            totalObjects: 0,
            totalProperties: 0,
            maxDepth: depth,
            totalDataSize: 0,
            countByType: {}
          };
          nodes.forEach(node => {
            if (!node.isProperty) {
              stats.totalObjects++;
              stats.countByType[node.type] = (stats.countByType[node.type] || 0) + 1;
              let nodeDataSize = node.type ? node.type.length : 0;
              if (node.properties && node.properties.length) {
                stats.totalProperties += node.properties.length;
                node.properties.forEach(prop => {
                  nodeDataSize += prop.value ? prop.value.length : 0;
                });
              }
              stats.totalDataSize += nodeDataSize;
              if (node.children && node.children.length) {
                const childStats = computeStats(node.children, depth + 1);
                stats.totalObjects += childStats.totalObjects;
                stats.totalProperties += childStats.totalProperties;
                stats.totalDataSize += childStats.totalDataSize;
                for (let type in childStats.countByType) {
                  stats.countByType[type] = (stats.countByType[type] || 0) + childStats.countByType[type];
                }
                if (childStats.maxDepth > stats.maxDepth) {
                  stats.maxDepth = childStats.maxDepth;
                }
              }
            }
          });
          return stats;
        }
        const stats = computeStats(activeTab.originalTreeData);
        const avgProps = stats.totalObjects > 0 ? (stats.totalProperties / stats.totalObjects).toFixed(2) : 0;
        const statsHtml = `
          <ul>
            <li><strong>Total Objects:</strong> ${stats.totalObjects}</li>
            <li><strong>Total Properties:</strong> ${stats.totalProperties}</li>
            <li><strong>Maximum Nesting Depth:</strong> ${stats.maxDepth}</li>
            <li><strong>Total Data Size:</strong> ${stats.totalDataSize} characters</li>
            <li><strong>Average Properties per Object:</strong> ${avgProps}</li>
            <li><strong>Object Type Counts:</strong>
              <ul>
                ${Object.entries(stats.countByType)
                  .map(([type, count]) => `<li>${type}: ${count}</li>`)
                  .join('')}
              </ul>
            </li>
          </ul>
        `;
        document.getElementById("overlayStatsContent").innerHTML = statsHtml;
      }
      updateDependencies() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayDepsContent").innerHTML = "No DXF data loaded.";
          return;
        }
        const dependencyTypes = ["LTYPE", "STYLE", "APPID", "LAYER", "DIMSTYLE", "VPORT", "XREF", "SHAPE"];
        const dependencies = {};
        dependencyTypes.forEach(type => dependencies[type] = []);
        function traverse(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty) {
              const type = node.type.toUpperCase();
              if (dependencyTypes.includes(type)) {
                dependencies[type].push(node);
              }
              if (node.children && node.children.length) {
                traverse(node.children);
              }
            }
          });
        }
        traverse(activeTab.originalTreeData);
        let html = "";
        dependencyTypes.forEach(depType => {
          if (dependencies[depType].length > 0) {
            html += `<h3>${depType} (${dependencies[depType].length})</h3><ul>`;
            dependencies[depType].forEach(dep => {
              let depInfo = `${dep.type} (Line ${dep.line})`;
              if (dep.properties && dep.properties.length) {
                const propSummary = dep.properties.map(p => `${p.code}:${p.value}`).join(", ");
                depInfo += ` [${propSummary}]`;
              }
              html += `<li>${depInfo}</li>`;
            });
            html += "</ul>";
          }
        });
        if (!html) {
          html = "No external dependency objects found.";
        }
        document.getElementById("overlayDepsContent").innerHTML = html;
      }
    }
    document.addEventListener("DOMContentLoaded", () => {
      new App();
    });
  </script>
</body>
</html>
