<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>DXF Parser</title>
  <style>
    /* ======= STYLES (Mostly the same as before) ======= */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .main-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      box-sizing: border-box;
      padding: 1em;
    }
    body {
      font-family: sans-serif;
    }
    #tabContainer {
      display: flex;
      border-bottom: 1px solid #ccc;
      margin: 1em 0;
    }
    .tab {
      padding: 0.5em 1em;
      border: 1px solid #ccc;
      border-bottom: none;
      cursor: pointer;
      margin-right: 2px;
      position: relative;
      background: #eee;
    }
    .tab.active {
      background: #fff;
      font-weight: bold;
    }
    .tab .close-tab {
      position: absolute;
      top: 0;
      right: 2px;
      cursor: pointer;
      padding: 0 4px;
    }
    .tree-header {
      display: flex;
      font-weight: bold;
      border-bottom: 1px solid #ccc;
      padding-bottom: 4px;
      margin-bottom: 4px;
      background: #eee;
      user-select: none;
    }
    .tree-header > div {
      display: flex;
      align-items: center;
      position: relative;
      padding: 0 4px;
      border-right: 1px solid #ccc;
    }
    .tree-header > div:last-child {
      border-right: none;
    }
    .header-cell {
      cursor: pointer;
    }
    .header-cell .resizer {
      position: absolute;
      right: 0;
      top: 0;
      width: 5px;
      height: 100%;
      cursor: col-resize;
    }
    .header-cell .sort-indicator {
      margin-left: 4px;
      font-size: 0.8em;
    }
    .tree-line, .tree-code {
      width: 100px;
      text-align: left;
    }
    .tree-data {
      flex: 1;
    }
    /* Virtual scroll container */
    #treeViewContainer {
      position: relative;
      flex: 1;
      overflow-y: auto;
      border: 1px solid #ccc;
    }
    #treeViewContent {
      position: relative;
    }
    /* Rows */
    .tree-row {
      display: flex;
      align-items: center;
      padding: 0;
      position: absolute;
      left: 0;
      right: 0;
      border-bottom: 1px solid #eee;
      box-sizing: border-box;
    }
    .tree-line, .tree-code, .tree-data {
      border-right: 1px solid #ccc;
      padding: 0 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .tree-line:last-child,
    .tree-code:last-child,
    .tree-data:last-child {
      border-right: none;
    }
    .toggle {
      display: inline-block;
      width: 16px;
      text-align: center;
      user-select: none;
      cursor: pointer;
    }
    .copy-button {
      margin-left: 8px;
      font-size: 0.8em;
      display: none;
    }
    .tree-row:hover .copy-button {
      display: inline;
    }
    /* Controls / Tag-style search */
    .controls {
      margin: 1em 0;
    }
    .tag-container {
      display: inline-block;
      border: 1px solid #ccc;
      padding: 2px;
      min-width: 200px;
      margin-right: 8px;
      vertical-align: middle;
      border-radius: 4px;
    }
    .tag-container input {
      border: none;
      outline: none;
      font-family: inherit;
    }
    .tag {
      display: inline-block;
      background-color: #ddd;
      padding: 2px 6px;
      margin: 2px;
      border-radius: 4px;
      font-size: 0.9em;
    }
    .tag .remove {
      margin-left: 4px;
      cursor: pointer;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="main-container">
    <h1>DXF Parser</h1>

    <!-- File Input -->
    <input type="file" id="fileInput" accept=".dxf" multiple>
    <button id="parseBtn">Parse File(s)</button>

    <!-- Tab Container -->
    <div id="tabContainer"></div>

    <!-- Search Controls -->
    <div class="controls">
      <div id="codeSearchTags" class="tag-container">
        <input type="text" id="codeSearchInput" placeholder="Search by Code">
      </div>
      <div id="dataSearchTags" class="tag-container">
        <input type="text" id="dataSearchInput" placeholder="Search by Data value">
      </div>
      <label>
        <input type="checkbox" id="dataExactCheckbox">
        Exact Data Match
      </label>
      <label>
        <input type="checkbox" id="dataCaseCheckbox">
        Case Sensitive
      </label>
      <button id="searchBtn">Search</button>
      <button id="clearSearchBtn">Clear Search</button>
      <button id="expandAllBtn">Expand All</button>
      <button id="collapseAllBtn">Collapse All</button>
    </div>

    <!-- Tree Grid Header -->
    <div id="treeGridHeader" class="tree-header">
      <div class="tree-line header-cell" data-field="line" data-sort="none" data-size="100px">
        Line <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
      <div class="tree-code header-cell" data-field="code" data-sort="none" data-size="100px">
        Code <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
      <div class="tree-data header-cell" data-field="type" data-sort="none" data-size="auto">
        Data <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
    </div>

    <!-- Virtual Scroll Container -->
    <div id="treeViewContainer">
      <div id="treeViewContent"></div>
    </div>
  </div>

  <!-- 1) DxfParser Class -->
  <script>
    class DxfParser {
      constructor() {
        // Map container objects to their ending markers
        this.containerMapping = {
          "SECTION": "ENDSEC",
          "BLOCK":   "ENDBLK",
          "TABLE":   "ENDTAB",
          "OBJECT":  "ENDOBJ",
          "POLYLINE":"SEQEND"
        };
        this.nextId = 1;
      }

      /**
       * Main entry point to parse a DXF text:
       *   1) parse text into tags
       *   2) group into hierarchical objects
       *   3) returns an array of top-level objects
       */
      parse(text) {
        const tags = this.parseDxf(text);
        const grouped = this.groupObjects(tags, 0);
        return grouped.objects;
      }

      /**
       * Splits the text into lines, forms { line, code, value }
       * @param {string} text - entire DXF file contents
       * @returns {Array} list of { line, code, value }
       */
      parseDxf(text) {
        const lines = text.split(/\r?\n/);
        const tags = [];
        for (let i = 0; i < lines.length; i++) {
          const codeLine = lines[i].trim();
          if (!codeLine) continue;
          const code = parseInt(codeLine, 10);
          if (isNaN(code)) continue;
          let value = "";
          const tagLine = i + 1; // store 1-based line number
          if (i + 1 < lines.length) {
            value = lines[i + 1].trim();
          }
          i++; // skip the value line
          tags.push({ line: tagLine, code, value });
        }
        return tags;
      }

      /**
       * Converts the list of tags into a tree of objects.
       * Recursively processes container objects (SECTION, BLOCK, etc.)
       * @param {Array} tags - list of { line, code, value }
       * @param {number} startIndex
       * @param {string|null} endMarker
       * @returns { { objects, nextIndex } }
       */
      groupObjects(tags, startIndex, endMarker = null) {
        const objects = [];
        let i = startIndex;

        while (i < tags.length) {
          // If we encounter the endMarker at code==0, we stop
          if (endMarker && tags[i].code === 0 && tags[i].value.toUpperCase() === endMarker) {
            i++;
            return { objects, nextIndex: i };
          }
          // If code != 0, skip until next code==0
          if (tags[i].code !== 0) {
            i++;
            continue;
          }
          // Build a new object
          const obj = {
            id: this.nextId++,
            type: tags[i].value,
            line: tags[i].line,
            properties: [],
            children: [],
            isContainer: this.containerMapping.hasOwnProperty(tags[i].value.toUpperCase()),
            expanded: false
          };
          i++;

          // Gather properties until next code==0 or until we run out
          while (i < tags.length && tags[i].code !== 0) {
            obj.properties.push(tags[i]);
            i++;
          }

          // If container, recursively parse children
          if (obj.isContainer) {
            const marker = this.containerMapping[obj.type.toUpperCase()];
            const result = this.groupObjects(tags, i, marker);
            obj.children = result.objects;
            i = result.nextIndex;
          }

          objects.push(obj);
        }
        return { objects, nextIndex: i };
      }

      /**
       * Find a node by ID in the entire tree (recursively).
       */
      findNodeById(tree, id) {
        for (const obj of tree) {
          if (String(obj.id) === String(id)) {
            return obj;
          }
          if (obj.children && obj.children.length) {
            const result = this.findNodeById(obj.children, id);
            if (result) return result;
          }
        }
        return null;
      }

      /**
       * Serialize a node (and its children) back to DXF text.
       * @param {Object} node
       * @returns {string} multiline DXF
       */
      serializeNode(node) {
        let lines = [];
        lines.push("0");
        lines.push(node.type);

        node.properties.forEach(prop => {
          lines.push(prop.code.toString());
          lines.push(prop.value);
        });

        // If container, recursively serialize children
        if (node.isContainer && node.children && node.children.length) {
          node.children.forEach(child => {
            lines.push(this.serializeNode(child));
          });
          const endMarker = this.containerMapping[node.type.toUpperCase()];
          if (endMarker) {
            lines.push("0");
            lines.push(endMarker);
          }
        }

        return lines.join("\n");
      }
    }
  </script>

  <!-- 2) VirtualTreeView Class (unchanged from previous refactor) -->
  <script>
    class VirtualTreeView {
      constructor(container, content, options = {}) {
        this.container = container;
        this.content = content;
        this.itemHeight = options.itemHeight || 24;
        this.copyCallback = options.copyCallback || null;
        this.onToggleExpand = options.onToggleExpand || null;

        // Column width getters
        this.getLineWidth = options.getLineWidth || (() => 100);
        this.getCodeWidth = options.getCodeWidth || (() => 100);
        this.getDataWidth = options.getDataWidth || (() => null);

        this.flatData = [];
        this.treeData = [];

        // Listen for scrolling
        this.container.addEventListener("scroll", this.updateVisibleNodes.bind(this));

        // Click handling
        this.content.addEventListener("click", (e) => {
          if (e.target.classList.contains("toggle")) {
            const row = e.target.closest(".tree-row");
            if (row) {
              const nodeId = row.dataset.id;
              // Let the outside code handle toggling
              if (this.onToggleExpand) {
                this.onToggleExpand(nodeId);
              }
            }
          }
          // Copy is handled in the button's click
        });
      }

      setData(treeData) {
        this.treeData = treeData || [];
        this.refresh();
      }

      refresh() {
        this.flatData = this.flattenTree(this.treeData);
        this.content.style.height = (this.flatData.length * this.itemHeight) + "px";
        this.updateVisibleNodes();
      }

      flattenTree(nodes, level = 0) {
        let flat = [];
        for (let node of nodes) {
          flat.push({ node, level });
          if (node.expanded) {
            if (node.properties && node.properties.length) {
              for (let prop of node.properties) {
                flat.push({
                  node: {
                    id: `prop-${node.id}-${prop.line}-${prop.code}`,
                    isProperty: true,
                    line: prop.line,
                    code: prop.code,
                    data: prop.value
                  },
                  level: level + 1
                });
              }
            }
            if (node.children && node.children.length) {
              flat = flat.concat(this.flattenTree(node.children, level + 1));
            }
          }
        }
        return flat;
      }

      updateVisibleNodes() {
        const scrollTop = this.container.scrollTop;
        const containerHeight = this.container.clientHeight;
        const startIndex = Math.floor(scrollTop / this.itemHeight);
        const visibleCount = Math.ceil(containerHeight / this.itemHeight) + 1;
        const endIndex = Math.min(startIndex + visibleCount, this.flatData.length);

        this.content.innerHTML = "";
        const fragment = document.createDocumentFragment();

        for (let i = startIndex; i < endIndex; i++) {
          const { node, level } = this.flatData[i];
          const row = document.createElement("div");
          row.className = "tree-row tree-node";
          row.style.top = (i * this.itemHeight) + "px";
          row.style.height = this.itemHeight + "px";
          row.style.position = "absolute";
          row.dataset.id = node.id;

          // --- LINE ---
          const lineDiv = document.createElement("div");
          lineDiv.className = "tree-line";
          const lineWidth = this.getLineWidth();
          if (lineWidth) {
            lineDiv.style.width = lineWidth + "px";
          }
          lineDiv.style.textAlign = "left";

          const lineContent = document.createElement("div");
          lineContent.style.display = "flex";
          lineContent.style.alignItems = "center";
          lineContent.style.marginLeft = (level * 20) + "px";

          if (!node.isProperty && ((node.properties && node.properties.length) || (node.children && node.children.length))) {
            const toggleSpan = document.createElement("span");
            toggleSpan.className = "toggle";
            toggleSpan.textContent = node.expanded ? "▼" : "►";
            lineContent.appendChild(toggleSpan);
          } else {
            const spacer = document.createElement("span");
            spacer.style.width = "16px";
            spacer.style.display = "inline-block";
            lineContent.appendChild(spacer);
          }
          const lineNumberSpan = document.createElement("span");
          lineNumberSpan.textContent = node.line || "";
          lineContent.appendChild(lineNumberSpan);

          lineDiv.appendChild(lineContent);
          row.appendChild(lineDiv);

          // --- CODE ---
          const codeDiv = document.createElement("div");
          codeDiv.className = "tree-code";
          const codeWidth = this.getCodeWidth();
          if (codeWidth) {
            codeDiv.style.width = codeWidth + "px";
          }
          codeDiv.style.textAlign = "left";
          if (node.isProperty) {
            codeDiv.textContent = node.code;
          } else {
            codeDiv.textContent = ((node.properties && node.properties.length) || (node.children && node.children.length)) ? "0" : "";
          }
          row.appendChild(codeDiv);

          // --- DATA ---
          const dataDiv = document.createElement("div");
          dataDiv.className = "tree-data";
          const dataWidth = this.getDataWidth();
          if (dataWidth) {
            dataDiv.style.width = dataWidth + "px";
            dataDiv.style.flex = "0 0 auto";
          } else {
            dataDiv.style.flex = "1";
          }
          dataDiv.textContent = node.isProperty ? node.data : node.type || "";

          // Copy button (for non-property nodes)
          if (this.copyCallback && !node.isProperty) {
            const copyButton = document.createElement("button");
            copyButton.textContent = "Copy";
            copyButton.className = "copy-button";
            copyButton.addEventListener("click", (e) => {
              e.stopPropagation();
              this.copyCallback(node.id);
            });
            dataDiv.appendChild(copyButton);
          }

          row.appendChild(dataDiv);
          fragment.appendChild(row);
        }

        this.content.appendChild(fragment);
      }
    }
  </script>

  <!-- 3) Main App Code Integrating DxfParser & VirtualTreeView -->
  <script>
    /***** 1) Instantiate classes and global state *****/
    const dxfParser = new DxfParser();  // Our new parser class

    // We'll reuse the container / content for the VirtualTreeView
    const treeViewContainer = document.getElementById("treeViewContainer");
    const treeViewContent = document.getElementById("treeViewContent");

    // Column widths
    let columnWidths = {
      line: 100,
      code: 100,
      type: null
    };

    // Tabs array
    let tabs = [];
    let activeTabId = null;

    // The actual tree view instance
    const myTreeView = new VirtualTreeView(treeViewContainer, treeViewContent, {
      itemHeight: 24,
      copyCallback: (nodeId) => {
        // Called when user clicks "Copy"
        const activeTab = getActiveTab();
        if (!activeTab) return;
        const node = dxfParser.findNodeById(activeTab.originalTreeData, nodeId);
        if (!node) {
          alert("Node not found in original data.");
          return;
        }
        const serialized = dxfParser.serializeNode(node);
        navigator.clipboard.writeText(serialized).then(() => {
          alert("Copied node to clipboard as valid DXF tags.");
        }, () => {
          alert("Failed to copy to clipboard.");
        });
      },
      onToggleExpand: (nodeId) => {
        // Flip expansion for the node in the original tree
        const activeTab = getActiveTab();
        if (!activeTab) return;
        const node = dxfParser.findNodeById(activeTab.originalTreeData, nodeId);
        if (node) {
          node.expanded = !node.expanded;

          // If there's a current sort, re-sort
          if (activeTab.currentSortField) {
            sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
          }
          // Re-filter if necessary
          const dataExact = document.getElementById("dataExactCheckbox").checked;
          const dataCase = document.getElementById("dataCaseCheckbox").checked;
          activeTab.currentTreeData = (activeTab.codeSearchTerms.length || activeTab.dataSearchTerms.length)
            ? filterTree(activeTab.originalTreeData, activeTab.codeSearchTerms, activeTab.dataSearchTerms, dataExact, dataCase)
            : activeTab.originalTreeData;

          // Update the tree
          myTreeView.setData(activeTab.currentTreeData);
        }
      },
      getLineWidth: () => columnWidths.line,
      getCodeWidth: () => columnWidths.code,
      getDataWidth: () => columnWidths.type
    });

    function getActiveTab() {
      return tabs.find(t => t.id === activeTabId);
    }

    // Rebuild tab UI
    function updateTabUI() {
      const tabContainer = document.getElementById("tabContainer");
      tabContainer.innerHTML = "";
      tabs.forEach(tab => {
        const tabElem = document.createElement("div");
        tabElem.className = "tab" + (tab.id === activeTabId ? " active" : "");
        tabElem.textContent = tab.name;
        tabElem.dataset.tabId = tab.id;

        tabElem.addEventListener("click", () => {
          activeTabId = tab.id;
          updateTabUI();
          myTreeView.setData(tab.currentTreeData);
        });
        // Close button
        const closeBtn = document.createElement("span");
        closeBtn.className = "close-tab";
        closeBtn.textContent = "×";
        closeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          tabs = tabs.filter(t => t.id !== tab.id);
          if (activeTabId === tab.id) {
            activeTabId = tabs.length ? tabs[0].id : null;
          }
          updateTabUI();
          if (activeTabId) {
            myTreeView.setData(getActiveTab().currentTreeData);
          } else {
            myTreeView.setData([]);
          }
        });
        tabElem.appendChild(closeBtn);
        tabContainer.appendChild(tabElem);
      });
    }

    /***** 2) Search & Filter Logic (unchanged) *****/
    function filterObject(obj, codeTerms, dataTerms, dataExact, dataCase) {
      const searchActive = (codeTerms.length > 0 || dataTerms.length > 0);
      let typeMatchesData = false;
      if (dataTerms.length > 0) {
        if (dataExact) {
          typeMatchesData = dataTerms.some(term => dataCase
            ? (obj.type === term)
            : (obj.type.toLowerCase() === term.toLowerCase())
          );
        } else {
          typeMatchesData = dataTerms.some(term => dataCase
            ? obj.type.includes(term)
            : obj.type.toLowerCase().includes(term.toLowerCase())
          );
        }
      } else {
        typeMatchesData = true;
      }

      const filteredProperties = obj.properties.filter(prop => {
        const codeMatch = (codeTerms.length === 0) || codeTerms.some(term => String(prop.code) === term);
        let dataMatch = true;
        if (dataTerms.length > 0) {
          if (dataExact) {
            dataMatch = dataTerms.some(term => dataCase
              ? (prop.value === term)
              : (prop.value.toLowerCase() === term.toLowerCase())
            );
          } else {
            dataMatch = dataTerms.some(term => dataCase
              ? prop.value.includes(term)
              : prop.value.toLowerCase().includes(term.toLowerCase())
            );
          }
        }
        return codeMatch && dataMatch;
      });

      const filteredChildren = [];
      obj.children.forEach(child => {
        const filteredChild = filterObject(child, codeTerms, dataTerms, dataExact, dataCase);
        if (filteredChild !== null) {
          filteredChildren.push(filteredChild);
        }
      });

      if (searchActive && obj.isContainer) {
        if (filteredProperties.length === 0 && filteredChildren.length === 0) {
          return null;
        }
        return {
          ...obj,
          properties: filteredProperties,
          children: filteredChildren
        };
      } else {
        if (typeMatchesData || filteredProperties.length > 0 || filteredChildren.length > 0) {
          return {
            ...obj,
            properties: filteredProperties,
            children: filteredChildren
          };
        }
        return null;
      }
    }

    function filterTree(objects, codeTerms, dataTerms, dataExact, dataCase) {
      const filtered = [];
      objects.forEach(obj => {
        const filteredObj = filterObject(obj, codeTerms, dataTerms, dataExact, dataCase);
        if (filteredObj !== null) {
          filtered.push(filteredObj);
        }
      });
      return filtered;
    }

    /***** 3) Expand/Collapse All *****/
    function expandAllNodes(nodes) {
      nodes.forEach(node => {
        if ((node.properties && node.properties.length) || (node.children && node.children.length)) {
          node.expanded = true;
          expandAllNodes(node.children);
        }
      });
    }
    function collapseAllNodes(nodes) {
      nodes.forEach(node => {
        node.expanded = false;
        collapseAllNodes(node.children);
      });
    }
    document.getElementById("expandAllBtn").addEventListener("click", () => {
      const activeTab = getActiveTab();
      if (!activeTab) return;
      expandAllNodes(activeTab.originalTreeData);
      if (activeTab.currentSortField) {
        sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
      }
      const dataExact = document.getElementById("dataExactCheckbox").checked;
      const dataCase = document.getElementById("dataCaseCheckbox").checked;
      activeTab.currentTreeData = (activeTab.codeSearchTerms.length || activeTab.dataSearchTerms.length)
        ? filterTree(activeTab.originalTreeData, activeTab.codeSearchTerms, activeTab.dataSearchTerms, dataExact, dataCase)
        : activeTab.originalTreeData;
      myTreeView.setData(activeTab.currentTreeData);
    });
    document.getElementById("collapseAllBtn").addEventListener("click", () => {
      const activeTab = getActiveTab();
      if (!activeTab) return;
      collapseAllNodes(activeTab.originalTreeData);
      if (activeTab.currentSortField) {
        sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
      }
      const dataExact = document.getElementById("dataExactCheckbox").checked;
      const dataCase = document.getElementById("dataCaseCheckbox").checked;
      activeTab.currentTreeData = (activeTab.codeSearchTerms.length || activeTab.dataSearchTerms.length)
        ? filterTree(activeTab.originalTreeData, activeTab.codeSearchTerms, activeTab.dataSearchTerms, dataExact, dataCase)
        : activeTab.originalTreeData;
      myTreeView.setData(activeTab.currentTreeData);
    });

    /***** 4) Sorting *****/
    function getSortValue(node, field) {
      if (field === "line") {
        return node.line ? Number(node.line) : 0;
      } else if (field === "code") {
        if (node.isProperty) {
          const c = parseInt(node.code, 10);
          return isNaN(c) ? Number.MAX_SAFE_INTEGER : c;
        }
        return 0; // container objects => code 0
      } else if (field === "type") {
        return node.isProperty ? (node.data || "") : (node.type || "");
      }
      return "";
    }

    function sortTreeNodes(nodes, field, ascending) {
      nodes.sort((a, b) => {
        const aVal = getSortValue(a, field);
        const bVal = getSortValue(b, field);
        if (field === "code" || field === "line") {
          return (aVal - bVal) * (ascending ? 1 : -1);
        } else {
          return aVal.localeCompare(bVal) * (ascending ? 1 : -1);
        }
      });
      nodes.forEach(node => {
        // Sort node's properties (if relevant to field)
        if (node.properties && node.properties.length) {
          node.properties.sort((a, b) => {
            if (field === "code") {
              const aC = parseInt(a.code, 10) || 0;
              const bC = parseInt(b.code, 10) || 0;
              return (aC - bC) * (ascending ? 1 : -1);
            } else if (field === "line") {
              const aL = a.line || 0;
              const bL = b.line || 0;
              return (aL - bL) * (ascending ? 1 : -1);
            } else if (field === "type") {
              const aV = a.value || "";
              const bV = b.value || "";
              return aV.localeCompare(bV) * (ascending ? 1 : -1);
            }
            return 0;
          });
        }
        // Recurse
        if (node.children && node.children.length) {
          sortTreeNodes(node.children, field, ascending);
        }
      });
    }

    document.querySelectorAll('.header-cell').forEach(headerCell => {
      headerCell.addEventListener('click', function(e) {
        if (e.target.classList.contains('resizer')) return;
        const field = headerCell.getAttribute('data-field');
        const activeTab = getActiveTab();
        if (!activeTab) return;

        let currentSort = headerCell.getAttribute('data-sort');
        let ascending = true;
        if (currentSort === 'asc') {
          ascending = false;
          headerCell.setAttribute('data-sort', 'desc');
          headerCell.querySelector('.sort-indicator').textContent = ' ▼';
        } else {
          ascending = true;
          headerCell.setAttribute('data-sort', 'asc');
          headerCell.querySelector('.sort-indicator').textContent = ' ▲';
        }
        activeTab.currentSortField = field;
        activeTab.currentSortAscending = ascending;

        document.querySelectorAll('.header-cell').forEach(cell => {
          if (cell !== headerCell) {
            cell.setAttribute('data-sort', 'none');
            cell.querySelector('.sort-indicator').textContent = '';
          }
        });

        sortTreeNodes(activeTab.originalTreeData, field, ascending);
        // Re-filter if needed
        const dataExact = document.getElementById("dataExactCheckbox").checked;
        const dataCase = document.getElementById("dataCaseCheckbox").checked;
        activeTab.currentTreeData = (activeTab.codeSearchTerms.length || activeTab.dataSearchTerms.length)
          ? filterTree(activeTab.originalTreeData, activeTab.codeSearchTerms, activeTab.dataSearchTerms, dataExact, dataCase)
          : activeTab.originalTreeData;

        myTreeView.setData(activeTab.currentTreeData);
      });
    });

    // Column resizing
    document.querySelectorAll('.header-cell .resizer').forEach(resizer => {
      resizer.addEventListener('mousedown', function(e) {
        e.stopPropagation();
        const headerCell = resizer.parentElement;
        const field = headerCell.getAttribute('data-field');
        const startX = e.clientX;
        const startWidth = headerCell.offsetWidth;
        function onMouseMove(e) {
          const newWidth = startWidth + (e.clientX - startX);
          columnWidths[field] = newWidth; // store globally
          headerCell.style.width = newWidth + 'px';
          // Trigger re-render of visible rows
          myTreeView.updateVisibleNodes();
        }
        function onMouseUp() {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
        }
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
    });

    /***** 5) Tag-style Search Inputs *****/
    function createTagElement(text, type) {
      const tag = document.createElement("span");
      tag.className = "tag";
      tag.textContent = text;

      const removeBtn = document.createElement("span");
      removeBtn.className = "remove";
      removeBtn.textContent = "×";
      removeBtn.addEventListener("click", function(e) {
        e.stopPropagation();
        const activeTab = getActiveTab();
        if (!activeTab) return;
        if (type === "code") {
          activeTab.codeSearchTerms = activeTab.codeSearchTerms.filter(term => term !== text);
          updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
        } else if (type === "data") {
          activeTab.dataSearchTerms = activeTab.dataSearchTerms.filter(term => term !== text);
          updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
        }
        // Re-filter
        const dataExact = document.getElementById("dataExactCheckbox").checked;
        const dataCase = document.getElementById("dataCaseCheckbox").checked;
        activeTab.currentTreeData = (activeTab.codeSearchTerms.length || activeTab.dataSearchTerms.length)
          ? filterTree(activeTab.originalTreeData, activeTab.codeSearchTerms, activeTab.dataSearchTerms, dataExact, dataCase)
          : activeTab.originalTreeData;
        myTreeView.setData(activeTab.currentTreeData);
      });
      tag.appendChild(removeBtn);

      return tag;
    }

    function updateTagContainer(containerId, termsArray, type) {
      const container = document.getElementById(containerId);
      Array.from(container.querySelectorAll(".tag")).forEach(tag => tag.remove());
      termsArray.forEach(term => {
        const tagElem = createTagElement(term, type);
        container.insertBefore(tagElem, container.querySelector("input"));
      });
    }

    function setupTagInput(inputId, type) {
      const input = document.getElementById(inputId);
      input.addEventListener("keydown", function(e) {
        if (e.key === "Enter" || e.key === ",") {
          e.preventDefault();
          const text = input.value.trim();
          if (text !== "") {
            const activeTab = getActiveTab();
            if (!activeTab) return;
            if (type === "code") {
              if (!activeTab.codeSearchTerms.includes(text)) {
                activeTab.codeSearchTerms.push(text);
              }
              updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
            } else {
              if (!activeTab.dataSearchTerms.includes(text)) {
                activeTab.dataSearchTerms.push(text);
              }
              updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
            }
            input.value = "";
          }
        }
      });
      input.addEventListener("blur", function(e) {
        const text = input.value.trim();
        if (text !== "") {
          const activeTab = getActiveTab();
          if (!activeTab) return;
          if (type === "code") {
            if (!activeTab.codeSearchTerms.includes(text)) {
              activeTab.codeSearchTerms.push(text);
            }
            updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
          } else {
            if (!activeTab.dataSearchTerms.includes(text)) {
              activeTab.dataSearchTerms.push(text);
            }
            updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
          }
          input.value = "";
        }
      });
    }
    setupTagInput("codeSearchInput", "code");
    setupTagInput("dataSearchInput", "data");

    // Search & Clear
    document.getElementById("searchBtn").addEventListener("click", function() {
      const activeTab = getActiveTab();
      if (!activeTab) return;
      const codeInput = document.getElementById("codeSearchInput");
      const dataInput = document.getElementById("dataSearchInput");

      if (codeInput.value.trim() !== "") {
        const text = codeInput.value.trim();
        if (!activeTab.codeSearchTerms.includes(text)) {
          activeTab.codeSearchTerms.push(text);
        }
        updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
        codeInput.value = "";
      }
      if (dataInput.value.trim() !== "") {
        const text = dataInput.value.trim();
        if (!activeTab.dataSearchTerms.includes(text)) {
          activeTab.dataSearchTerms.push(text);
        }
        updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
        dataInput.value = "";
      }

      const dataExact = document.getElementById("dataExactCheckbox").checked;
      const dataCase = document.getElementById("dataCaseCheckbox").checked;
      activeTab.currentTreeData = (activeTab.codeSearchTerms.length || activeTab.dataSearchTerms.length)
        ? filterTree(activeTab.originalTreeData, activeTab.codeSearchTerms, activeTab.dataSearchTerms, dataExact, dataCase)
        : activeTab.originalTreeData;
      myTreeView.setData(activeTab.currentTreeData);
    });

    document.getElementById("clearSearchBtn").addEventListener("click", function() {
      const activeTab = getActiveTab();
      if (!activeTab) return;
      activeTab.codeSearchTerms = [];
      activeTab.dataSearchTerms = [];
      updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
      updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
      document.getElementById("codeSearchInput").value = "";
      document.getElementById("dataSearchInput").value = "";
      document.getElementById("dataExactCheckbox").checked = false;
      document.getElementById("dataCaseCheckbox").checked = false;
      activeTab.currentTreeData = activeTab.originalTreeData;
      myTreeView.setData(activeTab.currentTreeData);
    });

    /***** 6) File Input & Parsing Integration *****/
    document.getElementById("parseBtn").addEventListener("click", function() {
      const fileInput = document.getElementById("fileInput");
      if (!fileInput.files || fileInput.files.length === 0) {
        alert("Please select at least one DXF file.");
        return;
      }
      Array.from(fileInput.files).forEach(file => {
        const reader = new FileReader();
        reader.onload = function(event) {
          const text = event.target.result;

          // Use DxfParser class
          const objects = dxfParser.parse(text);

          // Make a new tab
          const newTab = {
            id: Date.now() + Math.random(),
            name: file.name,
            originalTreeData: objects,
            currentTreeData: objects,
            codeSearchTerms: [],
            dataSearchTerms: [],
            currentSortField: "line",
            currentSortAscending: true
          };
          tabs.push(newTab);
          activeTabId = newTab.id;
          updateTabUI();

          // Show this tab's data
          myTreeView.setData(newTab.currentTreeData);
        };
        // Read as ASCII or UTF-8, depending on your files
        reader.readAsText(file, "ascii");
      });
    });
  </script>
</body>
</html>
