<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- This meta tag makes the app responsive on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DXF Parser</title>
  <!-- Include JSZip for ZIP file browsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <style>
    /* Base Styles */
    html, body { height: 100%; margin: 0; padding: 0; }
    *, *:before, *:after { box-sizing: border-box; }
    body { font-family: sans-serif; }
    .main-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 1em;
    }
    /* Layout for two‐column main content with fixed sidebar */
    .content-wrapper {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    .sidebar {
      width: 270px; /* Fixed width */
      padding: 1em;
      border-right: 1px solid #ccc;
      overflow-y: auto;
    }
    /* Sidebar Logo */
    .sidebar-logo h1 {
      margin: 0 0 1em 0;
      font-size: 1.5em;
    }
    .pane-resizer {
      width: 5px;
      cursor: ew-resize;
      background-color: #ccc;
    }
    .main-content {
      flex: 1;
      padding-left: 1em;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    /* Sidebar header buttons – stacked vertically and fill width */
    .sidebar-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.3em;
      margin-bottom: 0.5em;
    }
    .sidebar-buttons button {
      width: 100%;
      padding: 0.5em;
      box-sizing: border-box;
    }
    /* File input row */
    .file-input-row {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 1em;
    }
    /* Navigation Controls – a single row combining Go to Handle and navigation history */
    #navControls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1em;
    }
    /* Left part: Handle Navigation */
    #handleNavBar {
      display: flex;
      align-items: center;
    }
    #handleNavBar input {
      margin-right: 0.5em;
    }
    /* Right part: Navigation History */
    #navHistoryContainer {
      display: flex;
      align-items: center;
    }
    #navHistoryControls button {
      margin-right: 4px;
    }
    #navHistoryList {
      margin-left: 8px;
      overflow-x: auto;
      white-space: nowrap;
    }
    #parseBtn { padding: 0.3em 0.6em; white-space: nowrap; }
    /* Tabs */
    #tabContainer {
      display: flex;
      flex-wrap: wrap;
      border-bottom: 1px solid #ccc;
      margin: 0.5em 0;
    }
    .tab {
      padding: 0.5em 1em;
      border: 1px solid #ccc;
      border-bottom: none;
      cursor: pointer;
      margin-right: 2px;
      margin-bottom: 2px;
      background: #eee;
      position: relative;
    }
    .tab.active { background: #fff; font-weight: bold; }
    .tab .close-tab {
      position: absolute;
      top: 0;
      right: 2px;
      cursor: pointer;
      padding: 0 4px;
    }
    /* Tree Grid Header */
    #treeGridHeader {
      display: flex;
      align-items: center;
      height: 24px;
      font-weight: bold;
      border-bottom: 1px solid #ccc;
      background: #eee;
      user-select: none;
      position: sticky;
      top: 0;
      z-index: 2;
      will-change: transform;
    }
    .header-cell {
      display: flex;
      align-items: center;
      height: 100%;
      position: relative;
      padding: 0 4px;
      border-right: 1px solid #ccc;
      cursor: pointer;
    }
    .header-cell.flex-fixed { flex: none; }
    .header-cell.flex-grow { flex: 1; }
    .header-cell:last-child { border-right: none; }
    .header-cell .resizer {
      position: absolute;
      right: 0;
      top: 0;
      width: 5px;
      height: 100%;
      cursor: col-resize;
    }
    .header-cell .sort-indicator {
      margin-left: 4px;
      font-size: 0.8em;
    }
    .tree-line,
    .tree-code,
    .tree-object-count,
    .tree-data-size {
      flex: none;
      padding: 0 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: left;
      border-right: 1px solid #ccc;
      height: 100%;
    }
    .tree-data {
      padding: 0 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border-right: 1px solid #ccc;
      height: 100%;
    }
    .tree-line:last-child,
    .tree-code:last-child,
    .tree-data:last-child,
    .tree-object-count:last-child,
    .tree-data-size:last-child { border-right: none; }
    /* Tree View Container */
    #treeViewContainer {
      position: relative;
      flex: 1;
      overflow: auto;
      border: 1px solid #ccc;
      clip-path: inset(0);
    }
    #treeViewContent { position: relative; overflow: hidden; }
    /* Tree row styling – with row selection support */
    .tree-row {
      display: flex;
      align-items: center;
      height: 24px;
      border-bottom: 1px solid #eee;
      overflow: hidden;
      cursor: pointer;
    }
    .tree-row.selected {
      background-color: #bde4ff;
    }
    .toggle {
      display: inline-block;
      width: 16px;
      text-align: center;
      user-select: none;
      cursor: pointer;
    }
    .copy-button, .open-button, .hex-button {
      margin-left: 8px;
      font-size: 0.8em;
      display: none;
    }
    .tree-row:hover .copy-button,
    .tree-row:hover .open-button,
    .tree-row:hover .hex-button { display: inline; }
    /* Use monospace font for the tree grid display */
    .tree-row,
    .tree-line,
    .tree-code,
    .tree-object-count,
    .tree-data-size,
    .tree-data {
      font-family: monospace;
    }
    .tree-line,
    .tree-code,
    .tree-data,
    .tree-object-count,
    .tree-data-size {
      display: flex;
      align-items: center;
      height: 100%;
    }
    /* Filter Panel – controls now stacked vertically */
    .tree-row,
    .tree-row * {
      user-select: text;
    }
    .filter-panel {
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-bottom: 1em;
      padding: 0.5em;
    }
    .filter-panel h2 {
      margin: 0 0 0.5em 0;
      font-size: 1.2em;
    }
    .filter-content .filter-row {
      display: flex;
      flex-direction: column;
      gap: 0.5em;
      margin-bottom: 0.5em;
    }
    .filter-row label,
    .filter-row input,
    .filter-row button { margin-right: 0; }
    .tag-container {
      display: block;
      border: 1px solid #ccc;
      padding: 2px;
      margin-bottom: 0.5em;
      border-radius: 4px;
    }
    .tag-container input {
      border: none;
      outline: none;
      font-family: inherit;
      width: 100%;
    }
    .tag {
      display: inline-block;
      background: #ddd;
      padding: 2px 6px;
      margin: 2px;
      border-radius: 4px;
      font-size: 0.9em;
    }
    .tag .remove {
      margin-left: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    /* Overlays – all dialogs are hidden by default and appear above the tree view */
    #cloudOverlay,
    #statsOverlay,
    #depsOverlay,
    #binaryObjectsOverlay,
    #handleMapOverlay,
    #hexViewerOverlay,
    #proxyObjectsOverlay,
    /* NEW Fonts Overlay */
    #fontsOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    /* Raise the hex viewer above the other overlays */
    #hexViewerOverlay { z-index: 1100; }
    /* The other overlays get z-index: 1000 */
    #cloudOverlay,
    #statsOverlay,
    #depsOverlay,
    #binaryObjectsOverlay,
    #handleMapOverlay,
    #proxyObjectsOverlay,
    #fontsOverlay { z-index: 1000; }
    #classesOverlay {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
    }
    .overlay-content {
      background: #fff;
      margin: 20px;
      padding: 1em;
      width: calc(100% - 40px);
      height: calc(100% - 40px);
      border: 4px solid rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      position: relative;
      overflow-y: auto;
    }
    #closeCloudOverlay,
    #closeStatsOverlay,
    #closeDepsOverlay,
    #closeHexViewerOverlay,
    #closeBinaryObjectsOverlay,
    #closeHandleMapOverlay,
    #closeProxyObjectsOverlay,
    /* NEW Fonts Overlay close button */
    #closeFontsOverlay,
    #closeClassesOverlay,
    #saveBinaryBtn,
    #previewImageBtn {
      position: absolute;
      top: 10px;
      cursor: pointer;
    }
    #closeCloudOverlay,
    #closeStatsOverlay,
    #closeDepsOverlay,
    #closeHexViewerOverlay,
    #closeBinaryObjectsOverlay,
    #closeHandleMapOverlay,
    #closeProxyObjectsOverlay,
    #closeFontsOverlay,
    #closeClassesOverlay { right: 10px; }
    #saveBinaryBtn { right: 80px; }
    #previewImageBtn { right: 170px; }
    .cloud-tag {
      display: inline-block;
      margin: 4px;
      padding: 2px 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #f9f9f9;
    }
    #overlayStatsContent ul,
    #overlayDepsContent ul {
      list-style: none;
      padding: 0;
    }
    #overlayStatsContent li,
    #overlayDepsContent li {
      padding: 0.5em 0;
      border-bottom: 1px solid #eee;
    }
    /* Additional containers for previews */
    #imagePreviewContainer, #zipContentsContainer {
      margin-top: 10px;
    }
    /* Responsive adjustments for mobile */
    @media (max-width: 600px) {
      .filter-content .filter-row {
        flex-direction: column;
      }
      .tag-container { width: 100%; }
      #treeGridHeader .header-cell { padding: 0 2px; }
      .tree-row { height: 32px; }
      .tree-row .toggle { width: 20px; }
      .sidebar-logo h1 { font-size: 1.3em; }
      .content-wrapper {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid #ccc;
        padding-bottom: 1em;
        margin-bottom: 1em;
      }
      .pane-resizer { display: none; }
      .main-content { padding-left: 0; }
      #navControls { flex-direction: column; align-items: flex-start; }
      #handleNavBar, #navHistoryContainer { margin-bottom: 0.5em; }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <!-- Main content wrapper with sidebar and main content -->
    <div class="content-wrapper">
      <!-- Sidebar: Contains logo, header buttons and filter panel -->
      <div class="sidebar">
        <!-- Sidebar logo -->
        <div class="sidebar-logo">
          <h1>DXF Parser</h1>
        </div>
        <div class="sidebar-buttons">
          <button id="expandAllBtn">Expand All</button>
          <button id="collapseAllBtn">Collapse All</button>
          <button id="showCloudOverlayBtn">Cloud Data</button>
          <button id="showStatsOverlayBtn">Statistics</button>
          <button id="showDepsOverlayBtn">Dependencies</button>
          <button id="showBinaryObjectsOverlayBtn">Binary Objects</button>
          <button id="showHandleMapOverlayBtn">Handle Map</button>
          <button id="showProxyObjectsOverlayBtn">Proxy Objects</button>
          <button id="showFontsOverlayBtn">Fonts Used</button>
          <button id="showClassesOverlayBtn">Classes</button>
          <button id="showObjectSizeOverlayBtn">Object Sizes</button>
          <button id="showBlocksOverlayBtn">Blocks & Inserts</button>
          <button id="showLineTypesOverlayBtn">Line Types</button>
          <button id="showTextsOverlayBtn">Texts</button>
          <button id="showBatchProcessOverlayBtn">Batch Process</button>
        </div>
        <div class="filter-panel" id="filterPanel">
          <h2>Filters</h2>
          <div class="filter-content">
            <div class="filter-row">
              <div id="codeSearchTags" class="tag-container">
                <input type="text" id="codeSearchInput" placeholder="Search by Code">
              </div>
            </div>
            <div class="filter-row">
              <div id="dataSearchTags" class="tag-container">
                <input type="text" id="dataSearchInput" placeholder="Search by Data value">
              </div>
            </div>
            <div class="filter-row">
              <label>
                <input type="checkbox" id="dataExactCheckbox"> Exact Data Match
              </label>
            </div>
            <div class="filter-row">
              <label>
                <input type="checkbox" id="dataCaseCheckbox"> Case Sensitive
              </label>
            </div>
            <div class="filter-row">
              <label for="minLineInput">Min Line:</label>
              <input type="number" id="minLineInput" style="width:80px;">
            </div>
            <div class="filter-row">
              <label for="maxLineInput">Max Line:</label>
              <input type="number" id="maxLineInput" style="width:80px;">
            </div>
            <div class="filter-row">
              <button id="searchBtn">Search</button>
              <button id="clearSearchBtn">Clear Search</button>
            </div>
          </div>
        </div>
      </div>
      <!-- Resizer between sidebar and main content -->
      <div class="pane-resizer"></div>
      <!-- Main Content Area -->
      <div class="main-content">
        <!-- File input row -->
        <div class="file-input-row">
          <div class="left-part">
            <input type="file" id="fileInput" accept=".dxf" multiple>
            <label>
              <input type="checkbox" id="useStreamCheckbox">
              Use Streamed Parsing
            </label>
            <button id="parseBtn">Parse File(s)</button>
          </div>
        </div>
        <!-- Combined Navigation Row -->
        <div id="navControls">
          <div id="handleNavBar">
            <input type="text" id="handleSearchInput" placeholder="Go to Handle">
            <button id="goToHandleBtn">Go</button>
          </div>
          <div id="navHistoryContainer">
            <div id="navHistoryControls">
              <button id="backBtn" disabled>Back</button>
              <button id="forwardBtn" disabled>Forward</button>
              <button id="clearHistoryBtn">Clear</button>
            </div>
            <div id="navHistoryList"></div>
          </div>
        </div>
        <!-- Tabs -->
        <div id="tabContainer"></div>
        <!-- Tree Grid Header -->
        <div id="treeGridHeader" class="tree-header">
          <div class="tree-line header-cell flex-fixed" data-field="line" data-sort="none" style="width: 130px; text-align: left;">
            Line <span class="sort-indicator"></span>
            <div class="resizer"></div>
          </div>
          <div class="tree-code header-cell flex-fixed" data-field="code" data-sort="none" style="width: 100px; text-align: left;">
            Code <span class="sort-indicator"></span>
            <div class="resizer"></div>
          </div>
          <div class="tree-data header-cell flex-grow" data-field="type" data-sort="none" style="flex: 1;">
            Data <span class="sort-indicator"></span>
            <div class="resizer"></div>
          </div>
          <div class="tree-object-count header-cell flex-fixed" data-field="objectCount" data-sort="none" style="width: 130px; text-align: right;">
            Object Count <span class="sort-indicator"></span>
            <div class="resizer"></div>
          </div>
          <div class="tree-data-size header-cell flex-fixed" data-field="dataSize" data-sort="none" style="width: 130px; text-align: right;">
            Data Size <span class="sort-indicator"></span>
            <div class="resizer"></div>
          </div>
        </div>
        <!-- Tree View Container -->
        <div id="treeViewContainer">
          <div id="treeViewContent"></div>
        </div>
      </div>
    </div>
  </div>
  <!-- Overlays -->
  <div id="cloudOverlay">
    <div class="overlay-content">
      <button id="closeCloudOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="cloudOverlay">Back to Tree</button>
      <h2>Cloud Data</h2>
      <h3>Object Cloud</h3>
      <div id="overlayObjectCloud"></div>
      <h3>Code Cloud</h3>
      <div id="overlayCodeCloud"></div>
    </div>
  </div>
  <div id="statsOverlay">
    <div class="overlay-content">
      <button id="closeStatsOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="statsOverlay">Back to Tree</button>
      <h2>DXF Statistics</h2>
      <div id="overlayStatsContent"></div>
    </div>
  </div>
  <div id="depsOverlay">
    <div class="overlay-content">
      <button id="closeDepsOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="depsOverlay">Back to Tree</button>
      <h2>DXF Dependencies</h2>
      <div id="overlayDepsContent"></div>
    </div>
  </div>
  <div id="hexViewerOverlay">
    <div class="overlay-content">
      <button id="closeHexViewerOverlay">Close</button>
      <button id="saveBinaryBtn">Save Binary</button>
      <button id="previewImageBtn">Preview Image</button>
      <h2>Hex Viewer</h2>
      <div id="headerInfo"></div>
      <pre id="hexContent" style="overflow:auto; height: calc(100% - 160px);"></pre>
      <div id="imagePreviewContainer"></div>
      <div id="zipContentsContainer"></div>
    </div>
  </div>
  <div id="binaryObjectsOverlay">
    <div class="overlay-content">
      <button id="closeBinaryObjectsOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="binaryObjectsOverlay">Back to Tree</button>
      <h2>Binary Data Objects</h2>
      <div id="binaryObjectsList"></div>
    </div>
  </div>
  <div id="handleMapOverlay">
    <div class="overlay-content">
      <button id="closeHandleMapOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="handleMapOverlay">Back to Tree</button>
      <h2>DXF Handle Map</h2>
      <div id="overlayHandleMapContent"></div>
    </div>
  </div>
  <div id="proxyObjectsOverlay">
    <div class="overlay-content">
      <button id="closeProxyObjectsOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="proxyObjectsOverlay">Back to Tree</button>
      <h2>Proxy Objects</h2>
      <div id="proxyObjectsList"></div>
    </div>
  </div>
  <div id="fontsOverlay">
    <div class="overlay-content">
      <button id="closeFontsOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="fontsOverlay">Back to Tree</button>
      <h2>Fonts Used in DXF</h2>
      <div id="overlayFontsContent"></div>
    </div>
  </div>
  <div id="classesOverlay">
    <div class="overlay-content">
      <button id="closeClassesOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="classesOverlay">Back to Tree</button>
      <h2>DXF Classes</h2>
      <div id="overlayClassesContent"></div>
    </div>
  </div>
  <div id="objectSizeOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); z-index:1000;">
    <div class="overlay-content">
      <button id="closeObjectSizeOverlay" style="position:absolute; top:10px; right:10px; cursor:pointer;">Close</button>
      <h2>Object Sizes</h2>
      <!-- The container that will be virtualized -->
      <div id="objectSizeList" style="overflow-y:auto; height: calc(100% - 60px); border:1px solid #ccc; margin-top:40px;"></div>
    </div>
  </div>
  <div id="blocksOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); z-index:1000;">
    <div class="overlay-content">
      <button id="closeBlocksOverlay" style="position:absolute; top:10px; right:10px; cursor:pointer;">Close</button>
      <button class="backToTreeBtn" data-overlay="blocksOverlay">Back to Tree</button>
      <h2>Block &amp; Insert Relations</h2>
      <div id="overlayBlocksContent"></div>
    </div>
  </div>
  <div id="lineTypesOverlay" style="display:none; position: fixed; top:0; left:0; width:100%; height:100%; background-color: rgba(0,0,0,0.5); z-index:1000;">
    <div class="overlay-content">
      <button id="closeLineTypesOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="lineTypesOverlay">Back to Tree</button>
      <h2>DXF Line Types</h2>
      <div id="overlayLineTypesContent"></div>
    </div>
  </div>
  <div id="textsOverlay" style="display:none; position: fixed; top:0; left:0; width:100%; height:100%; background-color: rgba(0,0,0,0.5); z-index:1000;">
    <div class="overlay-content">
      <button id="closeTextsOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="textsOverlay">Back to Tree</button>
      <h2>DXF Texts</h2>
      <div id="overlayTextsContent"></div>
    </div>
  </div>
  <div id="batchProcessingOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); z-index:1000;">
    <div class="overlay-content" style="overflow:auto;">
      <button id="closeBatchOverlay" style="position:absolute; top:10px; right:10px; cursor:pointer;">Close</button>
      <h2>Batch Process DXF Files</h2>
      <div style="margin-bottom:1em;">
        <label>Select Root Directory:
          <!-- The "webkitdirectory" (and "directory") attribute allows directory selection -->
          <input type="file" id="directoryInput" webkitdirectory directory multiple>
        </label>
      </div>
      <div style="margin-bottom:1em;">
        <label>Object Type:
          <input type="text" id="batchObjectType" placeholder="e.g. LINE, CIRCLE">
        </label>
      </div>
      <div style="margin-bottom:1em;">
        <label>Search Data:
          <input type="text" id="batchSearchText" placeholder="Enter search text">
        </label>
      </div>
      <div style="margin-bottom:1em;">
        <label>
          <input type="radio" name="batchSearchMode" value="contains" checked> Contains
        </label>
        <label>
          <input type="radio" name="batchSearchMode" value="exact"> Exact
        </label>
      </div>
      <div style="margin-bottom:1em;">
        <button id="startBatchProcess">Start Batch Process</button>
        <progress id="batchProgress" value="0" max="100" style="width:100%; display:none;"></progress>
      </div>
      <hr>
      <h3>Results</h3>
      <!-- New download button added -->
      <button id="downloadExcelBtn" style="margin-bottom:1em;">Download as Excel</button>
      <div style="overflow:auto; max-height:300px;">
        <table id="batchResultsTable" border="1" cellspacing="0" cellpadding="4" style="width:100%;">
          <thead>
            <tr>
              <th>#</th>
              <th>File (Relative Path)</th>
              <th>Line</th>
              <th>Data</th>
            </tr>
          </thead>
          <tbody>
            <!-- Matches will be appended here -->
          </tbody>
        </table>
      </div>
    </div>
  </div>
  <!-- Utility Functions -->
  <script>
    // Convert a concatenated hex string into a Uint8Array.
    function hexStringToByteArray(hexString) {
      hexString = hexString.replace(/\s+/g, "");
      const byteLength = Math.floor(hexString.length / 2);
      const result = new Uint8Array(byteLength);
      for (let i = 0; i < byteLength; i++) {
        result[i] = parseInt(hexString.substr(i * 2, 2), 16);
      }
      return result;
    }
    // Produce a hex dump from a Uint8Array.
    function hexDump(buffer) {
      const bytesPerLine = 16;
      let result = "";
      for (let i = 0; i < buffer.length; i += bytesPerLine) {
        const lineBytes = Array.from(buffer.slice(i, i + bytesPerLine));
        const hexBytes = lineBytes.map(byte => byte.toString(16).padStart(2, '0'));
        const asciiChars = lineBytes.map(byte =>
          byte >= 32 && byte < 127 ? String.fromCharCode(byte) : '.'
        );
        while (hexBytes.length < bytesPerLine) {
          hexBytes.push("  ");
          asciiChars.push(" ");
        }
        result += i.toString(16).padStart(8, '0') + "  " +
                  hexBytes.join(" ") + "  " +
                  asciiChars.join("") + "\n";
      }
      return result;
    }
    // Attempt to detect a common file header from a Uint8Array.
    function detectHeader(buffer) {
      // Define a list of known file signatures.
      // Each signature can be defined as an array of byte values or as a string.
      // (You can add an "offset" property if the signature does not start at 0.)
      const signatures = [
        { type: "BMP Image",    signature: [0x42, 0x4D] },
        { type: "PNG Image",    signature: [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A] },
        { type: "GIF Image",    signature: "GIF87a" },
        { type: "GIF Image",    signature: "GIF89a" },
        { type: "JPEG Image",   signature: [0xFF, 0xD8, 0xFF] },
        { type: "PDF Document", signature: "%PDF" },
        { type: "ZIP Archive",  signature: [0x50, 0x4B, 0x03, 0x04] },
        // Additional formats:
        { type: "RAR Archive",  signature: [0x52, 0x61, 0x72, 0x21, 0x1A, 0x07, 0x00] },
        { type: "RAR Archive",  signature: [0x52, 0x61, 0x72, 0x21, 0x1A, 0x07, 0x01, 0x00] },
        { type: "7z Archive",   signature: [0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C] },
        { type: "ELF Executable", signature: [0x7F, 0x45, 0x4C, 0x46] }
      ];

      // Iterate over the signature definitions.
      for (const sig of signatures) {
        // Determine the starting offset (default is 0)
        const offset = sig.offset || 0;
        // Ensure the buffer is long enough to check this signature.
        const sigLength = (typeof sig.signature === "string")
          ? sig.signature.length
          : sig.signature.length;
        if (buffer.length < offset + sigLength) continue;

        if (typeof sig.signature === "string") {
          // Compare the signature as a text string.
          const header = String.fromCharCode(...buffer.slice(offset, offset + sigLength));
          if (header === sig.signature) return sig.type;
        } else if (Array.isArray(sig.signature)) {
          // Compare the signature byte by byte.
          let match = true;
          for (let i = 0; i < sig.signature.length; i++) {
            if (buffer[offset + i] !== sig.signature[i]) {
              match = false;
              break;
            }
          }
          if (match) return sig.type;
        }
      }
      return null;
    }
  </script>
  <!-- JavaScript Classes -->
  <script>
    class DxfParser {
      constructor() {
        this.containerMapping = {
          "SECTION": "ENDSEC",
          "BLOCK":   "ENDBLK",
          "TABLE":   "ENDTAB",
          "OBJECT":  "ENDOBJ",
          "POLYLINE": "SEQEND"
        };
        this.nextId = 1;
        this.handleCodes = [5, 105, 330, 350, 360];
      }
      parse(text) {
        const tags = this.parseDxf(text);
        const grouped = this.groupObjectsIterative(tags, 0);
        return grouped.objects;
      }
      parseDxf(text) {
        // Split on CR/LF without discarding blank lines in the value portion.
        const lines = text.split(/\r?\n/);
        const tags = [];
        for (let i = 0; i < lines.length; i++) {
          // Read the code line. (A DXF tag always begins with a numeric code.)
          // We trim the code line to remove extraneous whitespace.
          let codeLine = lines[i].trim();
          // If the code line is empty then it is not valid – skip it.
          if (codeLine === "") continue;
          let code = parseInt(codeLine, 10);
          if (isNaN(code)) continue;
          // For the value line, do not force a non‑empty string.
          // If the line is empty it still counts as valid data.
          let value = "";
          if (i + 1 < lines.length) {
            // If you want to preserve leading/trailing whitespace from the value, omit .trim()
            value = lines[i + 1];
            // Alternatively, if you want to remove extra whitespace, you can use .trim():
            // value = lines[i + 1].trim();
          }
          // Advance one extra line to skip the value that was just processed.
          i++;
          // Record the tag. Note: the "line" property is set to the line number (i.e. the index of the value line)
          // so that it corresponds to the original file numbering.
          tags.push({ line: i, code, value });
        }
        return tags;
      }

      parseDxfLines(lines) {
        const tags = [];
        for (let i = 0; i < lines.length; i++) {
          const codeLine = lines[i].trim();
          if (!codeLine) continue;
          const code = parseInt(codeLine, 10);
          if (isNaN(code)) continue;
          let value = "";
          if (i + 1 < lines.length) { value = lines[i + 1].trim(); }
          i++;
          tags.push({ line: i, code, value });
        }
        return tags;
      }

      groupObjects(tags, startIndex, endMarker = null, containerStartLine = null) {
        const objects = [];
        let i = startIndex;
        // Track the highest non‑empty line number seen so far in this grouping.
        let lastNonEmptyLine = containerStartLine !== null ? containerStartLine : 0;

        while (i < tags.length) {
          // If we encounter the expected end marker…
          if (
            endMarker &&
            tags[i].code === 0 &&
            tags[i].value.toUpperCase() === endMarker
          ) {
            if (tags[i].value.trim() !== "") {
              lastNonEmptyLine = Math.max(lastNonEmptyLine, tags[i].line);
            }
            const endNode = {
              id: this.nextId++,
              type: tags[i].value,
              line: tags[i].line,
              code: tags[i].code, // typically 0
              properties: [],
              children: [],
              isEndMarker: true,
              expanded: false
            };
            lastNonEmptyLine = Math.max(lastNonEmptyLine, tags[i].line);
            i++;
            while (i < tags.length && tags[i].code !== 0) {
              if (tags[i].value.trim() !== "") {
                lastNonEmptyLine = Math.max(lastNonEmptyLine, tags[i].line);
              }
              endNode.properties.push(tags[i]);
              i++;
            }
            objects.push(endNode);
            return { objects, nextIndex: i };
          }

          // Skip any tag that is not the start of an entity.
          if (tags[i].code !== 0) {
            if (tags[i].value.trim() !== "") {
              lastNonEmptyLine = Math.max(lastNonEmptyLine, tags[i].line);
            }
            i++;
            continue;
          }

          // ★ Check for the EOF marker.
          if (tags[i].code === 0 && tags[i].value.toUpperCase() === "EOF") {
            const eofNode = {
              id: this.nextId++,
              type: "EOF",
              line: tags[i].line,
              code: tags[i].code,
              properties: [],
              children: [],
              isEOF: true,    // flag this node as an EOF marker
              expanded: false
            };
            objects.push(eofNode);
            i++;
            continue;
          }

          // Process a new entity (a tag with code 0)
          const entity = {
            id: this.nextId++,
            type: tags[i].value,
            line: tags[i].line,
            code: tags[i].code,
            properties: [],
            children: [],
            isContainer: this.containerMapping.hasOwnProperty(tags[i].value.toUpperCase()),
            expanded: false
          };
          if (tags[i].value.trim() !== "") {
            lastNonEmptyLine = Math.max(lastNonEmptyLine, tags[i].line);
          }
          i++;

          // Collect subsequent property tags (all tags with code !== 0)
          while (i < tags.length && tags[i].code !== 0) {
            if (tags[i].value.trim() !== "") {
              lastNonEmptyLine = Math.max(lastNonEmptyLine, tags[i].line);
            }
            entity.properties.push(tags[i]);
            i++;
          }

          // Check for a handle property.
          const handleProp = entity.properties.find(prop =>
            this.handleCodes.includes(prop.code)
          );
          if (handleProp) {
            entity.handle = handleProp.value;
          }

          // If the entity is a container, process its children recursively.
          if (entity.isContainer) {
            const expectedEndMarker = this.containerMapping[entity.type.toUpperCase()];
            const result = this.groupObjects(tags, i, expectedEndMarker, entity.line);
            entity.children = result.objects;
            i = result.nextIndex;
            while (i < tags.length && tags[i].code !== 0) {
              if (tags[i].value.trim() !== "") {
                lastNonEmptyLine = Math.max(lastNonEmptyLine, tags[i].line);
              }
              entity.properties.push(tags[i]);
              i++;
            }
          }

          objects.push(entity);
        }

        // If an expected end marker was not found, create a synthetic one.
        if (endMarker) {
          const syntheticLine = lastNonEmptyLine + 1;
          const syntheticEndNode = {
            id: this.nextId++,
            type: endMarker,
            line: syntheticLine,
            code: 0,
            properties: [],
            children: [],
            isEndMarker: true,
            expanded: false,
            synthetic: true
          };
          objects.push(syntheticEndNode);
        }

        return { objects, nextIndex: i };
      }
      
      groupObjectsIterative(tags, startIndex = 0, endMarker = null, containerStartLine = null) {
  const objects = [];
  // The stack holds previous contexts when entering a container.
  const stack = [];
  // Our current context:
  let current = {
    // "children" is where nodes (entities) for this level are collected.
    children: objects,
    // If we are inside a container, this is the expected end marker (e.g. "ENDSEC")
    expectedEndMarker: endMarker,
    // Track the highest non‑empty line number seen in this grouping.
    lastNonEmptyLine: containerStartLine !== null ? containerStartLine : 0,
    // For container contexts, store the container entity so that later trailing property tags
    // (those immediately following its children) can be attached.
    containerNode: null
  };

  let i = startIndex;
  while (i < tags.length) {
    const tag = tags[i];
    // Update lastNonEmptyLine if this tag’s value is not empty.
    if (tag.value.trim() !== "") {
      current.lastNonEmptyLine = Math.max(current.lastNonEmptyLine, tag.line);
    }

    // If the tag is not a start-of-entity (code !== 0), skip it.
    if (tag.code !== 0) {
      i++;
      continue;
    }

    // (At this point tag.code === 0.)
    const tagValue = tag.value.trim();
    const tagValueU = tagValue.toUpperCase();

    // ─── 1. Check if we have reached the expected end marker for the current container ─────
    if (current.expectedEndMarker && tagValueU === current.expectedEndMarker) {
      // Update lastNonEmptyLine with this end marker.
      current.lastNonEmptyLine = Math.max(current.lastNonEmptyLine, tag.line);

      // Create an end‑marker node.
      const endNode = {
        id: this.nextId++,
        type: tag.value,
        line: tag.line,
        code: tag.code,
        properties: [],
        children: [],
        isEndMarker: true,
        expanded: false
      };

      i++; // move past the end marker tag

      // Collect any additional property tags that immediately follow the end marker.
      while (i < tags.length && tags[i].code !== 0) {
        const propTag = tags[i];
        if (propTag.value.trim() !== "") {
          current.lastNonEmptyLine = Math.max(current.lastNonEmptyLine, propTag.line);
        }
        endNode.properties.push(propTag);
        i++;
      }
      // Append the end marker node to the current container’s children.
      current.children.push(endNode);

      // ─── If we are finishing a container, then attach any trailing property tags
      // to the container entity (just like the recursive version does) ───────────────
      let finishedContext = current;
      let finishedContainer = finishedContext.containerNode;
      // Pop the previous context from the stack (if any).
      current = stack.length > 0 ? stack.pop() : { children: objects, expectedEndMarker: null, lastNonEmptyLine: finishedContext.lastNonEmptyLine, containerNode: null };

      // After closing a container, there may be extra property tags (until the next entity)
      // that should be attached to the container entity.
      while (i < tags.length && tags[i].code !== 0) {
        const extraProp = tags[i];
        if (extraProp.value.trim() !== "") {
          current.lastNonEmptyLine = Math.max(current.lastNonEmptyLine, extraProp.line);
        }
        if (finishedContainer) {
          finishedContainer.properties.push(extraProp);
        }
        i++;
      }
      continue; // proceed with next tag
    }

    // ─── 2. Check for EOF marker ─────────────────────────────
    if (tagValueU === "EOF") {
      const eofNode = {
        id: this.nextId++,
        type: "EOF",
        line: tag.line,
        code: tag.code,
        properties: [],
        children: [],
        isEOF: true,
        expanded: false
      };
      current.children.push(eofNode);
      i++;
      continue;
    }

    // ─── 3. Process a new entity (a tag with code 0 that isn’t an end marker) ───
    const entity = {
      id: this.nextId++,
      type: tag.value,
      line: tag.line,
      code: tag.code,
      properties: [],
      children: [],
      expanded: false,
      isContainer: !!this.containerMapping[tag.value.toUpperCase()]
    };
    // (Note: current.lastNonEmptyLine already updated above for tag.value.)
    i++;

    // Collect any following property tags (all tags with code !== 0).
    while (i < tags.length && tags[i].code !== 0) {
      const propTag = tags[i];
      if (propTag.value.trim() !== "") {
        current.lastNonEmptyLine = Math.max(current.lastNonEmptyLine, propTag.line);
      }
      entity.properties.push(propTag);
      i++;
    }

    // Look for a handle property among the collected properties.
    const handleProp = entity.properties.find(prop => this.handleCodes.includes(prop.code));
    if (handleProp) {
      entity.handle = handleProp.value;
    }

    // ─── 4. If the entity is a container, set up a new context for its children ───
    if (entity.isContainer) {
      // Push the current context on the stack.
      stack.push(current);
      // Add this container entity to the parent's children.
      // (The parent's context is now the one on the top of the stack.)
      const parentContext = stack[stack.length - 1];
      parentContext.children.push(entity);
      // Now create a new context for the container’s children.
      current = {
        children: entity.children,
        expectedEndMarker: this.containerMapping[entity.type.toUpperCase()],
        lastNonEmptyLine: entity.line,
        containerNode: entity
      };
    } else {
      // If not a container, simply add the entity to the current children.
      current.children.push(entity);
    }
  } // end while

  // ─── After processing all tags, if the current context was expecting an end marker,
  // create a synthetic end marker.
  while (true) {
    if (current.expectedEndMarker) {
      const syntheticLine = current.lastNonEmptyLine + 1;
      const syntheticEndNode = {
        id: this.nextId++,
        type: current.expectedEndMarker,
        line: syntheticLine,
        code: 0,
        properties: [],
        children: [],
        isEndMarker: true,
        expanded: false,
        synthetic: true
      };
      current.children.push(syntheticEndNode);
    }
    if (stack.length === 0) break;
    current = stack.pop();
  }

  return { objects, nextIndex: i };
}

      findNodeById(tree, id) {
        for (const obj of tree) {
          if (String(obj.id) === String(id)) return obj;
          if (obj.children && obj.children.length) {
            const result = this.findNodeById(obj.children, id);
            if (result) return result;
          }
        }
        return null;
      }

      findNodeByIdIterative(tree, id) {
        const stack = [...tree];
        while (stack.length) {
          const node = stack.pop();
          if (String(node.id) === String(id)) {
            return node;
          }
          if (node.children && node.children.length > 0) {
            stack.push(...node.children);
          }
        }
        return null;
      }

      serializeNode(node) {
        let lines = [];
        lines.push("0");
        lines.push(node.type);
        node.properties.forEach(prop => {
          lines.push(prop.code.toString());
          lines.push(prop.value);
        });
        if (node.isContainer && node.children && node.children.length) {
          node.children.forEach(child => {
            lines.push(this.serializeNode(child));
          });
          // Only add an extra end marker if the last child isn’t one already.
          const lastChild = node.children[node.children.length - 1];
          if (!lastChild.isEndMarker) {
            const endMarker = this.containerMapping[node.type.toUpperCase()];
            if (endMarker) { 
              lines.push("0"); 
              lines.push(endMarker); 
            }
          }
        }
        return lines.join("\n");
      }

    }
  </script>
  <!-- TreeDataGrid Control -->
  <script>
    class TreeDataGrid {
      constructor(container, content, options = {}) {
        this.container = container;
        this.content = content;
        this.itemHeight = options.itemHeight || 24;
        this.copyCallback = options.copyCallback || null;
        this.openCallback = options.openCallback || null;
        this.onToggleExpand = options.onToggleExpand || null;
        this.onHandleClick = options.onHandleClick || null;
        this.hexViewerCallback = options.hexViewerCallback || null;
        this.onRowSelect = options.onRowSelect || null;
        this.columnWidths = options.columnWidths || {
          line: 100,
          code: 100,
          type: "*",
          objectCount: 100,
          dataSize: 100
        };
        this.flatData = [];
        this.treeData = [];
        this.selectedRowId = null;
        this.container.addEventListener("scroll", () => { 
          requestAnimationFrame(() => this.updateVisibleNodes());
        });
        this.attachHeaderResizerEvents();
        this.content.addEventListener("click", (e) => {
          if (e.target.classList.contains("toggle")) {
            e.stopPropagation();
            const row = e.target.closest(".tree-row");
            if (row) {
              const nodeId = row.dataset.id;
              if (this.onToggleExpand) { this.onToggleExpand(nodeId); }
            }
          }
        });
      }
      
      attachHeaderResizerEvents() {
        const headerResizers = document.querySelectorAll('#treeGridHeader .header-cell .resizer');
        headerResizers.forEach(resizer => {
          resizer.addEventListener("mousedown", (e) => this.handleResizerMouseDown(e));
        });
      }
      
      handleResizerMouseDown(e) {
        e.stopPropagation();
        const headerCell = e.target.parentElement;
        const field = headerCell.getAttribute('data-field');
        const startX = e.clientX;
        const startWidth = headerCell.offsetWidth;
        const onMouseMove = (eMove) => {
          const newWidth = startWidth + (eMove.clientX - startX);
          this.columnWidths[field] = newWidth;
          headerCell.style.width = newWidth + "px";
          headerCell.style.flex = "none";
          this.updateVisibleNodes();
        };
        const onMouseUp = () => {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        };
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      }
      
      computeColumnFinalWidths() {
        const containerWidth = this.container.clientWidth;
        const columns = ["line", "code", "type", "objectCount", "dataSize"];
        let fixedTotal = 0;
        let starTotal = 0;
        let finalWidths = {};
        columns.forEach(col => {
          let def = this.columnWidths[col];
          if (typeof def === "number") {
            finalWidths[col] = def;
            fixedTotal += def;
          } else if (typeof def === "string") {
            if (def.toLowerCase() === "auto") {
              const headerCell = document.querySelector(`#treeGridHeader .tree-${col}`);
              let autoWidth = headerCell ? headerCell.scrollWidth : 100;
              finalWidths[col] = autoWidth;
              fixedTotal += autoWidth;
            } else if (def.trim().endsWith("*")) {
              let multiplier = parseFloat(def.trim().slice(0, -1));
              if (isNaN(multiplier)) multiplier = 1;
              starTotal += multiplier;
              finalWidths[col] = { star: multiplier };
            } else {
              let pixels = parseFloat(def);
              if (!isNaN(pixels)) {
                finalWidths[col] = pixels;
                fixedTotal += pixels;
              } else {
                finalWidths[col] = 100;
                fixedTotal += 100;
              }
            }
          } else {
            starTotal += 1;
            finalWidths[col] = { star: 1 };
          }
        });
        let remaining = containerWidth - fixedTotal;
        if (remaining < 0) remaining = 0;
        columns.forEach(col => {
          if (typeof finalWidths[col] === "object" && finalWidths[col].star) {
            let multiplier = finalWidths[col].star;
            let width = (multiplier / starTotal) * remaining;
            finalWidths[col] = width;
          }
        });
        return finalWidths;
      }
      
      syncHeaderWidths() {
        const header = document.getElementById("treeGridHeader");
        if (!header) return;
        const colWidths = this.computeColumnFinalWidths();
        const lineCell = header.querySelector('.tree-line');
        if (lineCell) lineCell.style.width = colWidths.line + "px";
        const codeCell = header.querySelector('.tree-code');
        if (codeCell) codeCell.style.width = colWidths.code + "px";
        const typeCell = header.querySelector('.tree-data');
        if (typeCell) {
          typeCell.style.width = colWidths.type + "px";
          typeCell.style.flex = "0 0 auto";
        }
        const objectCountCell = header.querySelector('.tree-object-count');
        if (objectCountCell) objectCountCell.style.width = colWidths.objectCount + "px";
        const dataSizeCell = header.querySelector('.tree-data-size');
        if (dataSizeCell) dataSizeCell.style.width = colWidths.dataSize + "px";
      }
      
      setData(treeData) {
        this.treeData = treeData || [];
        this.refresh();
      }
      
      refresh() {
        this.flatData = this.flattenTree(this.treeData);
        this.updateVisibleNodes();
      }
      
      /*
      flattenTree(nodes, level = 0) {
        let flat = [];
        for (let node of nodes) {
          flat.push({ node, level });
          if (node.expanded) {
            if (node.properties && node.properties.length) {
              for (let prop of node.properties) {
                flat.push({
                  node: {
                    id: `prop-${node.id}-${prop.line}-${prop.code}`,
                    isProperty: true,
                    line: prop.line,
                    code: prop.code,
                    data: prop.value
                  },
                  level: level + 1
                });
              }
            }
            if (node.children && node.children.length) {
              flat = flat.concat(this.flattenTree(node.children, level + 1));
            }
          }
        }
        return flat;
      }
      */

      flattenTree(nodes, initialLevel = 0) {
        const flat = [];
        const stack = [];
        // Push the initial nodes in reverse order so that the first node is processed first.
        for (let i = nodes.length - 1; i >= 0; i--) {
          stack.push({ node: nodes[i], level: initialLevel });
        }

        while (stack.length > 0) {
          const { node, level } = stack.pop();
          flat.push({ node, level });

          if (node.expanded) {
            // We want properties to appear immediately after the node.
            // To achieve that with a LIFO stack, we push the children first...
            if (node.children && node.children.length > 0) {
              for (let i = node.children.length - 1; i >= 0; i--) {
                stack.push({ node: node.children[i], level: level + 1 });
              }
            }
            // ...and then push the properties so they come off the stack before the children.
            if (node.properties && node.properties.length > 0) {
              // Push properties in reverse order so that when popped, they appear in the original order.
              for (let i = node.properties.length - 1; i >= 0; i--) {
                const prop = node.properties[i];
                stack.push({
                  node: {
                    id: `prop-${node.id}-${prop.line}-${prop.code}`,
                    isProperty: true,
                    line: prop.line,
                    code: prop.code,
                    data: prop.value
                  },
                  level: level + 1
                });
              }
            }
          }
        }

        return flat;
      }

      computeObjectCount(node) {
        if (!node.children || node.children.length === 0) return 0;
        let count = 0;
        for (let child of node.children) {
          if (!child.isProperty) {
            count++;
            if (child.children && child.children.length) { 
              count += this.computeObjectCount(child);
            }
          }
        }
        return count;
      }
      
      computeDataSize(node) {
        let size = 0;
        if (node.isProperty) {
          size += node.data ? node.data.length : 0;
        } else {
          size += node.type ? node.type.length : 0;
          if (node.properties && node.properties.length) {
            for (let prop of node.properties) {
              size += prop.value ? prop.value.length : 0;
            }
          }
          if (node.children && node.children.length) {
            for (let child of node.children) { size += this.computeDataSize(child); }
          }
        }
        return size;
      }

      updateVisibleNodes() {
        const scrollTop = this.container.scrollTop;
        const containerHeight = this.container.clientHeight;
        const totalRows = this.flatData.length;
        const fullHeight = totalRows * this.itemHeight;
        this.content.style.height = fullHeight + "px";

        const colWidths = this.computeColumnFinalWidths();
        const lineWidth = colWidths.line;
        const codeWidth = colWidths.code;
        const dataWidth = colWidths.type;
        const objectCountWidth = colWidths.objectCount;
        const dataSizeWidth = colWidths.dataSize;
        const totalWidth = lineWidth + codeWidth + dataWidth + objectCountWidth + dataSizeWidth;

        const containerElem = document.createElement("div");
        containerElem.style.width = totalWidth + "px";

        const startIndex = Math.floor(scrollTop / this.itemHeight);
        const visibleCount = Math.ceil(containerHeight / this.itemHeight) + 1;
        const endIndex = Math.min(startIndex + visibleCount, totalRows);

        const topSpacer = document.createElement("div");
        topSpacer.style.height = (startIndex * this.itemHeight) + "px";
        containerElem.appendChild(topSpacer);

        const fragment = document.createDocumentFragment();
        for (let i = startIndex; i < endIndex; i++) {
          const { node, level } = this.flatData[i];
          const row = document.createElement("div");
          row.className = "tree-row tree-node";
          row.style.display = "flex";
          row.style.position = "relative";
          row.style.height = this.itemHeight + "px";
          row.dataset.id = node.id;
          if (String(node.id) === String(this.selectedRowId)) {
            row.classList.add("selected");
          }
         row.addEventListener("click", (e) => {
          // If the user is in the middle of selecting text, do nothing.
          if (window.getSelection().toString().length > 0) {
            return;
          }
          // Otherwise, proceed with row selection.
          this.selectedRowId = node.id;
          this.updateVisibleNodes();
          if (this.onRowSelect) {
            this.onRowSelect(node.id);
          }
        });

          // Line column.
          const lineDiv = document.createElement("div");
          lineDiv.className = "tree-line";
          lineDiv.style.width = lineWidth + "px";
          const lineContent = document.createElement("div");
          lineContent.style.display = "flex";
          lineContent.style.alignItems = "center";
          lineContent.style.marginLeft = (level * 20) + "px";
          if (!node.isProperty && ((node.properties && node.properties.length) || (node.children && node.children.length))) {
            const toggleSpan = document.createElement("span");
            toggleSpan.className = "toggle";
            toggleSpan.textContent = node.expanded ? "▼" : "►";
            toggleSpan.addEventListener("click", (e) => {
              e.stopPropagation();
              if (this.onToggleExpand) { this.onToggleExpand(node.id); }
            });
            lineContent.appendChild(toggleSpan);
          } else {
            const spacer = document.createElement("span");
            spacer.style.width = "16px";
            spacer.style.display = "inline-block";
            lineContent.appendChild(spacer);
          }
          const lineNumberSpan = document.createElement("span");
          lineNumberSpan.textContent = node.line || "";
          lineContent.appendChild(lineNumberSpan);
          lineDiv.appendChild(lineContent);
          row.appendChild(lineDiv);

          // Code column.
          const codeDiv = document.createElement("div");
          codeDiv.className = "tree-code";
          codeDiv.style.width = codeWidth + "px";
          codeDiv.style.textAlign = "left";
          // For properties or end markers we normally display the code.
          if (node.isProperty || node.isEndMarker) {
            codeDiv.textContent = node.code;
          } else {
            codeDiv.textContent = ((node.properties && node.properties.length) || (node.children && node.children.length)) ? "0" : "";
          }
          row.appendChild(codeDiv);

          // Data column.
          const dataDiv = document.createElement("div");
          dataDiv.className = "tree-data";
          dataDiv.style.width = dataWidth + "px";
          dataDiv.style.flex = "0 0 auto";
          // When rendering a row…
          if (node.isProperty) {
            // Define the list of DXF group codes that represent handles.
            const handleCodes = [5, 105, 330, 350, 360];

            // If this property’s code is one of the handle codes,
            // create a clickable span instead of plain text.
            if (handleCodes.includes(Number(node.code))) {
              const spanHandle = document.createElement("span");
              spanHandle.textContent = node.data;
              spanHandle.style.textDecoration = "underline";
              spanHandle.style.color = "blue";
              spanHandle.style.cursor = "pointer";
              spanHandle.addEventListener("click", (e) => {
                e.preventDefault();
                if (this.onHandleClick) { 
                  this.onHandleClick(node.data);
                }
              });
              dataDiv.appendChild(spanHandle);
            } else {
              // Otherwise, simply display the property data.
              dataDiv.textContent = node.data;
            }
          } else {
            // For non‑property nodes, keep all your original functionality.
            dataDiv.textContent = node.type || "";
            // Append the handle (if any) as a clickable link.
            if (node.handle) {
              const spanHandle = document.createElement("span");
              spanHandle.textContent = " (" + node.handle + ")";
              spanHandle.style.textDecoration = "underline";
              spanHandle.style.color = "blue";
              spanHandle.style.cursor = "pointer";
              spanHandle.addEventListener("click", (e) => {
                e.preventDefault();
                if (this.onHandleClick) { 
                  this.onHandleClick(node.handle);
                }
              });
              dataDiv.appendChild(spanHandle);
            }
            // Retain the copy, open, and hex viewer buttons as before.
            if (this.copyCallback && !node.isProperty) {
              const copyButton = document.createElement("button");
              copyButton.textContent = "Copy";
              copyButton.className = "copy-button";
              copyButton.addEventListener("click", (e) => {
                e.stopPropagation();
                this.copyCallback(node.id);
              });
              dataDiv.appendChild(copyButton);
            }
            if (!node.isProperty) {
              const openButton = document.createElement("button");
              openButton.textContent = "Open";
              openButton.className = "open-button";
              openButton.addEventListener("click", (e) => {
                e.stopPropagation();
                if (this.openCallback) { 
                  this.openCallback(node.id);
                }
              });
              dataDiv.appendChild(openButton);
            }
            if (!node.isProperty && node.properties) {
              const binaryProps = node.properties.filter(prop => Number(prop.code) === 310);
              if (binaryProps.length > 0) {
                const combinedData = binaryProps.map(prop => prop.value).join("");
                const hexButton = document.createElement("button");
                hexButton.textContent = "Hex Viewer";
                hexButton.className = "hex-button";
                hexButton.addEventListener("click", (e) => {
                  e.stopPropagation();
                  if (this.hexViewerCallback) { 
                    this.hexViewerCallback(combinedData);
                  }
                });
                dataDiv.appendChild(hexButton);
              }
            }
          }

          row.appendChild(dataDiv);

          // Object Count column.
          const objectCountDiv = document.createElement("div");
          objectCountDiv.className = "tree-object-count";
          objectCountDiv.style.width = objectCountWidth + "px";
          objectCountDiv.style.textAlign = "right";
          if (!node.isProperty && node.children && node.children.length) {
            objectCountDiv.textContent = this.computeObjectCount(node);
          } else {
            objectCountDiv.textContent = "";
          }
          row.appendChild(objectCountDiv);

          // Data Size column.
          const dataSizeDiv = document.createElement("div");
          dataSizeDiv.className = "tree-data-size";
          dataSizeDiv.style.width = dataSizeWidth + "px";
          dataSizeDiv.style.textAlign = "right";
          dataSizeDiv.textContent = this.computeDataSize(node);
          row.appendChild(dataSizeDiv);

          // ★ If this node represents an EOF marker, adjust its display.
          if (node.isEOF) {
            codeDiv.textContent = node.code;      // Should show "0"
            dataDiv.textContent = node.type;        // Will show "EOF"
          }

          fragment.appendChild(row);
        }
        containerElem.appendChild(fragment);
        const bottomSpacer = document.createElement("div");
        const bottomHeight = Math.max(0, fullHeight - (startIndex + visibleCount) * this.itemHeight);
        bottomSpacer.style.height = bottomHeight + "px";
        containerElem.appendChild(bottomSpacer);
        this.content.innerHTML = "";
        this.content.appendChild(containerElem);
        this.syncHeaderWidths();
      }

    }
  </script>
  <!-- Application Code -->
  <script>
    class App {
      constructor() {
        // Define column widths – these will be passed into the TreeDataGrid constructor.
        this.columnWidths = {
          line: 130,
          code: 100,
          type: "*", // Star sizing: takes up remaining space.
          objectCount: 130,
          dataSize: 130
        };
        this.dxfParser = new DxfParser();
        this.treeViewContainer = document.getElementById("treeViewContainer");
        this.treeViewContent = document.getElementById("treeViewContent");
        this.tabs = [];
        this.activeTabId = null;
        this.currentBinaryData = null;
        this.currentDetectedType = null;
            // We'll cache the measured hex line height here.
    this.hexLineHeight = null;
        // Create the TreeDataGrid instance and pass columnWidths via the constructor.
        this.myTreeGrid = new TreeDataGrid(this.treeViewContainer, this.treeViewContent, {
          itemHeight: 24,
          copyCallback: (nodeId) => this.handleCopy(nodeId),
          openCallback: (nodeId) => this.handleOpen(nodeId),  // <-- new callback for "Open" button
          onToggleExpand: (nodeId) => this.handleToggleExpand(nodeId),
          onHandleClick: (handle) => this.handleLinkToHandle(handle),
          onRowSelect: (nodeId) => console.log("Row selected:", nodeId),
          columnWidths: this.columnWidths,
          hexViewerCallback: (combinedHexString) => this.showHexViewer(combinedHexString)
        });
        this.initEventListeners();
      }
      initEventListeners() {
        document.getElementById("parseBtn").addEventListener("click", () => this.handleParse());
        document.getElementById("expandAllBtn").addEventListener("click", () => this.handleExpandAll());
        document.getElementById("collapseAllBtn").addEventListener("click", () => this.handleCollapseAll());
        document.querySelectorAll('.header-cell').forEach(headerCell => {
          headerCell.addEventListener('click', (e) => {
            if (e.target.classList.contains('resizer')) return;
            this.handleHeaderClick(headerCell);
          });
        });
        document.querySelectorAll('.header-cell .resizer').forEach(resizer => {
          resizer.addEventListener('mousedown', (e) => this.handleResizerMouseDown(e));
        });
        this.setupTagInput("codeSearchInput", "code");
        this.setupTagInput("dataSearchInput", "data");
        document.getElementById("searchBtn").addEventListener("click", () => this.handleSearch());
        document.getElementById("clearSearchBtn").addEventListener("click", () => this.handleClearSearch());
        document.getElementById("showCloudOverlayBtn").addEventListener("click", () => {
          this.updateClouds();
          document.getElementById("cloudOverlay").style.display = "block";
        });
        document.getElementById("closeCloudOverlay").addEventListener("click", () => {
          document.getElementById("cloudOverlay").style.display = "none";
        });
        document.getElementById("showStatsOverlayBtn").addEventListener("click", () => {
          this.updateStats();
          document.getElementById("statsOverlay").style.display = "block";
        });
        document.getElementById("closeStatsOverlay").addEventListener("click", () => {
          document.getElementById("statsOverlay").style.display = "none";
        });
        document.getElementById("showDepsOverlayBtn").addEventListener("click", () => {
          this.updateDependencies();
          document.getElementById("depsOverlay").style.display = "block";
        });
        document.getElementById("closeDepsOverlay").addEventListener("click", () => {
          document.getElementById("depsOverlay").style.display = "none";
        });
        document.getElementById("showBinaryObjectsOverlayBtn").addEventListener("click", () => {
          this.showBinaryObjectsOverlay();
        });
        document.getElementById("closeBinaryObjectsOverlay").addEventListener("click", () => {
          document.getElementById("binaryObjectsOverlay").style.display = "none";
        });
        document.getElementById("showHandleMapOverlayBtn").addEventListener("click", () => {
          this.updateHandleMap();
          document.getElementById("handleMapOverlay").style.display = "block";
        });
        document.getElementById("closeHandleMapOverlay").addEventListener("click", () => {
          document.getElementById("handleMapOverlay").style.display = "none";
        });
        document.getElementById("showProxyObjectsOverlayBtn").addEventListener("click", () => {
          this.showProxyObjectsOverlay();
        });
        document.getElementById("closeProxyObjectsOverlay").addEventListener("click", () => {
          document.getElementById("proxyObjectsOverlay").style.display = "none";
        });
        document.getElementById("showFontsOverlayBtn").addEventListener("click", () => {
          this.updateFonts();
          document.getElementById("fontsOverlay").style.display = "block";
        });
        document.getElementById("closeFontsOverlay").addEventListener("click", () => {
          document.getElementById("fontsOverlay").style.display = "none";
        });
        document.getElementById("showClassesOverlayBtn").addEventListener("click", () => {
          this.updateClasses();
          document.getElementById("classesOverlay").style.display = "block";
        });
        document.getElementById("closeClassesOverlay").addEventListener("click", () => {
          document.getElementById("classesOverlay").style.display = "none";
        });
        document.getElementById("showObjectSizeOverlayBtn").addEventListener("click", () => {
          this.showObjectSizeDialog();
        });
        document.getElementById("closeObjectSizeOverlay").addEventListener("click", () => {
          document.getElementById("objectSizeOverlay").style.display = "none";
        });
        document.getElementById("showBlocksOverlayBtn").addEventListener("click", () => {
          this.updateBlocksOverlay();
          document.getElementById("blocksOverlay").style.display = "block";
        });
        document.getElementById("closeBlocksOverlay").addEventListener("click", () => {
          document.getElementById("blocksOverlay").style.display = "none";
        });
        document.getElementById("showLineTypesOverlayBtn").addEventListener("click", () => {
          this.updateLineTypes();
          document.getElementById("lineTypesOverlay").style.display = "block";
        });
        document.getElementById("closeLineTypesOverlay").addEventListener("click", () => {
          document.getElementById("lineTypesOverlay").style.display = "none";
        });
        document.getElementById("showTextsOverlayBtn").addEventListener("click", () => {
          this.updateTexts();
          document.getElementById("textsOverlay").style.display = "block";
        });
        document.getElementById("closeTextsOverlay").addEventListener("click", () => {
          document.getElementById("textsOverlay").style.display = "none";
        });
        document.getElementById("showBatchProcessOverlayBtn").addEventListener("click", () => {
        document.getElementById("batchProcessingOverlay").style.display = "block";
        });
        document.getElementById("closeBatchOverlay").addEventListener("click", () => {
          document.getElementById("batchProcessingOverlay").style.display = "none";
        });
        document.getElementById("startBatchProcess").addEventListener("click", () => this.handleBatchProcess());
        document.getElementById("downloadExcelBtn").addEventListener("click", () => this.downloadBatchResultsAsExcel());
        document.getElementById("dataExactCheckbox").addEventListener("change", () => this.handleSearchOptionChange());
        document.getElementById("dataCaseCheckbox").addEventListener("change", () => this.handleSearchOptionChange());
        document.getElementById("codeSearchInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("dataSearchInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("minLineInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("maxLineInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("goToHandleBtn").addEventListener("click", () => this.handleGoToHandle());
        document.getElementById("backBtn").addEventListener("click", () => this.navigateBack());
        document.getElementById("forwardBtn").addEventListener("click", () => this.navigateForward());
        document.getElementById("clearHistoryBtn").addEventListener("click", () => this.clearNavigationHistory());
        this.treeViewContainer.addEventListener("scroll", (e) => {
          const scrollLeft = e.target.scrollLeft;
          document.getElementById("treeGridHeader").style.transform = "translateX(-" + scrollLeft + "px)";
        });
        window.addEventListener("resize", () => { this.myTreeGrid.updateVisibleNodes(); });
        document.getElementById("closeHexViewerOverlay").addEventListener("click", () => {
          document.getElementById("hexViewerOverlay").style.display = "none";
          document.getElementById("imagePreviewContainer").innerHTML = "";
          document.getElementById("zipContentsContainer").innerHTML = "";
        });
        document.getElementById("saveBinaryBtn").addEventListener("click", () => {
          if (this.currentBinaryData) {
            const typeExtensions = {
              "PNG Image": "png",
              "GIF Image": "gif",
              "JPEG Image": "jpg",
              "BMP Image": "bmp",
              "PDF Document": "pdf",
              "ZIP Archive": "zip"
            };
            let ext = "bin";
            if (this.currentDetectedType && typeExtensions[this.currentDetectedType]) {
              ext = typeExtensions[this.currentDetectedType];
            }
            const blob = new Blob([this.currentBinaryData], { type: "application/octet-stream" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "binary_data." + ext;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }
        });
        document.getElementById("previewImageBtn").addEventListener("click", () => { this.previewImage(); });
        document.querySelectorAll(".backToTreeBtn").forEach(btn => {
          btn.addEventListener("click", (e) => {
            const overlayId = btn.getAttribute("data-overlay");
            document.getElementById(overlayId).style.display = "none";
            this.treeViewContainer.focus();
          });
        });
        const resizer = document.querySelector('.pane-resizer');
        const sidebar = document.querySelector('.sidebar');
        const contentWrapper = document.querySelector('.content-wrapper');
        resizer.addEventListener('mousedown', (e) => {
          e.preventDefault();
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
          function onMouseMove(e) {
            const newWidth = e.clientX - contentWrapper.getBoundingClientRect().left;
            if(newWidth > 150 && newWidth < contentWrapper.clientWidth - 100) {
              sidebar.style.width = newWidth + 'px';
            }
          }
          function onMouseUp() {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          }
        });
      }
      updateEffectiveSearchTerms() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const codeInput = document.getElementById("codeSearchInput");
        const dataInput = document.getElementById("dataSearchInput");
        const codeText = codeInput.value.trim();
        const dataText = dataInput.value.trim();
        const effectiveCodeSearchTerms = activeTab.codeSearchTerms.slice();
        const effectiveDataSearchTerms = activeTab.dataSearchTerms.slice();
        if (codeText !== "" && !effectiveCodeSearchTerms.includes(codeText)) {
          effectiveCodeSearchTerms.push(codeText);
        }
        if (dataText !== "" && !effectiveDataSearchTerms.includes(dataText)) {
          effectiveDataSearchTerms.push(dataText);
        }
        const minLine = document.getElementById("minLineInput").value.trim() !== "" ? parseInt(document.getElementById("minLineInput").value.trim(), 10) : null;
        const maxLine = document.getElementById("maxLineInput").value.trim() !== "" ? parseInt(document.getElementById("maxLineInput").value.trim(), 10) : null;
        activeTab.minLine = minLine;
        activeTab.maxLine = maxLine;
        activeTab.dataExact = document.getElementById("dataExactCheckbox").checked;
        activeTab.dataCase = document.getElementById("dataCaseCheckbox").checked;
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeGrid.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      handleSearchOptionChange() { this.updateEffectiveSearchTerms(); }
      getActiveTab() { return this.tabs.find(t => t.id === this.activeTabId); }
      updateTabUI() {
        const tabContainer = document.getElementById("tabContainer");
        tabContainer.innerHTML = "";
        this.tabs.forEach(tab => {
          const tabElem = document.createElement("div");
          tabElem.className = "tab" + (tab.id === this.activeTabId ? " active" : "");
          tabElem.textContent = tab.name;
          tabElem.dataset.tabId = tab.id;
          tabElem.addEventListener("click", () => {
            this.activeTabId = tab.id;
            document.getElementById("codeSearchInput").value = "";
            document.getElementById("dataSearchInput").value = "";
            this.updateTagContainer("codeSearchTags", tab.codeSearchTerms, "code");
            this.updateTagContainer("dataSearchTags", tab.dataSearchTerms, "data");
            document.getElementById("minLineInput").value = tab.minLine !== null ? tab.minLine : "";
            document.getElementById("maxLineInput").value = tab.maxLine !== null ? tab.maxLine : "";
            document.getElementById("dataExactCheckbox").checked = tab.dataExact || false;
            document.getElementById("dataCaseCheckbox").checked = tab.dataCase || false;
            this.myTreeGrid.setData(tab.currentTreeData);
            this.updateTabUI();
          });
          const closeBtn = document.createElement("span");
          closeBtn.className = "close-tab";
          closeBtn.textContent = "×";
          closeBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            this.tabs = this.tabs.filter(t => t.id !== tab.id);
            if (this.activeTabId === tab.id) { this.activeTabId = this.tabs.length ? this.tabs[0].id : null; }
            this.updateTabUI();
            if (this.activeTabId) { this.myTreeGrid.setData(this.getActiveTab().currentTreeData); }
            else { this.myTreeGrid.setData([]); }
          });
          tabElem.appendChild(closeBtn);
          tabContainer.appendChild(tabElem);
        });
        this.updateNavHistoryUI();
        this.updateNavButtons();
      }
      expandAllNodes(nodes) {
        nodes.forEach(node => {
          if ((node.properties && node.properties.length) || (node.children && node.children.length)) {
            node.expanded = true;
            this.expandAllNodes(node.children);
          }
        });
      }
      collapseAllNodes(nodes) {
        nodes.forEach(node => {
          node.expanded = false;
          this.collapseAllNodes(node.children);
        });
      }
      handleExpandAll() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        this.expandAllNodes(activeTab.originalTreeData);
        if (activeTab.currentSortField) {
          this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
        }
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeGrid.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      handleCollapseAll() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        this.collapseAllNodes(activeTab.originalTreeData);
        if (activeTab.currentSortField) {
          this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
        }
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeGrid.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      handleToggleExpand(nodeId) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const node = this.dxfParser.findNodeByIdIterative(activeTab.originalTreeData, nodeId);
        if (node) {
          node.expanded = !node.expanded;
          if (activeTab.currentSortField) {
            this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
          }
          activeTab.currentTreeData = this.filterTree(
            activeTab.originalTreeData,
            activeTab.codeSearchTerms,
            activeTab.dataSearchTerms,
            activeTab.dataExact,
            activeTab.dataCase,
            activeTab.minLine,
            activeTab.maxLine
          );
          this.myTreeGrid.setData(activeTab.currentTreeData);
        }
      }
      getSortValue(node, field) {
        if (field === "line") { return node.line ? Number(node.line) : 0; }
        else if (field === "code") {
          if (node.isProperty) {
            const c = parseInt(node.code, 10);
            return isNaN(c) ? Number.MAX_SAFE_INTEGER : c;
          }
          return 0;
        } else if (field === "type") { return node.isProperty ? (node.data || "") : (node.type || ""); }
        else if (field === "objectCount") {
          if (node.isProperty) return 0;
          function countDescendants(n) {
            if (!n.children || n.children.length === 0) return 0;
            let count = 0;
            for (let child of n.children) {
              if (!child.isProperty) {
                count++;
                if (child.children && child.children.length) { count += countDescendants(child); }
              }
            }
            return count;
          }
          return countDescendants(node);
        } else if (field === "dataSize") {
          function computeSize(n) {
            if (n.isProperty) { return n.data ? n.data.length : 0; }
            else {
              let size = n.type ? n.type.length : 0;
              if (n.properties && n.properties.length) {
                for (let prop of n.properties) { size += prop.value ? prop.value.length : 0; }
              }
              if (n.children && n.children.length) {
                for (let child of n.children) { size += computeSize(child); }
              }
              return size;
            }
          }
          return computeSize(node);
        }
        return "";
      }
      sortTreeNodes(nodes, field, ascending) {
        nodes.sort((a, b) => {
          const aVal = this.getSortValue(a, field);
          const bVal = this.getSortValue(b, field);
          if (field === "code" || field === "line" || field === "objectCount" || field === "dataSize") {
            return (aVal - bVal) * (ascending ? 1 : -1);
          } else { return aVal.localeCompare(bVal) * (ascending ? 1 : -1); }
        });
        nodes.forEach(node => {
          if (node.properties && node.properties.length) {
            node.properties.sort((aProp, bProp) => {
              if (field === "code") {
                const aC = parseInt(aProp.code, 10) || 0;
                const bC = parseInt(bProp.code, 10) || 0;
                return (aC - bC) * (ascending ? 1 : -1);
              } else if (field === "line") {
                const aL = aProp.line || 0;
                const bL = bProp.line || 0;
                return (aL - bL) * (ascending ? 1 : -1);
              } else if (field === "type") {
                const aV = aProp.value || "";
                const bV = bProp.value || "";
                return aV.localeCompare(bV) * (ascending ? 1 : -1);
              }
              return 0;
            });
          }
          if (node.children && node.children.length) { this.sortTreeNodes(node.children, field, ascending); }
        });
      }
      handleHeaderClick(headerCell) {
        const field = headerCell.getAttribute('data-field');
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        let currentSort = headerCell.getAttribute('data-sort');
        let ascending = true;
        if (currentSort === 'asc') {
          ascending = false;
          headerCell.setAttribute('data-sort', 'desc');
          headerCell.querySelector('.sort-indicator').textContent = ' ▼';
        } else {
          ascending = true;
          headerCell.setAttribute('data-sort', 'asc');
          headerCell.querySelector('.sort-indicator').textContent = ' ▲';
        }
        activeTab.currentSortField = field;
        activeTab.currentSortAscending = ascending;
        document.querySelectorAll('.header-cell').forEach(cell => {
          if (cell !== headerCell) {
            cell.setAttribute('data-sort', 'none');
            cell.querySelector('.sort-indicator').textContent = '';
          }
        });
        this.sortTreeNodes(activeTab.originalTreeData, field, ascending);
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeGrid.setData(activeTab.currentTreeData);
      }
      handleResizerMouseDown(e) {
        e.stopPropagation();
        const headerCell = e.target.parentElement;
        const field = headerCell.getAttribute('data-field');
        const startX = e.clientX;
        const startWidth = headerCell.offsetWidth;
        const onMouseMove = (eMove) => {
          const newWidth = startWidth + (eMove.clientX - startX);
          this.columnWidths[field] = newWidth;
          headerCell.style.width = newWidth + "px";
          headerCell.style.flex = "none";
          this.myTreeGrid.updateVisibleNodes();
        };
        const onMouseUp = () => {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        };
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      }
      filterTree(objects, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine) {
        const filtered = [];
        objects.forEach(obj => {
          const filteredObj = this.filterObject(obj, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine);
          if (filteredObj !== null) { filtered.push(filteredObj); }
        });
        return filtered;
      }
      filterObject(obj, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine) {
        let nodeLine = parseInt(obj.line, 10);
        let lineMatches = true;
        if (minLine != null && !isNaN(minLine)) {
          if (isNaN(nodeLine) || nodeLine < minLine) lineMatches = false;
        }
        if (maxLine != null && !isNaN(maxLine)) {
          if (isNaN(nodeLine) || nodeLine > maxLine) lineMatches = false;
        }
        const filteredProperties = obj.properties.filter(prop => {
          let propLine = parseInt(prop.line, 10);
          if (minLine != null && !isNaN(minLine)) {
            if (isNaN(propLine) || propLine < minLine) return false;
          }
          if (maxLine != null && !isNaN(maxLine)) {
            if (isNaN(propLine) || propLine > maxLine) return false;
          }
          const codeMatch = (codeTerms.length === 0) ||
            codeTerms.some(term => String(prop.code) === term);
          let dataMatch = true;
          if (dataTerms.length > 0) {
            if (dataExact) {
              dataMatch = dataTerms.some(term =>
                dataCase ? (prop.value === term)
                         : (prop.value.toLowerCase() === term.toLowerCase())
              );
            } else {
              dataMatch = dataTerms.some(term =>
                dataCase ? prop.value.includes(term)
                         : prop.value.toLowerCase().includes(term.toLowerCase())
              );
            }
          }
          return codeMatch && dataMatch;
        });
        const filteredChildren = obj.children
          .map(child => this.filterObject(child, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine))
          .filter(child => child !== null);
        const codeFilterActive = codeTerms.length > 0;
        const dataFilterActive = dataTerms.length > 0;
        let typeMatchesData = false;
        if (dataFilterActive) {
          if (dataExact) {
            typeMatchesData = dataTerms.some(term =>
              dataCase ? (obj.type === term)
                       : (obj.type.toLowerCase() === term.toLowerCase())
            );
          } else {
            typeMatchesData = dataTerms.some(term =>
              dataCase ? obj.type.includes(term)
                       : obj.type.toLowerCase().includes(term.toLowerCase())
            );
          }
        }
        if (!codeFilterActive && !dataFilterActive) {
          if (!lineMatches && filteredProperties.length === 0 && filteredChildren.length === 0) {
            return null;
          }
          return {
            ...obj,
            properties: filteredProperties,
            children: filteredChildren
          };
        }
        if (codeFilterActive && filteredProperties.length === 0 && filteredChildren.length === 0) {
          return null;
        }
        if (dataFilterActive && !(typeMatchesData || filteredProperties.length > 0 || filteredChildren.length > 0)) {
          return null;
        }
        if (!lineMatches && filteredProperties.length === 0 && filteredChildren.length === 0) {
          return null;
        }
        return {
          ...obj,
          properties: filteredProperties,
          children: filteredChildren
        };
      }
      handleCopy(nodeId) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const node = this.dxfParser.findNodeByIdIterative(activeTab.originalTreeData, nodeId);
        if (!node) { alert("Node not found in original data."); return; }
        const serialized = this.dxfParser.serializeNode(node);
        navigator.clipboard.writeText(serialized).then(() => {
          alert("Copied node to clipboard as valid DXF tags.");
        }, () => {
          alert("Failed to copy to clipboard.");
        });
      }
      handleOpen(nodeId) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        // Find the node in the current (original) tree data.
        const node = this.dxfParser.findNodeByIdIterative(activeTab.originalTreeData, nodeId);
        if (!node) {
          alert("Node not found.");
          return;
        }
        // Create a new tab object that displays only this node.
        const newTab = {
          id: Date.now() + Math.random(),
          name: node.type + (node.handle ? " (" + node.handle + ")" : ""),
          originalTreeData: [node],    // only this node will be shown in the tree
          currentTreeData: [node],
          codeSearchTerms: [],
          dataSearchTerms: [],
          currentSortField: "line",
          currentSortAscending: true,
          minLine: null,
          maxLine: null,
          dataExact: false,
          dataCase: false,
          navigationHistory: [],
          currentHistoryIndex: -1
        };
        this.tabs.push(newTab);
        this.activeTabId = newTab.id;
        this.updateTabUI();
        this.myTreeGrid.setData(newTab.currentTreeData);
      }

      async parseFileStream(file) {
        const reader = file.stream().getReader();
        const decoder = new TextDecoder("ascii");
        let leftover = "";
        const lines = [];
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          const chunkText = decoder.decode(value, { stream: true });
          const text = leftover + chunkText;
          const parts = text.split(/\r?\n/);
          leftover = parts.pop();
          // Use a loop instead of the spread operator to avoid call stack issues:
          for (const part of parts) {
            lines.push(part);
          }
        }
        if (leftover) { lines.push(leftover); }
        const tags = this.dxfParser.parseDxfLines(lines);
        const grouped = this.dxfParser.groupObjectsIterative(tags, 0);
        return grouped.objects;
      }

      handleFiles(files) {
        const useStream = document.getElementById("useStreamCheckbox").checked;
        if (!files || files.length === 0) {
          alert("Please select (or drop) at least one DXF file.");
          return;
        }
        Array.from(files).forEach(file => {
          if (!file.name.toLowerCase().endsWith(".dxf")) {
            alert("Only DXF files are supported. Skipping: " + file.name);
            return;
          }
          if (useStream && file.stream) {
            this.parseFileStream(file)
              .then(objects => {
                const newTab = {
                  id: Date.now() + Math.random(),
                  name: file.name,
                  originalTreeData: objects,
                  currentTreeData: objects,
                  codeSearchTerms: [],
                  dataSearchTerms: [],
                  currentSortField: "line",
                  currentSortAscending: true,
                  minLine: null,
                  maxLine: null,
                  dataExact: false,
                  dataCase: false,
                  navigationHistory: [],
                  currentHistoryIndex: -1
                };
                this.tabs.push(newTab);
                this.activeTabId = newTab.id;
                this.updateTabUI();
                this.myTreeGrid.setData(newTab.currentTreeData);
              })
              .catch(err => {
                console.error("Error during streamed parsing:", err);
                alert("Error during streamed parsing.");
              });
          } else {
            const reader = new FileReader();
            reader.onload = (event) => {
              const text = event.target.result;
              const objects = this.dxfParser.parse(text);
              const newTab = {
                id: Date.now() + Math.random(),
                name: file.name,
                originalTreeData: objects,
                currentTreeData: objects,
                codeSearchTerms: [],
                dataSearchTerms: [],
                currentSortField: "line",
                currentSortAscending: true,
                minLine: null,
                maxLine: null,
                dataExact: false,
                dataCase: false,
                navigationHistory: [],
                currentHistoryIndex: -1
              };
              this.tabs.push(newTab);
              this.activeTabId = newTab.id;
              this.updateTabUI();
              this.myTreeGrid.setData(newTab.currentTreeData);
            };
            reader.readAsText(file, "ascii");
          }
        });
      }
      handleParse() {
        const fileInput = document.getElementById("fileInput");
        this.handleFiles(fileInput.files);
      }
      createTagElement(text, type) {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = text;
        const removeBtn = document.createElement("span");
        removeBtn.className = "remove";
        removeBtn.textContent = "×";
        removeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          const activeTab = this.getActiveTab();
          if (!activeTab) return;
          if (type === "code") {
            activeTab.codeSearchTerms = activeTab.codeSearchTerms.filter(term => term !== text);
            this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
          } else if (type === "data") {
            activeTab.dataSearchTerms = activeTab.dataSearchTerms.filter(term => term !== text);
            this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
          }
          activeTab.currentTreeData = this.filterTree(
            activeTab.originalTreeData,
            activeTab.codeSearchTerms,
            activeTab.dataSearchTerms,
            activeTab.dataExact,
            activeTab.dataCase,
            activeTab.minLine,
            activeTab.maxLine
          );
          this.myTreeGrid.setData(activeTab.currentTreeData);
          this.treeViewContainer.scrollTop = 0;
        });
        tag.appendChild(removeBtn);
        return tag;
      }
      updateTagContainer(containerId, termsArray, type) {
        const container = document.getElementById(containerId);
        Array.from(container.querySelectorAll(".tag")).forEach(tag => tag.remove());
        termsArray.forEach(term => {
          const tagElem = this.createTagElement(term, type);
          container.insertBefore(tagElem, container.querySelector("input"));
        });
      }
      setupTagInput(inputId, type) {
        const input = document.getElementById(inputId);
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === ",") {
            e.preventDefault();
            const text = input.value.trim();
            if (text !== "") {
              const activeTab = this.getActiveTab();
              if (!activeTab) return;
              if (type === "code") {
                if (!activeTab.codeSearchTerms.includes(text)) {
                  activeTab.codeSearchTerms.push(text);
                }
                this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
              } else {
                if (!activeTab.dataSearchTerms.includes(text)) {
                  activeTab.dataSearchTerms.push(text);
                }
                this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
              }
              input.value = "";
              this.updateEffectiveSearchTerms();
            }
          }
        });
        input.addEventListener("blur", () => {
          const text = input.value.trim();
          if (text !== "") {
            const activeTab = this.getActiveTab();
            if (!activeTab) return;
            if (type === "code") {
              if (!activeTab.codeSearchTerms.includes(text)) {
                activeTab.codeSearchTerms.push(text);
              }
              this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
            } else {
              if (!activeTab.dataSearchTerms.includes(text)) {
                activeTab.dataSearchTerms.push(text);
              }
              this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
            }
            input.value = "";
            this.updateEffectiveSearchTerms();
          }
        });
      }
      handleSearch() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const codeInput = document.getElementById("codeSearchInput");
        const dataInput = document.getElementById("dataSearchInput");
        if (codeInput.value.trim() !== "") {
          const text = codeInput.value.trim();
          if (!activeTab.codeSearchTerms.includes(text)) {
            activeTab.codeSearchTerms.push(text);
          }
          this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
          codeInput.value = "";
        }
        if (dataInput.value.trim() !== "") {
          const text = dataInput.value.trim();
          if (!activeTab.dataSearchTerms.includes(text)) {
            activeTab.dataSearchTerms.push(text);
          }
          this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
          dataInput.value = "";
        }
        this.updateEffectiveSearchTerms();
      }
      handleClearSearch() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        activeTab.codeSearchTerms = [];
        activeTab.dataSearchTerms = [];
        activeTab.minLine = null;
        activeTab.maxLine = null;
        this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
        this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
        document.getElementById("codeSearchInput").value = "";
        document.getElementById("dataSearchInput").value = "";
        document.getElementById("dataExactCheckbox").checked = false;
        document.getElementById("dataCaseCheckbox").checked = false;
        document.getElementById("minLineInput").value = "";
        document.getElementById("maxLineInput").value = "";
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          false,
          false,
          null,
          null
        );
        this.myTreeGrid.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      findPathByHandle(nodes, handle) {
        for (const node of nodes) {
          if (node.handle && node.handle.toUpperCase() === handle.toUpperCase()) {
            return [node];
          }
          if (node.children && node.children.length) {
            const subPath = this.findPathByHandle(node.children, handle);
            if (subPath) { return [node, ...subPath]; }
          }
        }
        return null;
      }
      findPathByLine(nodes, targetLine) {
        for (const node of nodes) {
          // First check the node itself
          if (Number(node.line) === Number(targetLine)) {
            return [node];
          }
          // Check if any property has the matching line.
          if (node.properties && node.properties.length) {
            for (const prop of node.properties) {
              if (Number(prop.line) === Number(targetLine)) {
                // Create a pseudo-node for the property.
                // (Make sure the id matches how your flattenTree renders property nodes.)
                const pseudoNode = {
                  id: "prop-" + node.id + "-" + prop.line + "-" + prop.code,
                  line: prop.line,
                  isProperty: true,
                  code: prop.code,
                  data: prop.value
                };
                return [node, pseudoNode];
              }
            }
          }
          // Otherwise, check the children.
          if (node.children && node.children.length) {
            const subPath = this.findPathByLine(node.children, targetLine);
            if (subPath) {
              return [node, ...subPath];
            }
          }
        }
        return null;
      }
      scrollToLineAfterTabOpen(targetLine, attempt = 1) {
        const activeTab = this.getActiveTab();
        const path = this.findPathByLine(activeTab.originalTreeData, targetLine);
        if (!path) {
          // If not found yet, try again a few times.
          if (attempt < 5) {
            setTimeout(() => {
              this.scrollToLineAfterTabOpen(targetLine, attempt + 1);
            }, 200);
          } else {
            console.warn("Could not locate a node with line " + targetLine);
          }
          return;
        }
        // Expand all nodes in the path (ignore the last pseudo node if present).
        // We only need to expand real entity nodes.
        for (let i = 0; i < path.length; i++) {
          if (!path[i].isProperty) {
            path[i].expanded = true;
          }
        }
        // Update the current tree data so that the expanded state takes effect.
        activeTab.currentTreeData = activeTab.originalTreeData;
        this.myTreeGrid.setData(activeTab.currentTreeData);

        // Allow the tree view to re-render, then scroll.
        setTimeout(() => {
          // Use the id of the last node in the path.
          const targetNodeId = path[path.length - 1].id;
          const flatData = this.myTreeGrid.flatData;
          const targetIndex = flatData.findIndex(item => String(item.node.id) === String(targetNodeId));
          if (targetIndex >= 0) {
            this.treeViewContainer.scrollTop = targetIndex * this.myTreeGrid.itemHeight;
            const element = this.treeViewContent.querySelector(`[data-id="${targetNodeId}"]`);
            if (element) {
              element.style.backgroundColor = "yellow";
              setTimeout(() => { element.style.backgroundColor = ""; }, 2000);
            }
          }
        }, 300);
      }
      navigateToHandle(handle, addHistory = true) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const path = this.findPathByHandle(activeTab.originalTreeData, handle);
        if (!path) { alert("Definition not found for handle: " + handle); return; }
        path.forEach(node => node.expanded = true);
        activeTab.currentTreeData = activeTab.originalTreeData;
        this.myTreeGrid.setData(activeTab.currentTreeData);
        setTimeout(() => {
          const targetNodeId = path[path.length - 1].id;
          const flatData = this.myTreeGrid.flatData;
          const targetIndex = flatData.findIndex(item => String(item.node.id) === String(targetNodeId));
          if (targetIndex >= 0) {
            this.treeViewContainer.scrollTop = targetIndex * this.myTreeGrid.itemHeight;
            const element = this.treeViewContent.querySelector(`[data-id="${targetNodeId}"]`);
            if (element) {
              element.style.backgroundColor = "yellow";
              setTimeout(() => { element.style.backgroundColor = ""; }, 2000);
            }
          }
        }, 300);
        if (addHistory) {
          if (activeTab.currentHistoryIndex < activeTab.navigationHistory.length - 1) {
            activeTab.navigationHistory.splice(activeTab.currentHistoryIndex + 1);
          }
          activeTab.navigationHistory.push(handle);
          activeTab.currentHistoryIndex = activeTab.navigationHistory.length - 1;
          this.updateNavHistoryUI();
          this.updateNavButtons();
        }
      }
      handleGoToHandle() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const handleValue = document.getElementById("handleSearchInput").value.trim();
        if (!handleValue) return;
        this.navigateToHandle(handleValue, true);
      }
      handleLinkToHandle(handle) { this.navigateToHandle(handle, true); }
      updateNavHistoryUI() {
        const activeTab = this.getActiveTab();
        const listContainer = document.getElementById("navHistoryList");
        listContainer.innerHTML = "";
        if (!activeTab) return;
        activeTab.navigationHistory.forEach((handle, index) => {
          const span = document.createElement("span");
          span.textContent = handle;
          span.style.cursor = "pointer";
          span.style.marginRight = "8px";
          if (index === activeTab.currentHistoryIndex) {
            span.style.fontWeight = "bold";
            span.style.textDecoration = "underline";
          }
          span.addEventListener("click", () => {
            activeTab.currentHistoryIndex = index;
            this.navigateToHandle(handle, false);
            this.updateNavHistoryUI();
            this.updateNavButtons();
          });
          listContainer.appendChild(span);
        });
      }
      updateNavButtons() {
        const activeTab = this.getActiveTab();
        const backBtn = document.getElementById("backBtn");
        const forwardBtn = document.getElementById("forwardBtn");
        if (!activeTab) { backBtn.disabled = true; forwardBtn.disabled = true; return; }
        backBtn.disabled = activeTab.currentHistoryIndex <= 0;
        forwardBtn.disabled = activeTab.currentHistoryIndex >= activeTab.navigationHistory.length - 1;
      }
      navigateBack() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        if (activeTab.currentHistoryIndex > 0) {
          activeTab.currentHistoryIndex--;
          const handle = activeTab.navigationHistory[activeTab.currentHistoryIndex];
          this.navigateToHandle(handle, false);
          this.updateNavHistoryUI();
          this.updateNavButtons();
        }
      }
      navigateForward() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        if (activeTab.currentHistoryIndex < activeTab.navigationHistory.length - 1) {
          activeTab.currentHistoryIndex++;
          const handle = activeTab.navigationHistory[activeTab.currentHistoryIndex];
          this.navigateToHandle(handle, false);
          this.updateNavHistoryUI();
          this.updateNavButtons();
        }
      }
      clearNavigationHistory() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        activeTab.navigationHistory = [];
        activeTab.currentHistoryIndex = -1;
        this.updateNavHistoryUI();
        this.updateNavButtons();
      }
      updateClouds() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayObjectCloud").innerHTML = "";
          document.getElementById("overlayCodeCloud").innerHTML = "";
          return;
        }
        const objectCounts = {};
        const codeCounts = {};
        function traverse(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty) {
              objectCounts[node.type] = (objectCounts[node.type] || 0) + 1;
              node.properties.forEach(prop => {
                codeCounts[prop.code] = (codeCounts[prop.code] || 0) + 1;
              });
              if (node.children && node.children.length > 0) { traverse(node.children); }
            }
          });
        }
        traverse(activeTab.originalTreeData);
        const populateCloud = (element, counts, minFont, maxFont, cloudType) => {
          element.innerHTML = "";
          const maxCount = Math.max(...Object.values(counts), 1);
          for (const key in counts) {
            const count = counts[key];
            const fontSize = minFont + ((count / maxCount) * (maxFont - minFont));
            const span = document.createElement("span");
            span.className = "cloud-tag";
            span.style.fontSize = fontSize + "px";
            span.textContent = `${key} (${count})`;
            span.style.cursor = "pointer";
            span.addEventListener("click", () => {
              document.getElementById("cloudOverlay").style.display = "none";
              this.handleCloudTagClick(cloudType, key);
            });
            element.appendChild(span);
          }
        };
        const minFont = 12, maxFont = 36;
        const overlayObjectCloudElem = document.getElementById("overlayObjectCloud");
        const overlayCodeCloudElem = document.getElementById("overlayCodeCloud");
        populateCloud(overlayObjectCloudElem, objectCounts, minFont, maxFont, "object");
        populateCloud(overlayCodeCloudElem, codeCounts, minFont, maxFont, "code");
      }
      handleCloudTagClick(cloudType, key) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        if (cloudType === "object") {
          function search(nodes) {
            for (const node of nodes) {
              if (node.type && node.type.toLowerCase().includes(key.toLowerCase())) {
                return node;
              }
              if (node.children && node.children.length) {
                const result = search(node.children);
                if (result) return result;
              }
            }
            return null;
          }
          const found = search(activeTab.originalTreeData);
          if (found && found.handle) {
            this.handleLinkToHandle(found.handle);
          } else {
            alert("No matching object found for type: " + key);
          }
        } else if (cloudType === "code") {
          function search(nodes) {
            for (const node of nodes) {
              if (node.properties && node.properties.length) {
                for (const prop of node.properties) {
                  if (String(prop.code) === key) {
                    return node;
                  }
                }
              }
              if (node.children && node.children.length) {
                const result = search(node.children);
                if (result) return result;
              }
            }
            return null;
          }
          const found = search(activeTab.originalTreeData);
          if (found && found.handle) {
            this.handleLinkToHandle(found.handle);
          } else {
            alert("No matching object found for code: " + key);
          }
        }
      }
      updateStats() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayStatsContent").innerHTML = "No DXF data loaded.";
          return;
        }
        function computeStats(nodes, depth = 1) {
          let stats = {
            totalObjects: 0,
            totalProperties: 0,
            maxDepth: depth,
            totalDataSize: 0,
            countByType: {}
          };
          nodes.forEach(node => {
            if (!node.isProperty) {
              stats.totalObjects++;
              stats.countByType[node.type] = (stats.countByType[node.type] || 0) + 1;
              let nodeDataSize = node.type ? node.type.length : 0;
              if (node.properties && node.properties.length) {
                stats.totalProperties += node.properties.length;
                node.properties.forEach(prop => { nodeDataSize += prop.value ? prop.value.length : 0; });
              }
              stats.totalDataSize += nodeDataSize;
              if (node.children && node.children.length) {
                const childStats = computeStats(node.children, depth + 1);
                stats.totalObjects += childStats.totalObjects;
                stats.totalProperties += childStats.totalProperties;
                stats.totalDataSize += childStats.totalDataSize;
                for (let type in childStats.countByType) {
                  stats.countByType[type] = (stats.countByType[type] || 0) + childStats.countByType[type];
                }
                if (childStats.maxDepth > stats.maxDepth) { stats.maxDepth = childStats.maxDepth; }
              }
            }
          });
          return stats;
        }
        const stats = computeStats(activeTab.originalTreeData);
        const avgProps = stats.totalObjects > 0 ? (stats.totalProperties / stats.totalObjects).toFixed(2) : 0;
        const statsHtml = `
          <ul>
            <li><strong>Total Objects:</strong> ${stats.totalObjects}</li>
            <li><strong>Total Properties:</strong> ${stats.totalProperties}</li>
            <li><strong>Maximum Nesting Depth:</strong> ${stats.maxDepth}</li>
            <li><strong>Total Data Size:</strong> ${stats.totalDataSize} characters</li>
            <li><strong>Average Properties per Object:</strong> ${avgProps}</li>
            <li><strong>Object Type Counts:</strong>
              <ul>
                ${Object.entries(stats.countByType)
                  .map(([type, count]) => `<li><a href="#" class="stats-type" data-type="${type}">${type}: ${count}</a></li>`)
                  .join('')}
              </ul>
            </li>
          </ul>
        `;
        document.getElementById("overlayStatsContent").innerHTML = statsHtml;
        document.querySelectorAll(".stats-type").forEach(link => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            const type = link.getAttribute("data-type");
            document.getElementById("statsOverlay").style.display = "none";
            this.handleCloudTagClick("object", type);
          });
        });
      }
      updateDependencies() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayDepsContent").innerHTML = "No DXF data loaded.";
          return;
        }
        const dependencyTypes = ["LTYPE", "STYLE", "APPID", "LAYER", "DIMSTYLE", "VPORT", "XREF", "SHAPE"];
        const dependencies = {};
        dependencyTypes.forEach(type => dependencies[type] = []);
        function traverse(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty) {
              const type = node.type.toUpperCase();
              if (dependencyTypes.includes(type)) { dependencies[type].push(node); }
              if (node.children && node.children.length) { traverse(node.children); }
            }
          });
        }
        traverse(activeTab.originalTreeData);
        let html = "";
        dependencyTypes.forEach(depType => {
          if (dependencies[depType].length > 0) {
            html += `<h3>${depType} (${dependencies[depType].length})</h3><ul>`;
            dependencies[depType].forEach(dep => {
              let depInfo = `${dep.type} (Line ${dep.line})`;
              if (dep.properties && dep.properties.length) {
                const propSummary = dep.properties.map(p => `${p.code}:${p.value}`).join(", ");
                depInfo += ` [${propSummary}]`;
              }
              if (dep.handle) {
                html += `<li><a href="#" class="dep-link" data-handle="${dep.handle}">${depInfo}</a></li>`;
              } else {
                html += `<li>${depInfo}</li>`;
              }
            });
            html += "</ul>";
          }
        });
        if (!html) { html = "No external dependency objects found."; }
        document.getElementById("overlayDepsContent").innerHTML = html;
        const self = this;
        document.querySelectorAll(".dep-link").forEach(link => {
          link.addEventListener("click", function(e) {
            e.preventDefault();
            document.getElementById("depsOverlay").style.display = "none";
            const handle = this.getAttribute("data-handle");
            self.handleLinkToHandle(handle);
          });
        });
      }
      renderHexLine(lineNumber, binaryArray) {
  const bytesPerLine = 16;
  const offset = lineNumber * bytesPerLine;
  const lineBytes = binaryArray.slice(offset, offset + bytesPerLine);
  let hex = '';
  let ascii = '';
  for (let i = 0; i < lineBytes.length; i++) {
    const byte = lineBytes[i];
    // Convert the byte to a two-digit hexadecimal value.
    hex += byte.toString(16).padStart(2, '0') + ' ';
    // Build the ASCII representation.
    ascii += (byte >= 32 && byte < 127) ? String.fromCharCode(byte) : '.';
  }
  // Pad the hex section if the last line is shorter than bytesPerLine.
  hex = hex.padEnd(bytesPerLine * 3, ' ');
  // Return a string that shows the offset, the hex values, and the ASCII characters.
  return offset.toString(16).padStart(8, '0') + '  ' + hex + '  ' + ascii;
}
      virtualizeHexViewer(binaryArray) {
        const container = document.getElementById("hexContent");

        // Check that we have data to display.
        if (!binaryArray || binaryArray.length === 0) {
          container.textContent = "No data to display.";
          return;
        }

        // Measure one hex line’s height (only once).
        if (!this.hexLineHeight) {
          const tempDiv = document.createElement("div");
          tempDiv.style.position = "absolute";
          tempDiv.style.visibility = "hidden";
          tempDiv.style.whiteSpace = "pre";
          tempDiv.textContent = this.renderHexLine(0, binaryArray);
          container.appendChild(tempDiv);
          this.hexLineHeight = tempDiv.offsetHeight || 18; // Fallback if measurement fails.
          container.removeChild(tempDiv);

        }
        const lineHeight = this.hexLineHeight;
        const bytesPerLine = 16;
        const totalLines = Math.ceil(binaryArray.length / bytesPerLine);

        // This function renders only the visible lines.
        const updateView = () => {
          const scrollTop = container.scrollTop;
          const containerHeight = container.clientHeight;
          const startLine = Math.floor(scrollTop / lineHeight);
          const visibleLines = Math.ceil(containerHeight / lineHeight) + 1;
          const endLine = Math.min(startLine + visibleLines, totalLines);

          // Create an outer div with the full height of all lines.
          const contentDiv = document.createElement("div");
          contentDiv.style.position = "relative";
          contentDiv.style.height = (totalLines * lineHeight) + "px";

          // Create an inner container positioned at the correct offset.
          const visibleContainer = document.createElement("div");
          visibleContainer.style.position = "absolute";
          visibleContainer.style.top = (startLine * lineHeight) + "px";
          visibleContainer.style.left = "0";
          visibleContainer.style.right = "0";
          visibleContainer.style.whiteSpace = "pre"; // Preserve formatting

          // Render each visible line.
          for (let i = startLine; i < endLine; i++) {
            const lineDiv = document.createElement("div");
            lineDiv.style.height = lineHeight + "px";
            lineDiv.textContent = this.renderHexLine(i, binaryArray);
            visibleContainer.appendChild(lineDiv);
          }

          contentDiv.appendChild(visibleContainer);
          container.innerHTML = "";
          container.appendChild(contentDiv);
        };

        // Attach the scroll event.
        container.onscroll = updateView;
        // Render the initial view.
        updateView();
      }
      showHexViewer(combinedHexString) {
        const binaryArray = hexStringToByteArray(combinedHexString);
        const detectedType = detectHeader(binaryArray);
        document.getElementById("headerInfo").textContent =
          detectedType ? "Detected file type: " + detectedType : "Unknown file type";
        this.currentBinaryData = binaryArray;
        this.currentDetectedType = detectedType;
        document.getElementById("hexViewerOverlay").style.display = "block";

        // Use virtualization instead of rendering the full dump at once.
        this.virtualizeHexViewer(binaryArray);

        // (Optional) Continue handling ZIP/image previews as before.
        if (detectedType === "ZIP Archive") {
          document.getElementById("imagePreviewContainer").innerHTML = "";
          this.browseZip(binaryArray);
        } else if (detectedType === "PNG Image" || detectedType === "GIF Image" ||
                   detectedType === "JPEG Image" || detectedType === "BMP Image") {
          this.previewImage();
          document.getElementById("zipContentsContainer").innerHTML = "";
        } else {
          document.getElementById("imagePreviewContainer").innerHTML = "";
          document.getElementById("zipContentsContainer").innerHTML = "";
        }
      }
      previewImage() {
        if (!this.currentBinaryData) { alert("No binary data available."); return; }
        const imageTypes = {
          "PNG Image": "image/png",
          "GIF Image": "image/gif",
          "JPEG Image": "image/jpeg",
          "BMP Image": "image/bmp"
        };
        if (!this.currentDetectedType || !imageTypes[this.currentDetectedType]) {
          alert("Preview not available for this file type.");
          return;
        }
        const mimeType = imageTypes[this.currentDetectedType];
        const blob = new Blob([this.currentBinaryData], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const container = document.getElementById("imagePreviewContainer");
        container.innerHTML = "";
        const img = document.createElement("img");
        img.src = url;
        img.style.maxWidth = "100%";
        img.style.maxHeight = "300px";
        container.appendChild(img);
      }
      browseZip(binaryArray) {
        const blob = new Blob([binaryArray], { type: "application/zip" });
        JSZip.loadAsync(blob).then(zip => {
          const container = document.getElementById("zipContentsContainer");
          container.innerHTML = "<h3>ZIP Contents</h3>";
          Object.keys(zip.files).forEach(filename => {
            const file = zip.files[filename];
            const fileDiv = document.createElement("div");
            fileDiv.style.borderBottom = "1px solid #ccc";
            fileDiv.style.padding = "5px";
            fileDiv.innerHTML = `<strong>${filename}</strong> (${file._data.uncompressedSize || 0} bytes) `;
            if (!file.dir) {
              const previewBtn = document.createElement("button");
              previewBtn.textContent = "Preview";
              previewBtn.addEventListener("click", () => {
                const lowerName = filename.toLowerCase();
                if (lowerName.endsWith(".png") || lowerName.endsWith(".jpg") ||
                    lowerName.endsWith(".jpeg") || lowerName.endsWith(".gif") ||
                    lowerName.endsWith(".bmp")) {
                  file.async("base64").then(content => {
                    const img = document.createElement("img");
                    let mimeType = "image/png";
                    if(lowerName.endsWith(".jpg") || lowerName.endsWith(".jpeg")) mimeType = "image/jpeg";
                    else if(lowerName.endsWith(".gif")) mimeType = "image/gif";
                    else if(lowerName.endsWith(".bmp")) mimeType = "image/bmp";
                    img.src = `data:${mimeType};base64,${content}`;
                    const previewContainer = document.createElement("div");
                    previewContainer.style.marginTop = "10px";
                    previewContainer.appendChild(img);
                    fileDiv.appendChild(previewContainer);
                  });
                } else {
                  file.async("string").then(content => {
                    const pre = document.createElement("pre");
                    pre.textContent = content;
                    pre.style.maxHeight = "200px";
                    pre.style.overflow = "auto";
                    fileDiv.appendChild(pre);
                  });
                }
              });
              fileDiv.appendChild(previewBtn);
              const downloadBtn = document.createElement("button");
              downloadBtn.textContent = "Download";
              downloadBtn.addEventListener("click", () => {
                file.async("blob").then(blobContent => {
                  const url = URL.createObjectURL(blobContent);
                  const a = document.createElement("a");
                  a.href = url;
                  a.download = filename;
                  document.body.appendChild(a);
                  a.click();
                  document.body.removeChild(a);
                  URL.revokeObjectURL(url);
                });
              });
              fileDiv.appendChild(downloadBtn);
            }
            container.appendChild(fileDiv);
          });
        }).catch(err => {
          alert("Failed to load ZIP file: " + err);
        });
      }
      updateHandleMap() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayHandleMapContent").innerHTML = "No DXF data loaded.";
          return;
        }
        const nodesByHandle = {};
        function traverse(nodes) {
          nodes.forEach(node => {
            if (node.handle) {
              nodesByHandle[node.handle] = { handle: node.handle, type: node.type, line: node.line, children: [] };
            }
            if (node.children && node.children.length > 0) { traverse(node.children); }
          });
        }
        traverse(activeTab.originalTreeData);
        const roots = [];
        function assignOwner(nodes) {
          nodes.forEach(node => {
            const current = node.handle ? nodesByHandle[node.handle] : null;
            const ownerProp = node.properties.find(prop => Number(prop.code) === 330);
            if (ownerProp && ownerProp.value && nodesByHandle[ownerProp.value]) {
              const parent = nodesByHandle[ownerProp.value];
              if (current) { parent.children.push(current); }
            } else {
              if (current) { roots.push(current); }
            }
            if (node.children && node.children.length > 0) { assignOwner(node.children); }
          });
        }
        assignOwner(activeTab.originalTreeData);
        const uniqueRoots = Array.from(new Set(roots));
        function buildList(items) {
          const ul = document.createElement("ul");
          items.forEach(item => {
            const li = document.createElement("li");
            if (item.handle) {
              const a = document.createElement("a");
              a.href = "#";
              a.textContent = `Handle: ${item.handle} | Type: ${item.type} | Line: ${item.line}`;
              a.addEventListener("click", (e) => {
                e.preventDefault();
                document.getElementById("handleMapOverlay").style.display = "none";
                this.handleLinkToHandle(item.handle);
              });
              li.appendChild(a);
            } else {
              li.textContent = `Type: ${item.type} | Line: ${item.line}`;
            }
            if (item.children && item.children.length > 0) {
              li.appendChild(buildList.call(this, item.children));
            }
            ul.appendChild(li);
          });
          return ul;
        }
        const container = document.getElementById("overlayHandleMapContent");
        container.innerHTML = "";
        if (uniqueRoots.length === 0) {
          container.textContent = "No owner relationships (code 330) found.";
        } else {
          container.appendChild(buildList.call(this, uniqueRoots));
        }
      }
      showBinaryObjectsOverlay() {
        const activeTab = this.getActiveTab();
        const listContainer = document.getElementById("binaryObjectsList");
        listContainer.innerHTML = "";
        if (!activeTab) {
          listContainer.textContent = "No DXF data loaded.";
          document.getElementById("binaryObjectsOverlay").style.display = "block";
          return;
        }
        let binaryNodes = [];
        function findBinaryNodes(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty && node.properties) {
              const binaryProps = node.properties.filter(prop => Number(prop.code) === 310);
              if (binaryProps.length > 0) { binaryNodes.push(node); }
            }
            if (node.children && node.children.length > 0) { findBinaryNodes(node.children); }
          });
        }
        findBinaryNodes(activeTab.originalTreeData);
        if (binaryNodes.length === 0) {
          listContainer.textContent = "No binary data objects found.";
        } else {
          binaryNodes.forEach(node => {
            const div = document.createElement("div");
            div.style.borderBottom = "1px solid #ccc";
            div.style.padding = "5px";
            let info = `Type: ${node.type} | Line: ${node.line}`;
            if (node.handle) { info += ` | Handle: ${node.handle}`; }
            const infoSpan = document.createElement("span");
            infoSpan.textContent = info + " ";
            div.appendChild(infoSpan);
            const binaryProps = node.properties.filter(prop => Number(prop.code) === 310);
            const combinedData = binaryProps.map(prop => prop.value).join("");
            const hexBtn = document.createElement("button");
            hexBtn.textContent = "Hex Viewer";
            hexBtn.addEventListener("click", () => { this.showHexViewer(combinedData); });
            div.appendChild(hexBtn);
            if (node.handle) {
              const showLink = document.createElement("a");
              showLink.href = "#";
              showLink.textContent = "Show in Tree";
              showLink.style.marginLeft = "10px";
              showLink.addEventListener("click", (e) => {
                e.preventDefault();
                document.getElementById("binaryObjectsOverlay").style.display = "none";
                this.handleLinkToHandle(node.handle);
              });
              div.appendChild(showLink);
            }
            listContainer.appendChild(div);
          });
        }
        document.getElementById("binaryObjectsOverlay").style.display = "block";
      }
      analyzeProxyObject(node) {
        let html = `<h3>Proxy Object Analysis</h3>`;
        html += `<p><strong>Total Properties:</strong> ${node.properties.length}. `;
        html += `<strong>Total Child Objects:</strong> ${node.children ? node.children.length : 0}.</p>`;
        html += `<table border="1" cellspacing="0" cellpadding="4" style="border-collapse: collapse; width: 100%;">`;
        html += `<tr><th>DXF Code</th><th>Value</th></tr>`;
        node.properties.forEach(prop => {
          if (Number(prop.code) === 330) {
            html += `<tr><td>${prop.code}</td><td><a href="#" onclick="window.app.handleLinkToHandle('${prop.value}'); return false;">${prop.value}</a></td></tr>`;
          } else if (Number(prop.code) === 310) {
            html += `<tr><td>${prop.code}</td><td>Binary Data (length: ${prop.value.length})</td></tr>`;
          } else {
            html += `<tr><td>${prop.code}</td><td>${prop.value}</td></tr>`;
          }
        });
        html += `</table>`;
        const binaryProps = node.properties.filter(p => Number(p.code) === 310);
        if (binaryProps.length > 0) {
          const combinedData = binaryProps.map(p => p.value).join("");
          html += `<p><strong>Combined Binary Data:</strong> ${combinedData.length} characters. <a href="#" onclick="window.app.showHexViewer('${combinedData}'); return false;">View Hex</a></p>`;
        }
        if (node.children && node.children.length > 0) {
          html += `<h4>Child Objects:</h4>`;
          html += `<ul>`;
          node.children.forEach(child => {
            html += `<li>`;
            html += `Type: ${child.type} (Line: ${child.line}`;
            if (child.handle) {
              html += `, Handle: <a href="#" onclick="window.app.handleLinkToHandle('${child.handle}'); return false;">${child.handle}</a>`;
            }
            html += `)`;
            html += window.app.analyzeProxyObject(child);
            html += `</li>`;
          });
          html += `</ul>`;
        }
        return html;
      }
      showProxyObjectsOverlay() {
        const activeTab = this.getActiveTab();
        const listContainer = document.getElementById("proxyObjectsList");
        listContainer.innerHTML = "";
        if (!activeTab) {
          listContainer.textContent = "No DXF data loaded.";
          document.getElementById("proxyObjectsOverlay").style.display = "block";
          return;
        }
        let proxyNodes = [];
        function findProxyNodes(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty && node.type && node.type.toUpperCase() === "ACAD_PROXY_OBJECT") {
              proxyNodes.push(node);
            }
            if (node.children && node.children.length > 0) { findProxyNodes(node.children); }
          });
        }
        findProxyNodes(activeTab.originalTreeData);
        if (proxyNodes.length === 0) {
          listContainer.textContent = "No proxy objects found.";
        } else {
          proxyNodes.forEach(node => {
            const div = document.createElement("div");
            div.style.borderBottom = "1px solid #ccc";
            div.style.padding = "5px";
            let info = `Type: ${node.type} | Line: ${node.line}`;
            if (node.handle) { info += ` | Handle: ${node.handle}`; }
            const infoSpan = document.createElement("span");
            infoSpan.textContent = info + " ";
            div.appendChild(infoSpan);
            const copyBtn = document.createElement("button");
            copyBtn.textContent = "Copy DXF";
            copyBtn.addEventListener("click", () => {
              const serialized = this.dxfParser.serializeNode(node);
              navigator.clipboard.writeText(serialized).then(() => {
                alert("Copied proxy object to clipboard as valid DXF tags.");
              }, () => {
                alert("Failed to copy to clipboard.");
              });
            });
            div.appendChild(copyBtn);
            const detailsBtn = document.createElement("button");
            detailsBtn.textContent = "Show Details";
            const detailsDiv = document.createElement("pre");
            detailsDiv.style.display = "none";
            detailsDiv.style.background = "#f9f9f9";
            detailsDiv.style.padding = "5px";
            detailsDiv.textContent = this.dxfParser.serializeNode(node);
            detailsBtn.addEventListener("click", () => {
              if (detailsDiv.style.display === "none") {
                detailsDiv.style.display = "block";
                detailsBtn.textContent = "Hide Details";
              } else {
                detailsDiv.style.display = "none";
                detailsBtn.textContent = "Show Details";
              }
            });
            div.appendChild(detailsBtn);
            div.appendChild(detailsDiv);
            const analyzeBtn = document.createElement("button");
            analyzeBtn.textContent = "Analyze";
            const analyzeDiv = document.createElement("div");
            analyzeDiv.style.display = "none";
            analyzeDiv.style.background = "#eef";
            analyzeDiv.style.padding = "5px";
            analyzeBtn.addEventListener("click", () => {
              if (analyzeDiv.style.display === "none") {
                analyzeDiv.innerHTML = window.app.analyzeProxyObject(node);
                analyzeDiv.style.display = "block";
                analyzeBtn.textContent = "Hide Analysis";
              } else {
                analyzeDiv.style.display = "none";
                analyzeBtn.textContent = "Analyze";
              }
            });
            div.appendChild(analyzeBtn);
            div.appendChild(analyzeDiv);
            if (node.handle) {
              const showLink = document.createElement("a");
              showLink.href = "#";
              showLink.textContent = "Show in Tree";
              showLink.style.marginLeft = "10px";
              showLink.addEventListener("click", (e) => {
                e.preventDefault();
                document.getElementById("proxyObjectsOverlay").style.display = "none";
                this.handleLinkToHandle(node.handle);
              });
              div.appendChild(showLink);
            }
            listContainer.appendChild(div);
          });
        }
        document.getElementById("proxyObjectsOverlay").style.display = "block";
      }
      updateFonts() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayFontsContent").innerHTML = "<p>No DXF data loaded.</p>";
          return;
        }
        // Create a mapping: font identifier => array of reference objects { desc, handle }
        let fonts = {};
        function traverse(node) {
          // For STYLE entities, check for a font file (group code 3) and style name (group code 2)
          if (node.type.toUpperCase() === "STYLE") {
            let styleName = "";
            let fontFile = "";
            node.properties.forEach(prop => {
              if (prop.code == 2) { styleName = prop.value; }
              if (prop.code == 3) { fontFile = prop.value; }
            });
            if (fontFile) {
              if (!fonts[fontFile]) {
                fonts[fontFile] = [];
              }
              fonts[fontFile].push({
                desc: `STYLE: ${styleName} (Line: ${node.line}${node.handle ? ", Handle: " + node.handle : ""})`,
                handle: node.handle
              });
            }
          }
          // For TEXT or MTEXT entities, check for text style (group code 7)
          if (node.type.toUpperCase() === "TEXT" || node.type.toUpperCase() === "MTEXT") {
            let textStyle = "";
            node.properties.forEach(prop => {
              if (prop.code == 7) { textStyle = prop.value; }
            });
            if (textStyle) {
              if (!fonts[textStyle]) {
                fonts[textStyle] = [];
              }
              fonts[textStyle].push({
                desc: `${node.type} (Line: ${node.line}${node.handle ? ", Handle: " + node.handle : ""})`,
                handle: node.handle
              });
            }
          }
          // Recurse through children
          if (node.children && node.children.length > 0) {
            node.children.forEach(child => traverse(child));
          }
        }
        activeTab.originalTreeData.forEach(node => traverse(node));
  
        // Build the HTML list from the fonts mapping.
        let html = "";
        if (Object.keys(fonts).length === 0) {
          html = "<p>No fonts found in the DXF data.</p>";
        } else {
          html = "<ul>";
          for (let font in fonts) {
            html += `<li><strong>${font}</strong><ul>`;
            fonts[font].forEach(entry => {
              html += `<li>${entry.desc}`;
              if (entry.handle) {
                html += ` <a href="#" onclick="window.app.handleLinkToHandle('${entry.handle}'); document.getElementById('fontsOverlay').style.display = 'none'; return false;">Show in Tree</a>`;
              }
              html += `</li>`;
            });
            html += "</ul></li>";
          }
          html += "</ul>";
        }
        document.getElementById("overlayFontsContent").innerHTML = html;
      }
      updateClasses() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayClassesContent").innerHTML =
            "<p>No DXF data loaded.</p>";
          return;
        }

        // Traverse the original tree data to collect CLASS nodes.
        let classes = [];
        function traverse(node) {
          if (!node.isProperty && node.type && node.type.toUpperCase() === "CLASS") {
            classes.push(node);
          }
          if (node.children && node.children.length > 0) {
            node.children.forEach(child => traverse(child));
          }
        }
        activeTab.originalTreeData.forEach(node => traverse(node));

        let html = "";

        // Build a cloud of Application Names (group code 3) styled like the Code and Data clouds.
        let appNameCounts = {};
        classes.forEach(cls => {
          let appName = "";
          if (cls.properties && cls.properties.length) {
            cls.properties.forEach(prop => {
              if (Number(prop.code) === 3) {
                appName = prop.value;
              }
            });
          }
          if (appName) {
            appNameCounts[appName] = (appNameCounts[appName] || 0) + 1;
          }
        });

        if (Object.keys(appNameCounts).length > 0) {
          // Determine the maximum count to scale the font sizes.
          let maxCount = Math.max(...Object.values(appNameCounts));
          html += `<div class="app-cloud" style="padding:8px; margin:8px; border:1px dashed #aaa;">
                     <h4>Application Name Cloud</h4>`;
          for (let app in appNameCounts) {
            let count = appNameCounts[app];
            // Compute font size between 12 and 24 pixels.
            let fontSize = 12 + ((count / maxCount) * 12);
            html += `<span class="cloud-tag" style="font-size:${fontSize}px; cursor:pointer;"
                            onclick="window.app.filterClassesByAppName('${app.replace(/'/g, "\\'")}')">
                            ${app} (${count})
                     </span>`;
          }
          html += `</div>`;
        }

        // If no CLASS nodes were found, show a message.
        if (classes.length === 0) {
          html += "<p>No classes found in the DXF data.</p>";
        } else {
          classes.forEach(cls => {
            // Extract key properties from each CLASS node.
            let recordName = "", cppClass = "", appName = "";
            if (cls.properties && cls.properties.length) {
              cls.properties.forEach(prop => {
                switch (Number(prop.code)) {
                  case 1:
                    recordName = prop.value;
                    break;
                  case 2:
                    cppClass = prop.value;
                    break;
                  case 3:
                    appName = prop.value;
                    break;
                  default:
                    break;
                }
              });
            }
            html += `<div class="class-record" style="border:1px solid #ddd; border-radius:4px; margin:8px; padding:8px;">
                      <h3 style="margin-top:0;">${recordName || "Unnamed Class"}</h3>
                      <p><strong>C++ Class:</strong> ${cppClass || "N/A"}</p>
                      <p><strong>Application Name:</strong> ${appName || "N/A"}</p>`;
            if (cls.handle) {
              html += `<p><a class="show-in-tree" href="#"
                              onclick="window.app.handleLinkToHandle('${cls.handle}'); 
                                       document.getElementById('classesOverlay').style.display='none'; return false;">
                              Show in Tree</a></p>`;
            }
            // Toggle button to show/hide the serialized details.
            html += `<button class="toggle-details" style="margin-bottom:8px;" 
                            onclick="var details=this.nextElementSibling; 
                                     if(details.style.display==='none'){ details.style.display='block'; this.textContent='Hide Details'; } 
                                     else { details.style.display='none'; this.textContent='Show Details'; }">
                            Show Details</button>
                     <pre class="class-details" style="display:none; background:#f8f8f8; border:1px solid #eee; padding:8px; overflow:auto;">
      ${window.app.dxfParser.serializeNode(cls)}</pre>
                    </div>`;
          });
        }
        document.getElementById("overlayClassesContent").innerHTML = html;
      }
      filterClassesByAppName(appName) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;

        // Traverse CLASS nodes and select those whose Application Name matches.
        let filteredClasses = [];
        function traverse(node) {
          if (!node.isProperty && node.type && node.type.toUpperCase() === "CLASS") {
            let foundApp = "";
            if (node.properties && node.properties.length) {
              node.properties.forEach(prop => {
                if (Number(prop.code) === 3) {
                  foundApp = prop.value;
                }
              });
            }
            if (foundApp === appName) {
              filteredClasses.push(node);
            }
          }
          if (node.children && node.children.length > 0) {
            node.children.forEach(child => traverse(child));
          }
        }
        activeTab.originalTreeData.forEach(node => traverse(node));

        let html = `<h4>Classes with Application Name: ${appName}</h4>`;
        if (filteredClasses.length === 0) {
          html += `<p>No classes found with this Application Name.</p>`;
        } else {
          filteredClasses.forEach(cls => {
            let recordName = "", cppClass = "", appNameVal = "";
            if (cls.properties && cls.properties.length) {
              cls.properties.forEach(prop => {
                switch (Number(prop.code)) {
                  case 1:
                    recordName = prop.value;
                    break;
                  case 2:
                    cppClass = prop.value;
                    break;
                  case 3:
                    appNameVal = prop.value;
                    break;
                  default:
                    break;
                }
              });
            }
            html += `<div class="class-record" style="border:1px solid #ddd; border-radius:4px; margin:8px; padding:8px;">
                      <h3 style="margin-top:0;">${recordName || "Unnamed Class"}</h3>
                      <p><strong>C++ Class:</strong> ${cppClass || "N/A"}</p>
                      <p><strong>Application Name:</strong> ${appNameVal || "N/A"}</p>`;
            if (cls.handle) {
              html += `<p><a class="show-in-tree" href="#"
                              onclick="window.app.handleLinkToHandle('${cls.handle}'); 
                                       document.getElementById('classesOverlay').style.display='none'; return false;">
                              Show in Tree</a></p>`;
            }
            html += `<button class="toggle-details" style="margin-bottom:8px;" 
                            onclick="var details=this.nextElementSibling; 
                                     if(details.style.display==='none'){ details.style.display='block'; this.textContent='Hide Details'; } 
                                     else { details.style.display='none'; this.textContent='Show Details'; }">
                            Show Details</button>
                     <pre class="class-details" style="display:none; background:#f8f8f8; border:1px solid #eee; padding:8px; overflow:auto;">
      ${window.app.dxfParser.serializeNode(cls)}</pre>
                    </div>`;
          });
        }
        // Provide a back button to return to the full view.
        html += `<button onclick="window.app.updateClasses();" style="margin:8px;">Show All Classes</button>`;
        document.getElementById("overlayClassesContent").innerHTML = html;
      }
      showObjectSizeDialog() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          alert("No DXF data loaded.");
          return;
        }
        // Collect all non‑property objects from the original tree.
        const nodes = [];
        function collectNodes(nodelist) {
          nodelist.forEach(node => {
            if (!node.isProperty) {
              nodes.push(node);
            }
            if (node.children && node.children.length > 0) {
              collectNodes(node.children);
            }
          });
        }
        collectNodes(activeTab.originalTreeData);
        // Sort by data size (largest first). (Uses the same computeDataSize method from the TreeDataGrid.)
        nodes.sort((a, b) => {
          return this.myTreeGrid.computeDataSize(b) - this.myTreeGrid.computeDataSize(a);
        });
        // Save sorted nodes so the virtualized renderer can use them.
        this.sortedNodesByDataSize = nodes;
        // Open the overlay and render the list.
        document.getElementById("objectSizeOverlay").style.display = "block";
        this.renderObjectSizeList();
      }
      renderObjectSizeList() {
        const container = document.getElementById("objectSizeList");
        const nodes = this.sortedNodesByDataSize || [];
        const rowHeight = 30; // fixed row height for each item
        const totalRows = nodes.length;
        container.innerHTML = ""; // clear previous content

        // Create an outer container with the full height
        const outerDiv = document.createElement("div");
        outerDiv.style.position = "relative";
        outerDiv.style.height = (totalRows * rowHeight) + "px";
        container.appendChild(outerDiv);

        // Function to render only the visible rows.
        const updateView = () => {
          const scrollTop = container.scrollTop;
          const containerHeight = container.clientHeight;
          const startIndex = Math.floor(scrollTop / rowHeight);
          const visibleCount = Math.ceil(containerHeight / rowHeight) + 1;
          const endIndex = Math.min(startIndex + visibleCount, totalRows);

          // Use an inner container for visible rows.
          let visibleContainer = outerDiv.querySelector(".visible-container");
          if (!visibleContainer) {
            visibleContainer = document.createElement("div");
            visibleContainer.className = "visible-container";
            visibleContainer.style.position = "absolute";
            visibleContainer.style.left = "0";
            visibleContainer.style.right = "0";
            outerDiv.appendChild(visibleContainer);
          }
          visibleContainer.style.top = (startIndex * rowHeight) + "px";
          visibleContainer.innerHTML = ""; // clear current content

          // Render each visible row.
          for (let i = startIndex; i < endIndex; i++) {
            const node = nodes[i];
            const row = document.createElement("div");
            row.style.height = rowHeight + "px";
            row.style.display = "flex";
            row.style.alignItems = "center";
            row.style.borderBottom = "1px solid #ccc";
            row.style.padding = "0 8px";

            // Object tag (e.g. BLOCK, LINE, SECTION etc.)
            const typeSpan = document.createElement("span");
            typeSpan.textContent = node.type || "";
            typeSpan.style.flex = "1";

            // Data size (computed via computeDataSize)
            const dataSizeSpan = document.createElement("span");
            dataSizeSpan.textContent = this.myTreeGrid.computeDataSize(node);
            dataSizeSpan.style.width = "80px";
            dataSizeSpan.style.textAlign = "right";
            dataSizeSpan.style.marginRight = "8px";

            // "Show In Tree" button
            const showButton = document.createElement("button");
            showButton.textContent = "Show In Tree";
            showButton.addEventListener("click", () => {
              // Close the Object Size dialog.
              document.getElementById("objectSizeOverlay").style.display = "none";

              if (node.handle) {
                // Navigate using the handle if available.
                this.handleLinkToHandle(node.handle);
              } else {
                // Use the starting line number to locate the item.
                const targetLine = node.line;
                const flatData = this.myTreeGrid.flatData;
                const targetItem = flatData.find(item => Number(item.node.line) === Number(targetLine));

                if (targetItem) {
                  // Determine the row index.
                  const targetIndex = flatData.indexOf(targetItem);
                  const itemHeight = this.myTreeGrid.itemHeight;

                  // Calculate the row's top and bottom positions.
                  const rowTop = targetIndex * itemHeight;
                  const rowBottom = rowTop + itemHeight;

                  // Get current scroll position and container height.
                  const containerScrollTop = this.treeViewContainer.scrollTop;
                  const containerHeight = this.treeViewContainer.clientHeight;

                  // If the target row is not completely visible, adjust the scroll position.
                  if (rowTop < containerScrollTop || rowBottom > containerScrollTop + containerHeight) {
                    this.treeViewContainer.scrollTop = rowTop;
                  }

                  // Optionally, highlight the row.
                  const element = this.treeViewContent.querySelector(`[data-id="${targetItem.node.id}"]`);
                  if (element) {
                    element.style.backgroundColor = "yellow";
                    setTimeout(() => { element.style.backgroundColor = ""; }, 2000);
                  }
                } else {
                  alert("Could not locate an object starting at line " + targetLine);
                }
              }
            });


            row.appendChild(typeSpan);
            row.appendChild(dataSizeSpan);
            row.appendChild(showButton);
            visibleContainer.appendChild(row);
          }
        };

        // Attach scroll event for virtualization.
        container.onscroll = updateView;
        updateView();
      }
      updateBlocksOverlay() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayBlocksContent").innerHTML = "No DXF data loaded.";
          return;
        }

        // Build a dictionary of block definitions using BLOCK nodes (group code 2 for block name)
        let blocksDict = {};
        function traverseForBlocks(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty && node.type && node.type.toUpperCase() === "BLOCK") {
              let blockName = "";
              if (node.properties && node.properties.length) {
                node.properties.forEach(prop => {
                  if (Number(prop.code) === 2) {
                    blockName = prop.value;
                  }
                });
              }
              if (blockName) {
                blocksDict[blockName] = { block: node, inserts: [] };
              }
            }
            if (node.children && node.children.length > 0) {
              traverseForBlocks(node.children);
            }
          });
        }
        activeTab.originalTreeData.forEach(node => traverseForBlocks([node]));

        // Traverse the tree to collect all INSERT nodes
        function traverseForInserts(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty && node.type && node.type.toUpperCase() === "INSERT") {
              let insertBlockName = "";
              let layer = "";
              if (node.properties && node.properties.length) {
                node.properties.forEach(prop => {
                  if (Number(prop.code) === 2) {
                    insertBlockName = prop.value;
                  }
                  if (Number(prop.code) === 8) {
                    layer = prop.value;
                  }
                });
              }
              if (insertBlockName) {
                if (!blocksDict[insertBlockName]) {
                  blocksDict[insertBlockName] = { block: null, inserts: [] };
                }
                blocksDict[insertBlockName].inserts.push({ insert: node, layer: layer });
              }
            }
            if (node.children && node.children.length > 0) {
              traverseForInserts(node.children);
            }
          });
        }
        activeTab.originalTreeData.forEach(node => traverseForInserts([node]));

        // Helper function to render nested INSERTs (if an INSERT node contains its own INSERT children)
        function renderNestedInserts(node) {
          let nestedHtml = "";
          if (node.children && node.children.length > 0) {
            let childInserts = node.children.filter(child => child.type && child.type.toUpperCase() === "INSERT");
            if (childInserts.length > 0) {
              nestedHtml += `<ul>`;
              childInserts.forEach(child => {
                let childLayer = "";
                if (child.properties && child.properties.length) {
                  child.properties.forEach(prop => {
                    if (Number(prop.code) === 8) {
                      childLayer = prop.value;
                    }
                  });
                }
                nestedHtml += `<li>Nested Insert at line: ${child.line} on layer: ${childLayer}`;
                if (child.handle) {
                  nestedHtml += ` <a href="#" onclick="window.app.handleLinkToHandle('${child.handle}'); document.getElementById('blocksOverlay').style.display='none'; return false;">Show In Tree</a>`;
                }
                nestedHtml += renderNestedInserts(child);
                nestedHtml += `</li>`;
              });
              nestedHtml += `</ul>`;
            }
          }
          return nestedHtml;
        }

        // Build the HTML output
        let html = "";
        for (let blockName in blocksDict) {
          let entry = blocksDict[blockName];
          html += `<h3>Block: ${blockName}</h3>`;
          if (entry.block) {
            html += `<p>Defined at line: ${entry.block.line}`;
            if (entry.block.handle) {
              html += ` <a href="#" onclick="window.app.handleLinkToHandle('${entry.block.handle}'); document.getElementById('blocksOverlay').style.display='none'; return false;">Show In Tree</a>`;
            }
            html += `</p>`;
          } else {
            html += `<p>Block definition not found.</p>`;
          }
          if (entry.inserts.length > 0) {
            html += `<ul>`;
            entry.inserts.forEach(ins => {
              html += `<li>Insert at line: ${ins.insert.line} on layer: ${ins.layer}`;
              if (ins.insert.handle) {
                html += ` <a href="#" onclick="window.app.handleLinkToHandle('${ins.insert.handle}'); document.getElementById('blocksOverlay').style.display='none'; return false;">Show In Tree</a>`;
              }
              html += renderNestedInserts(ins.insert);
              html += `</li>`;
            });
            html += `</ul>`;
          } else {
            html += `<p>No inserts found for this block.</p>`;
          }
        }
        document.getElementById("overlayBlocksContent").innerHTML = html;
      }
      showInTree(node) {
        if (node.handle) {
          // Navigate using the handle if available.
          this.handleLinkToHandle(node.handle);
        } else {
          // Use the starting line number to locate the item.
          const targetLine = node.line;
          const flatData = this.myTreeGrid.flatData;
          const targetItem = flatData.find(item => Number(item.node.line) === Number(targetLine));
          if (targetItem) {
            // Determine the row index.
            const targetIndex = flatData.indexOf(targetItem);
            const itemHeight = this.myTreeGrid.itemHeight;
            // Calculate the row's top and bottom positions.
            const rowTop = targetIndex * itemHeight;
            const rowBottom = rowTop + itemHeight;
            // Get current scroll position and container height.
            const containerScrollTop = this.treeViewContainer.scrollTop;
            const containerHeight = this.treeViewContainer.clientHeight;
            // If the target row is not completely visible, adjust the scroll position.
            if (rowTop < containerScrollTop || rowBottom > containerScrollTop + containerHeight) {
              this.treeViewContainer.scrollTop = rowTop;
            }
            // Highlight the row.
            const element = this.treeViewContent.querySelector(`[data-id="${targetItem.node.id}"]`);
            if (element) {
              element.style.backgroundColor = "yellow";
              setTimeout(() => { element.style.backgroundColor = ""; }, 2000);
            }
          } else {
            alert("Could not locate an object starting at line " + targetLine);
          }
        }
      }
      showInTreeById(nodeId, nodeLine) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const node = this.dxfParser.findNodeByIdIterative(activeTab.originalTreeData, nodeId);
        if (node) {
          // Close the overlays that initiated this action.
          document.getElementById("lineTypesOverlay").style.display = "none";
          document.getElementById("textsOverlay").style.display = "none";
          // Navigate to and highlight the node.
          this.showInTree(node);
        } else {
          alert("Node not found");
        }
      }
      updateLineTypes() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayLineTypesContent").innerHTML = "<p>No DXF data loaded.</p>";
          return;
        }
        let defined = {};
        let used = {};

        function traverse(nodes) {
          nodes.forEach(node => {
            if (node.type && node.type.toUpperCase() === "LTYPE") {
              let ltName = "";
              if (node.properties) {
                node.properties.forEach(prop => {
                  if (Number(prop.code) === 2) {
                    ltName = prop.value;
                  }
                });
              }
              if (ltName) {
                if (!defined[ltName]) {
                  defined[ltName] = node;
                }
              }
            } else {
              if (node.properties) {
                node.properties.forEach(prop => {
                  if (Number(prop.code) === 6) {
                    let lt = prop.value;
                    if (lt && !used[lt]) {
                      used[lt] = node;
                    }
                  }
                });
              }
            }
            if (node.children && node.children.length > 0) {
              traverse(node.children);
            }
          });
        }
        traverse(activeTab.originalTreeData);

        let allTypes = new Set([...Object.keys(defined), ...Object.keys(used)]);
        let html = "";
        if (allTypes.size === 0) {
          html = "<p>No linetypes found.</p>";
        } else {
          html += "<ul>";
          allTypes.forEach(lt => {
            let node = defined[lt] ? defined[lt] : used[lt];
            let origin = defined[lt] ? "Defined" : "Used Only";
            html += `<li>${lt} (${origin}) - 
                     <button onclick="window.app.showInTreeById('${node.id}', ${node.line})">Show In Tree</button>
                     </li>`;
          });
          html += "</ul>";
        }
        document.getElementById("overlayLineTypesContent").innerHTML = html;
      }
      /**
       * Deciphers an MTEXT string by replacing DXF formatting codes with HTML
       * and also returns a detailed breakdown of each code encountered.
       *
       * Supported MTEXT codes in this example:
       *   • \P  : Paragraph break (inserts a new paragraph)
       *   • \~  : Non‑breaking space
       *   • \\  : Literal backslash (protected)
       *   • \L  : Begin underline
       *   • \l  : End underline
       *   • \O  : Begin overline
       *   • \o  : End overline
       *   • \T  : Text style toggle (ignored)
       *   • \H<number>x : Set text height (e.g. \H12.5x means height 12.5)
       *   • \W<number>x : Set width factor (e.g. \W0.8x means width factor 0.8)
       *   • \A<number>; : Set text angle in degrees (e.g. \A45; means 45° rotation)
       *   • \S<numerator>;<denom>; : Fraction formatting (replaced with a fraction display)
       *
       * @param {string} mtext - The raw MTEXT string from the DXF.
       * @returns {string} A combined string that shows the deciphered (HTML-formatted)
       *                   text and a breakdown of each formatting code.
       */
      decipherMTextFormatting(mtext) {
        if (!mtext) return "";

        // Save the original text for reference.
        const originalText = mtext;

        // Protect any literal backslashes (i.e. "\\" becomes a placeholder).
        mtext = mtext.replace(/\\\\/g, "%%BACKSLASH%%");

        // Array to collect breakdown info for each formatting code encountered.
        let breakdown = [];

        // Replace paragraph breaks (\P) with two <br/> tags.
        mtext = mtext.replace(/\\P/g, function(match) {
          breakdown.push({
            code: "\\P",
            description: "Paragraph break – starts a new paragraph",
            replacement: "<br/><br/>",
            original: match
          });
          return "<br/><br/>";
        });

        // Replace non-breaking space (\~) with HTML non‑breaking space.
        mtext = mtext.replace(/\\~/g, function(match) {
          breakdown.push({
            code: "\\~",
            description: "Non‑breaking space",
            replacement: "&nbsp;",
            original: match
          });
          return "&nbsp;";
        });

        // Underline on (\L) and off (\l)
        mtext = mtext.replace(/\\L/g, function(match) {
          breakdown.push({
            code: "\\L",
            description: "Turn on underline formatting",
            replacement: "<u>",
            original: match
          });
          return "<u>";
        });
        mtext = mtext.replace(/\\l/g, function(match) {
          breakdown.push({
            code: "\\l",
            description: "Turn off underline formatting",
            replacement: "</u>",
            original: match
          });
          return "</u>";
        });

        // Overline on (\O) and off (\o)
        mtext = mtext.replace(/\\O/g, function(match) {
          breakdown.push({
            code: "\\O",
            description: "Turn on overline formatting",
            replacement: "<span style='text-decoration: overline;'>",
            original: match
          });
          return "<span style='text-decoration: overline;'>";
        });
        mtext = mtext.replace(/\\o/g, function(match) {
          breakdown.push({
            code: "\\o",
            description: "Turn off overline formatting",
            replacement: "</span>",
            original: match
          });
          return "</span>";
        });

        // Text style toggle (\T) is not rendered (ignored).
        mtext = mtext.replace(/\\T/g, function(match) {
          breakdown.push({
            code: "\\T",
            description: "Text style toggle (ignored in this implementation)",
            replacement: "",
            original: match
          });
          return "";
        });

        // Text height (\H<number>x) – the numeric value sets the text height.
        mtext = mtext.replace(/\\H([\d\.]+)x?/g, function(match, p1) {
          breakdown.push({
            code: "\\H" + p1 + "x",
            description: "Set text height to " + p1,
            replacement: "",
            original: match
          });
          // In the formatted text output we simply remove the height command.
          return "";
        });

        // Width factor (\W<number>x) – the numeric value sets the width factor.
        mtext = mtext.replace(/\\W([\d\.]+)x?/g, function(match, p1) {
          breakdown.push({
            code: "\\W" + p1 + "x",
            description: "Set width factor to " + p1,
            replacement: "",
            original: match
          });
          return "";
        });

        // Text angle (\A<number>;) – sets the rotation angle in degrees.
        mtext = mtext.replace(/\\A(-?[\d\.]+);/g, function(match, p1) {
          breakdown.push({
            code: "\\A" + p1 + ";",
            description: "Set text angle to " + p1 + " degrees",
            replacement: "",
            original: match
          });
          return "";
        });

        // Fraction formatting (\S<numerator>;<denom>;) – display as a fraction.
        mtext = mtext.replace(/\\S([^;]+);([^;]+);/g, function(match, num, den) {
          breakdown.push({
            code: "\\S" + num + ";" + den + ";",
            description: "Fraction formatting – numerator: " + num + ", denominator: " + den,
            replacement: "<sup>" + num + "</sup>&frasl;<sub>" + den + "</sub>",
            original: match
          });
          return "<sup>" + num + "</sup>&frasl;<sub>" + den + "</sub>";
        });

        // Restore literal backslashes.
        mtext = mtext.replace(/%%BACKSLASH%%/g, "\\");

        // Build a formatted breakdown string.
        let breakdownText = "MTEXT Formatting Breakdown:\n";
        breakdown.forEach(item => {
          breakdownText += `${item.code} : ${item.description}\n`;
        });

        // Combine the deciphered (formatted) text with the breakdown.
        let result =
          "Original MTEXT Value:\n" + originalText + "\n\n" +
          "Deciphered Text (HTML):\n" + mtext + "\n\n" +
          breakdownText;

        return result;
      }
      decipherMText(nodeId) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const node = this.dxfParser.findNodeByIdIterative(activeTab.originalTreeData, nodeId);
        if (!node) {
          alert("MTEXT node not found");
          return;
        }
        // Assume that group code 1 holds the raw MTEXT string.
        let rawText = "";
        node.properties.forEach(prop => {
          if (Number(prop.code) === 1) {
            rawText = prop.value;
          }
        });
        // Call the helper function to decipher the MTEXT formatting.
        const deciphered = decipherMTextFormatting(rawText);
        // You might want to show the deciphered details in a dialog.
        // For simplicity, we use alert here.
        alert("Deciphered MTEXT:\n\n" + deciphered);
      }
      toggleDecipherDetails(nodeId) {
        const detailsElem = document.getElementById(`deciphered-${nodeId}`);
        if (detailsElem) {
          detailsElem.style.display = (detailsElem.style.display === "none") ? "block" : "none";
        }
      }
      updateTexts() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayTextsContent").innerHTML = "<p>No DXF data loaded.</p>";
          return;
        }
        let texts = [];
        function traverse(nodes) {
          nodes.forEach(node => {
            if (node.type && (node.type.toUpperCase() === "TEXT" || node.type.toUpperCase() === "MTEXT")) {
              texts.push(node);
            }
            if (node.children && node.children.length > 0) {
              traverse(node.children);
            }
          });
        }
        traverse(activeTab.originalTreeData);

        let html = "";
        if (texts.length === 0) {
          html = "<p>No text objects found.</p>";
        } else {
          html += "<ul>";
          texts.forEach(node => {
            let txt = "";
            if (node.properties) {
              node.properties.forEach(prop => {
                if (Number(prop.code) === 1) {
                  txt = prop.value;
                }
              });
            }
            html += `<li>${node.type} (Line ${node.line}) - Text: ${txt} 
                     <button onclick="window.app.showInTreeById('${node.id}', ${node.line})">Show In Tree</button>`;
            // For MTEXT entities, add a toggle button and hidden details area.
            if (node.type.toUpperCase() === "MTEXT") {
              html += ` <button class="toggle-details" onclick="window.app.toggleDecipherDetails('${node.id}')">
                          Show Deciphered Details
                        </button>
                        <pre id="deciphered-${node.id}" style="display:none; background:#f9f9f9; border:1px solid #eee; padding:8px;">
            Deciphered Text:
            ${window.app.decipherMTextFormatting(txt)}
                        </pre>`;
            }
            html += `</li>`;
          });
          html += "</ul>";
        }
        document.getElementById("overlayTextsContent").innerHTML = html;
      }
      searchDxfTree(nodes, objectType, searchText, exact) {
        let results = [];
        nodes.forEach(node => {
          if (!objectType || (node.type && node.type.toLowerCase() === objectType.toLowerCase())) {
            if (node.properties && node.properties.length > 0) {
              node.properties.forEach(prop => {
                if (prop.value) {
                  let isMatch = false;
                  if (exact) {
                    isMatch = (prop.value === searchText);
                  } else {
                    isMatch = prop.value.toLowerCase().includes(searchText.toLowerCase());
                  }
                  if (isMatch) {
                    results.push({ line: prop.line, data: prop.value });
                  }
                }
              });
            }
          }
          if (node.children && node.children.length > 0) {
            results = results.concat(this.searchDxfTree(node.children, objectType, searchText, exact));
          }
        });
        return results;
      }
      openFileTab(file, targetLine) {
        // Close the batch results overlay.
        document.getElementById("batchProcessingOverlay").style.display = "none";

        // Check if a tab for this file already exists (using file.name as the identifier).
        let existingTab = this.tabs.find(tab => tab.name === file.name);
        if (existingTab) {
          // Switch to that tab.
          this.activeTabId = existingTab.id;
          this.updateTabUI();
          this.myTreeGrid.setData(existingTab.currentTreeData);
          // Delay scrolling until after the tab is rendered.
          setTimeout(() => {
            this.scrollToLineAfterTabOpen(targetLine);
          }, 300);
        } else {
          // File not loaded yet: load it as with manual file parsing.
          const reader = new FileReader();
          reader.onload = (event) => {
            const text = event.target.result;
            const objects = this.dxfParser.parse(text);
            const newTab = {
              id: Date.now() + Math.random(),
              name: file.name,
              originalTreeData: objects,
              currentTreeData: objects,
              codeSearchTerms: [],
              dataSearchTerms: [],
              currentSortField: "line",
              currentSortAscending: true,
              minLine: null,
              maxLine: null,
              dataExact: false,
              dataCase: false,
              navigationHistory: [],
              currentHistoryIndex: -1
            };
            this.tabs.push(newTab);
            this.activeTabId = newTab.id;
            this.updateTabUI();
            this.myTreeGrid.setData(newTab.currentTreeData);
            // Delay scrolling until after the new tab is rendered.
            setTimeout(() => {
              this.scrollToLineAfterTabOpen(targetLine);
            }, 300);
          };
          reader.readAsText(file, "ascii");
        }
      }
      handleBatchProcess() {
        const directoryInput = document.getElementById("directoryInput");
        const files = directoryInput.files;
        if (!files || files.length === 0) {
          alert("Please select a directory containing DXF files.");
          return;
        }
        const objectType = document.getElementById("batchObjectType").value.trim();
        const searchText = document.getElementById("batchSearchText").value.trim();
        const searchMode = document.querySelector('input[name="batchSearchMode"]:checked').value;
        const exact = (searchMode === "exact");
        if (!searchText) {
          alert("Please enter search text.");
          return;
        }
        const resultsTbody = document.getElementById("batchResultsTable").querySelector("tbody");
        resultsTbody.innerHTML = ""; // Clear any previous results
        let rowCounter = 1; // Counter for numbering rows

        // Process the files sequentially to help keep memory usage low.
        const filesArray = Array.from(files);
        const processFile = async (file) => {
          console.log("Processing file:", file.name);
          // Only process DXF files.
          if (!file.name.toLowerCase().endsWith(".dxf")) return;
          try {
            // Use the existing streamed parser (which uses file.stream()).
            const dxfObjects = await this.parseFileStream(file);
            const matches = this.searchDxfTree(dxfObjects, objectType, searchText, exact);
            matches.forEach(match => {
              const row = document.createElement("tr");
              // Add numbering cell as the first column.
              const cellNum = document.createElement("td");
              cellNum.textContent = rowCounter++;
              row.appendChild(cellNum);

              const cellFile = document.createElement("td");
              const link = document.createElement("a");
              link.textContent = file.webkitRelativePath || file.name;
              link.href = "#";
              link.addEventListener("click", function(e) {
                e.preventDefault();
                window.app.openFileTab(file, match.line);
              });
              cellFile.appendChild(link);
              row.appendChild(cellFile);

              const cellLine = document.createElement("td");
              cellLine.textContent = match.line;
              row.appendChild(cellLine);

              const cellData = document.createElement("td");
              cellData.textContent = match.data;
              row.appendChild(cellData);

              resultsTbody.appendChild(row);
            });
          } catch (err) {
            console.error("Error processing file: " + file.name, err);
            console.error("Stack:", err.stack);
          }
        };

        // Process each file sequentially.
        const progressBar = document.getElementById("batchProgress");
        // Show progress bar when processing starts
        progressBar.style.display = "block";

        const processAllFiles = async () => {
          for (let i = 0; i < filesArray.length; i++) {
            await processFile(filesArray[i]);
            // Update progress bar (percentage complete)
            progressBar.value = ((i + 1) / filesArray.length) * 100;
          }
          // When finished, reset progress and hide the progress bar
          progressBar.value = 0;
          progressBar.style.display = "none";
        };

        processAllFiles();
      }
      downloadBatchResultsAsExcel() {
        const table = document.getElementById("batchResultsTable");
        if (!table) {
          alert("No batch results table found.");
          return;
        }
        let csv = "";
        // Loop over all rows in the table.
        for (let row of table.rows) {
          let rowData = [];
          for (let cell of row.cells) {
            let cellText = cell.textContent.trim();
            // Escape any quotes in the cell text.
            cellText = cellText.replace(/"/g, '""');
            rowData.push('"' + cellText + '"');
          }
          csv += rowData.join(",") + "\n";
        }
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("href", url);
        link.setAttribute("download", "batch_results.csv");
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    }
    document.addEventListener("DOMContentLoaded", () => { 
      window.app = new App();
      
      // DRAG & DROP SUPPORT:
      // Prevent default drag behaviors on document
      document.addEventListener("dragover", function(e) {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = "copy";
      }, false);
      document.addEventListener("dragenter", function(e) {
        e.preventDefault();
        e.stopPropagation();
      }, false);
      document.addEventListener("dragleave", function(e) {
        e.preventDefault();
        e.stopPropagation();
      }, false);
      // Handle file drops on the entire document body
      document.addEventListener("drop", function(e) {
        e.preventDefault();
        e.stopPropagation();
        const files = e.dataTransfer.files;
        if (files && files.length > 0) {
          window.app.handleFiles(files);
        }
      }, false);
    });
  </script>
</body>
</html>
