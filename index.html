<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- This meta tag makes the app responsive on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DXF Parser</title>
  <!-- Include JSZip for ZIP file browsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <style>
    /* Base Styles */
    html, body { height: 100%; margin: 0; padding: 0; }
    *, *:before, *:after { box-sizing: border-box; }
    body { font-family: sans-serif; }
    .main-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 1em;
    }
    /* Layout for two‐column main content with fixed sidebar */
    .content-wrapper {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    .sidebar {
      width: 300px; /* Fixed width */
      padding: 1em;
      border-right: 1px solid #ccc;
      overflow-y: auto;
    }
    /* Sidebar Logo */
    .sidebar-logo h1 {
      margin: 0 0 1em 0;
      font-size: 1.5em;
    }
    .pane-resizer {
      width: 5px;
      cursor: ew-resize;
      background-color: #ccc;
    }
    .main-content {
      flex: 1;
      padding-left: 1em;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    /* Sidebar header buttons – stacked vertically and fill width */
    .sidebar-buttons {
      display: flex;
      flex-direction: column;
      gap: 0.5em;
      margin-bottom: 1em;
    }
    .sidebar-buttons button {
      width: 100%;
      padding: 0.5em;
      box-sizing: border-box;
    }
    /* File input row */
    .file-input-row {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 1em;
    }
    .file-input-row .left-part {
      display: flex;
      align-items: center;
      gap: 0.5em;
    }
    /* Navigation Controls – a single row combining Go to Handle and navigation history */
    #navControls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1em;
    }
    /* Left part: Handle Navigation */
    #handleNavBar {
      display: flex;
      align-items: center;
    }
    #handleNavBar input {
      margin-right: 0.5em;
    }
    /* Right part: Navigation History */
    #navHistoryContainer {
      display: flex;
      align-items: center;
    }
    #navHistoryControls button {
      margin-right: 4px;
    }
    #navHistoryList {
      margin-left: 8px;
      overflow-x: auto;
      white-space: nowrap;
    }
    #parseBtn { padding: 0.3em 0.6em; white-space: nowrap; }
    /* Tabs */
    #tabContainer {
      display: flex;
      flex-wrap: wrap;
      border-bottom: 1px solid #ccc;
      margin: 0.5em 0;
    }
    .tab {
      padding: 0.5em 1em;
      border: 1px solid #ccc;
      border-bottom: none;
      cursor: pointer;
      margin-right: 2px;
      margin-bottom: 2px;
      background: #eee;
      position: relative;
    }
    .tab.active { background: #fff; font-weight: bold; }
    .tab .close-tab {
      position: absolute;
      top: 0;
      right: 2px;
      cursor: pointer;
      padding: 0 4px;
    }
    /* Tree Grid Header */
    #treeGridHeader {
      display: flex;
      align-items: center;
      height: 24px;
      font-weight: bold;
      border-bottom: 1px solid #ccc;
      background: #eee;
      user-select: none;
      position: sticky;
      top: 0;
      z-index: 2;
      will-change: transform;
    }
    .header-cell {
      display: flex;
      align-items: center;
      height: 100%;
      position: relative;
      padding: 0 4px;
      border-right: 1px solid #ccc;
      cursor: pointer;
    }
    .header-cell.flex-fixed { flex: none; }
    .header-cell.flex-grow { flex: 1; }
    .header-cell:last-child { border-right: none; }
    .header-cell .resizer {
      position: absolute;
      right: 0;
      top: 0;
      width: 5px;
      height: 100%;
      cursor: col-resize;
    }
    .header-cell .sort-indicator {
      margin-left: 4px;
      font-size: 0.8em;
    }
    .tree-line,
    .tree-code,
    .tree-object-count,
    .tree-data-size {
      flex: none;
      padding: 0 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: left;
      border-right: 1px solid #ccc;
      height: 100%;
    }
    .tree-data {
      padding: 0 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border-right: 1px solid #ccc;
      height: 100%;
    }
    .tree-line:last-child,
    .tree-code:last-child,
    .tree-data:last-child,
    .tree-object-count:last-child,
    .tree-data-size:last-child { border-right: none; }
    /* Tree View Container */
    #treeViewContainer {
      position: relative;
      flex: 1;
      overflow: auto;
      border: 1px solid #ccc;
      clip-path: inset(0);
    }
    #treeViewContent { position: relative; overflow: hidden; }
    /* Tree row styling – with row selection support */
    .tree-row {
      display: flex;
      align-items: center;
      height: 24px;
      border-bottom: 1px solid #eee;
      overflow: hidden;
      cursor: pointer;
    }
    .tree-row.selected {
      background-color: #bde4ff;
    }
    .toggle {
      display: inline-block;
      width: 16px;
      text-align: center;
      user-select: none;
      cursor: pointer;
    }
    .copy-button, .hex-button {
      margin-left: 8px;
      font-size: 0.8em;
      display: none;
    }
    .tree-row:hover .copy-button,
    .tree-row:hover .hex-button { display: inline; }
    /* Filter Panel – controls now stacked vertically */
    .filter-panel {
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-bottom: 1em;
      padding: 0.5em;
    }
    .filter-panel h2 {
      margin: 0 0 0.5em 0;
      font-size: 1.2em;
    }
    .filter-content .filter-row {
      display: flex;
      flex-direction: column;
      gap: 0.5em;
      margin-bottom: 0.5em;
    }
    .filter-row label,
    .filter-row input,
    .filter-row button { margin-right: 0; }
    .tag-container {
      display: block;
      border: 1px solid #ccc;
      padding: 2px;
      margin-bottom: 0.5em;
      border-radius: 4px;
    }
    .tag-container input {
      border: none;
      outline: none;
      font-family: inherit;
      width: 100%;
    }
    .tag {
      display: inline-block;
      background: #ddd;
      padding: 2px 6px;
      margin: 2px;
      border-radius: 4px;
      font-size: 0.9em;
    }
    .tag .remove {
      margin-left: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    /* Overlays – all dialogs are hidden by default and appear above the tree view */
    #cloudOverlay,
    #statsOverlay,
    #depsOverlay,
    #binaryObjectsOverlay,
    #handleMapOverlay,
    #hexViewerOverlay,
    #proxyObjectsOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    /* Raise the hex viewer above the other overlays */
    #hexViewerOverlay { z-index: 1100; }
    /* The other overlays get z-index: 1000 */
    #cloudOverlay,
    #statsOverlay,
    #depsOverlay,
    #binaryObjectsOverlay,
    #handleMapOverlay,
    #proxyObjectsOverlay { z-index: 1000; }
    .overlay-content {
      background: #fff;
      margin: 20px;
      padding: 1em;
      width: calc(100% - 40px);
      height: calc(100% - 40px);
      border: 4px solid rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      position: relative;
      overflow-y: auto;
    }
    #closeCloudOverlay,
    #closeStatsOverlay,
    #closeDepsOverlay,
    #closeHexViewerOverlay,
    #closeBinaryObjectsOverlay,
    #closeHandleMapOverlay,
    #closeProxyObjectsOverlay,
    #saveBinaryBtn,
    #previewImageBtn {
      position: absolute;
      top: 10px;
      cursor: pointer;
    }
    #closeCloudOverlay,
    #closeStatsOverlay,
    #closeDepsOverlay,
    #closeHexViewerOverlay,
    #closeBinaryObjectsOverlay,
    #closeHandleMapOverlay,
    #closeProxyObjectsOverlay { right: 10px; }
    #saveBinaryBtn { right: 80px; }
    #previewImageBtn { right: 170px; }
    .cloud-tag {
      display: inline-block;
      margin: 4px;
      padding: 2px 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #f9f9f9;
    }
    #overlayStatsContent ul,
    #overlayDepsContent ul {
      list-style: none;
      padding: 0;
    }
    #overlayStatsContent li,
    #overlayDepsContent li {
      padding: 0.5em 0;
      border-bottom: 1px solid #eee;
    }
    /* Additional containers for previews */
    #imagePreviewContainer, #zipContentsContainer {
      margin-top: 10px;
    }
    /* Responsive adjustments for mobile */
    @media (max-width: 600px) {
      .filter-content .filter-row {
        flex-direction: column;
      }
      .tag-container { width: 100%; }
      #treeGridHeader .header-cell { padding: 0 2px; }
      .tree-row { height: 32px; }
      .tree-row .toggle { width: 20px; }
      .sidebar-logo h1 { font-size: 1.3em; }
      .content-wrapper {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid #ccc;
        padding-bottom: 1em;
        margin-bottom: 1em;
      }
      .pane-resizer { display: none; }
      .main-content { padding-left: 0; }
      #navControls { flex-direction: column; align-items: flex-start; }
      #handleNavBar, #navHistoryContainer { margin-bottom: 0.5em; }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <!-- Main content wrapper with sidebar and main content -->
    <div class="content-wrapper">
      <!-- Sidebar: Contains logo, header buttons and filter panel -->
      <div class="sidebar">
        <!-- Sidebar logo -->
        <div class="sidebar-logo">
          <h1>DXF Parser</h1>
        </div>
        <div class="sidebar-buttons">
          <button id="expandAllBtn">Expand All</button>
          <button id="collapseAllBtn">Collapse All</button>
          <button id="showCloudOverlayBtn">Show Cloud Data</button>
          <button id="showStatsOverlayBtn">Show DXF Statistics</button>
          <button id="showDepsOverlayBtn">Show DXF Dependencies</button>
          <button id="showBinaryObjectsOverlayBtn">Show Binary Objects</button>
          <button id="showHandleMapOverlayBtn">Show Handle Map</button>
          <button id="showProxyObjectsOverlayBtn">Show Proxy Objects</button>
        </div>
        <div class="filter-panel" id="filterPanel">
          <h2>Filters</h2>
          <div class="filter-content">
            <div class="filter-row">
              <div id="codeSearchTags" class="tag-container">
                <input type="text" id="codeSearchInput" placeholder="Search by Code">
              </div>
            </div>
            <div class="filter-row">
              <div id="dataSearchTags" class="tag-container">
                <input type="text" id="dataSearchInput" placeholder="Search by Data value">
              </div>
            </div>
            <div class="filter-row">
              <label>
                <input type="checkbox" id="dataExactCheckbox"> Exact Data Match
              </label>
            </div>
            <div class="filter-row">
              <label>
                <input type="checkbox" id="dataCaseCheckbox"> Case Sensitive
              </label>
            </div>
            <div class="filter-row">
              <label for="minLineInput">Min Line:</label>
              <input type="number" id="minLineInput" style="width:80px;">
            </div>
            <div class="filter-row">
              <label for="maxLineInput">Max Line:</label>
              <input type="number" id="maxLineInput" style="width:80px;">
            </div>
            <div class="filter-row">
              <button id="searchBtn">Search</button>
              <button id="clearSearchBtn">Clear Search</button>
            </div>
          </div>
        </div>
      </div>
      <!-- Resizer between sidebar and main content -->
      <div class="pane-resizer"></div>
      <!-- Main Content Area -->
      <div class="main-content">
        <!-- File input row -->
        <div class="file-input-row">
          <div class="left-part">
            <input type="file" id="fileInput" accept=".dxf" multiple>
            <label>
              <input type="checkbox" id="useStreamCheckbox">
              Use Streamed Parsing
            </label>
            <button id="parseBtn">Parse File(s)</button>
          </div>
        </div>
        <!-- Combined Navigation Row -->
        <div id="navControls">
          <div id="handleNavBar">
            <input type="text" id="handleSearchInput" placeholder="Go to Handle">
            <button id="goToHandleBtn">Go</button>
          </div>
          <div id="navHistoryContainer">
            <div id="navHistoryControls">
              <button id="backBtn" disabled>Back</button>
              <button id="forwardBtn" disabled>Forward</button>
              <button id="clearHistoryBtn">Clear</button>
            </div>
            <div id="navHistoryList"></div>
          </div>
        </div>
        <!-- Tabs -->
        <div id="tabContainer"></div>
        <!-- Tree Grid Header -->
        <div id="treeGridHeader" class="tree-header">
          <div class="tree-line header-cell flex-fixed" data-field="line" data-sort="none" style="width: 100px; text-align: left;">
            Line <span class="sort-indicator"></span>
            <div class="resizer"></div>
          </div>
          <div class="tree-code header-cell flex-fixed" data-field="code" data-sort="none" style="width: 100px; text-align: left;">
            Code <span class="sort-indicator"></span>
            <div class="resizer"></div>
          </div>
          <div class="tree-data header-cell flex-grow" data-field="type" data-sort="none" style="flex: 1;">
            Data <span class="sort-indicator"></span>
            <div class="resizer"></div>
          </div>
          <div class="tree-object-count header-cell flex-fixed" data-field="objectCount" data-sort="none" style="width: 100px; text-align: right;">
            Object Count <span class="sort-indicator"></span>
            <div class="resizer"></div>
          </div>
          <div class="tree-data-size header-cell flex-fixed" data-field="dataSize" data-sort="none" style="width: 100px; text-align: right;">
            Data Size <span class="sort-indicator"></span>
            <div class="resizer"></div>
          </div>
        </div>
        <!-- Tree View Container -->
        <div id="treeViewContainer">
          <div id="treeViewContent"></div>
        </div>
      </div>
    </div>
  </div>
  <!-- Overlays -->
  <div id="cloudOverlay">
    <div class="overlay-content">
      <button id="closeCloudOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="cloudOverlay">Back to Tree</button>
      <h2>Cloud Data</h2>
      <h3>Object Cloud</h3>
      <div id="overlayObjectCloud"></div>
      <h3>Code Cloud</h3>
      <div id="overlayCodeCloud"></div>
    </div>
  </div>
  <div id="statsOverlay">
    <div class="overlay-content">
      <button id="closeStatsOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="statsOverlay">Back to Tree</button>
      <h2>DXF Statistics</h2>
      <div id="overlayStatsContent"></div>
    </div>
  </div>
  <div id="depsOverlay">
    <div class="overlay-content">
      <button id="closeDepsOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="depsOverlay">Back to Tree</button>
      <h2>DXF Dependencies</h2>
      <div id="overlayDepsContent"></div>
    </div>
  </div>
  <div id="hexViewerOverlay">
    <div class="overlay-content">
      <button id="closeHexViewerOverlay">Close</button>
      <button id="saveBinaryBtn">Save Binary</button>
      <button id="previewImageBtn">Preview Image</button>
      <h2>Hex Viewer</h2>
      <div id="headerInfo"></div>
      <pre id="hexContent" style="overflow:auto; height: calc(100% - 160px);"></pre>
      <div id="imagePreviewContainer"></div>
      <div id="zipContentsContainer"></div>
    </div>
  </div>
  <div id="binaryObjectsOverlay">
    <div class="overlay-content">
      <button id="closeBinaryObjectsOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="binaryObjectsOverlay">Back to Tree</button>
      <h2>Binary Data Objects</h2>
      <div id="binaryObjectsList"></div>
    </div>
  </div>
  <div id="handleMapOverlay">
    <div class="overlay-content">
      <button id="closeHandleMapOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="handleMapOverlay">Back to Tree</button>
      <h2>DXF Handle Map</h2>
      <div id="overlayHandleMapContent"></div>
    </div>
  </div>
  <!-- New Proxy Objects Overlay -->
  <div id="proxyObjectsOverlay">
    <div class="overlay-content">
      <button id="closeProxyObjectsOverlay">Close</button>
      <button class="backToTreeBtn" data-overlay="proxyObjectsOverlay">Back to Tree</button>
      <h2>Proxy Objects</h2>
      <div id="proxyObjectsList"></div>
    </div>
  </div>
  <!-- Utility Functions -->
  <script>
    // Convert a concatenated hex string into a Uint8Array.
    function hexStringToByteArray(hexString) {
      hexString = hexString.replace(/\s+/g, "");
      const byteLength = Math.floor(hexString.length / 2);
      const result = new Uint8Array(byteLength);
      for (let i = 0; i < byteLength; i++) {
        result[i] = parseInt(hexString.substr(i * 2, 2), 16);
      }
      return result;
    }
    // Produce a hex dump from a Uint8Array.
    function hexDump(buffer) {
      const bytesPerLine = 16;
      let result = "";
      for (let i = 0; i < buffer.length; i += bytesPerLine) {
        const lineBytes = Array.from(buffer.slice(i, i + bytesPerLine));
        const hexBytes = lineBytes.map(byte => byte.toString(16).padStart(2, '0'));
        const asciiChars = lineBytes.map(byte =>
          byte >= 32 && byte < 127 ? String.fromCharCode(byte) : '.'
        );
        while (hexBytes.length < bytesPerLine) {
          hexBytes.push("  ");
          asciiChars.push(" ");
        }
        result += i.toString(16).padStart(8, '0') + "  " +
                  hexBytes.join(" ") + "  " +
                  asciiChars.join("") + "\n";
      }
      return result;
    }
    // Attempt to detect a common file header from a Uint8Array.
    function detectHeader(buffer) {
      if (buffer.length >= 2 && buffer[0] === 0x42 && buffer[1] === 0x4D) return "BMP Image";
      if (buffer.length >= 8 &&
          buffer[0] === 0x89 && buffer[1] === 0x50 &&
          buffer[2] === 0x4E && buffer[3] === 0x47 &&
          buffer[4] === 0x0D && buffer[5] === 0x0A &&
          buffer[6] === 0x1A && buffer[7] === 0x0A)
        return "PNG Image";
      if (buffer.length >= 6) {
        const header = String.fromCharCode(...buffer.slice(0,6));
        if (header === "GIF87a" || header === "GIF89a") return "GIF Image";
      }
      if (buffer.length >= 3 && buffer[0] === 0xFF && buffer[1] === 0xD8 && buffer[2] === 0xFF)
        return "JPEG Image";
      if (buffer.length >= 4) {
        const header = String.fromCharCode(...buffer.slice(0,4));
        if (header === "%PDF") return "PDF Document";
      }
      if (buffer.length >= 4 &&
          buffer[0] === 0x50 && buffer[1] === 0x4B &&
          buffer[2] === 0x03 && buffer[3] === 0x04)
        return "ZIP Archive";
      return null;
    }
  </script>
  <!-- JavaScript Classes -->
  <script>
    class DxfParser {
      constructor() {
        this.containerMapping = {
          "SECTION": "ENDSEC",
          "BLOCK":   "ENDBLK",
          "TABLE":   "ENDTAB",
          "OBJECT":  "ENDOBJ",
          "POLYLINE": "SEQEND"
        };
        this.nextId = 1;
        this.handleCodes = [5, 105, 330, 350, 360];
      }
      parse(text) {
        const tags = this.parseDxf(text);
        const grouped = this.groupObjects(tags, 0);
        return grouped.objects;
      }
      parseDxf(text) {
        const lines = text.split(/\r?\n/);
        const tags = [];
        for (let i = 0; i < lines.length; i++) {
          const codeLine = lines[i].trim();
          if (!codeLine) continue;
          const code = parseInt(codeLine, 10);
          if (isNaN(code)) continue;
          let value = "";
          if (i + 1 < lines.length) { value = lines[i + 1].trim(); }
          i++;
          tags.push({ line: i, code, value });
        }
        return tags;
      }
      parseDxfLines(lines) {
        const tags = [];
        for (let i = 0; i < lines.length; i++) {
          const codeLine = lines[i].trim();
          if (!codeLine) continue;
          const code = parseInt(codeLine, 10);
          if (isNaN(code)) continue;
          let value = "";
          if (i + 1 < lines.length) { value = lines[i + 1].trim(); }
          i++;
          tags.push({ line: i, code, value });
        }
        return tags;
      }
      groupObjects(tags, startIndex, endMarker = null) {
        const objects = [];
        let i = startIndex;
        while (i < tags.length) {
          if (endMarker && tags[i].code === 0 && tags[i].value.toUpperCase() === endMarker) {
            i++;
            return { objects, nextIndex: i };
          }
          if (tags[i].code !== 0) { i++; continue; }
          const obj = {
            id: this.nextId++,
            type: tags[i].value,
            line: tags[i].line,
            properties: [],
            children: [],
            isContainer: this.containerMapping.hasOwnProperty(tags[i].value.toUpperCase()),
            expanded: false
          };
          i++;
          while (i < tags.length && tags[i].code !== 0) {
            obj.properties.push(tags[i]);
            i++;
          }
          const handleProp = obj.properties.find(prop => this.handleCodes.includes(prop.code));
          if (handleProp) { obj.handle = handleProp.value; }
          if (obj.isContainer) {
            const marker = this.containerMapping[obj.type.toUpperCase()];
            const result = this.groupObjects(tags, i, marker);
            obj.children = result.objects;
            i = result.nextIndex;
          }
          objects.push(obj);
        }
        return { objects, nextIndex: i };
      }
      findNodeById(tree, id) {
        for (const obj of tree) {
          if (String(obj.id) === String(id)) return obj;
          if (obj.children && obj.children.length) {
            const result = this.findNodeById(obj.children, id);
            if (result) return result;
          }
        }
        return null;
      }
      serializeNode(node) {
        let lines = [];
        lines.push("0");
        lines.push(node.type);
        node.properties.forEach(prop => {
          lines.push(prop.code.toString());
          lines.push(prop.value);
        });
        if (node.isContainer && node.children && node.children.length) {
          node.children.forEach(child => { lines.push(this.serializeNode(child)); });
          const endMarker = this.containerMapping[node.type.toUpperCase()];
          if (endMarker) { lines.push("0"); lines.push(endMarker); }
        }
        return lines.join("\n");
      }
    }
  </script>
  <!-- TreeDataGrid Control -->
  <script>
    class TreeDataGrid {
      constructor(container, content, options = {}) {
        this.container = container;
        this.content = content;
        this.itemHeight = options.itemHeight || 24;
        this.copyCallback = options.copyCallback || null;
        this.onToggleExpand = options.onToggleExpand || null;
        this.onHandleClick = options.onHandleClick || null;
        this.hexViewerCallback = options.hexViewerCallback || null;
        this.onRowSelect = options.onRowSelect || null;
        // Column widths are passed via the constructor options.
        // Each value may be a fixed pixel number, "Auto", or a star value (e.g. "*" or "2*").
        this.columnWidths = options.columnWidths || {
          line: 100,
          code: 100,
          type: "*",
          objectCount: 100,
          dataSize: 100
        };
        this.flatData = [];
        this.treeData = [];
        this.selectedRowId = null;
        // Re-render on scroll.
        this.container.addEventListener("scroll", () => { 
          requestAnimationFrame(() => this.updateVisibleNodes());
        });
        // Attach header resizer events (assumes header element exists with id "treeGridHeader").
        this.attachHeaderResizerEvents();
        // Handle toggle clicks inside the content.
        this.content.addEventListener("click", (e) => {
          if (e.target.classList.contains("toggle")) {
            e.stopPropagation();
            const row = e.target.closest(".tree-row");
            if (row) {
              const nodeId = row.dataset.id;
              if (this.onToggleExpand) { this.onToggleExpand(nodeId); }
            }
          }
        });
      }
      
      attachHeaderResizerEvents() {
        const headerResizers = document.querySelectorAll('#treeGridHeader .header-cell .resizer');
        headerResizers.forEach(resizer => {
          resizer.addEventListener("mousedown", (e) => this.handleResizerMouseDown(e));
        });
      }
      
      handleResizerMouseDown(e) {
        e.stopPropagation();
        const headerCell = e.target.parentElement;
        const field = headerCell.getAttribute('data-field');
        const startX = e.clientX;
        const startWidth = headerCell.offsetWidth;
        const onMouseMove = (eMove) => {
          const newWidth = startWidth + (eMove.clientX - startX);
          // Update the columnWidths for this field to a fixed pixel value.
          this.columnWidths[field] = newWidth;
          headerCell.style.width = newWidth + "px";
          headerCell.style.flex = "none";
          this.updateVisibleNodes();
        };
        const onMouseUp = () => {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        };
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      }
      
      computeColumnFinalWidths() {
        const containerWidth = this.container.clientWidth;
        const columns = ["line", "code", "type", "objectCount", "dataSize"];
        let fixedTotal = 0;
        let starTotal = 0;
        let finalWidths = {};
        columns.forEach(col => {
          let def = this.columnWidths[col];
          if (typeof def === "number") {
            finalWidths[col] = def;
            fixedTotal += def;
          } else if (typeof def === "string") {
            if (def.toLowerCase() === "auto") {
              const headerCell = document.querySelector(`#treeGridHeader .tree-${col}`);
              let autoWidth = headerCell ? headerCell.scrollWidth : 100;
              finalWidths[col] = autoWidth;
              fixedTotal += autoWidth;
            } else if (def.trim().endsWith("*")) {
              let multiplier = parseFloat(def.trim().slice(0, -1));
              if (isNaN(multiplier)) multiplier = 1;
              starTotal += multiplier;
              finalWidths[col] = { star: multiplier };
            } else {
              let pixels = parseFloat(def);
              if (!isNaN(pixels)) {
                finalWidths[col] = pixels;
                fixedTotal += pixels;
              } else {
                finalWidths[col] = 100;
                fixedTotal += 100;
              }
            }
          } else {
            starTotal += 1;
            finalWidths[col] = { star: 1 };
          }
        });
        let remaining = containerWidth - fixedTotal;
        if (remaining < 0) remaining = 0;
        columns.forEach(col => {
          if (typeof finalWidths[col] === "object" && finalWidths[col].star) {
            let multiplier = finalWidths[col].star;
            let width = (multiplier / starTotal) * remaining;
            finalWidths[col] = width;
          }
        });
        return finalWidths;
      }
      
      syncHeaderWidths() {
        const header = document.getElementById("treeGridHeader");
        if (!header) return;
        const colWidths = this.computeColumnFinalWidths();
        const lineCell = header.querySelector('.tree-line');
        if (lineCell) lineCell.style.width = colWidths.line + "px";
        const codeCell = header.querySelector('.tree-code');
        if (codeCell) codeCell.style.width = colWidths.code + "px";
        const typeCell = header.querySelector('.tree-data');
        if (typeCell) {
          typeCell.style.width = colWidths.type + "px";
          typeCell.style.flex = "0 0 auto";
        }
        const objectCountCell = header.querySelector('.tree-object-count');
        if (objectCountCell) objectCountCell.style.width = colWidths.objectCount + "px";
        const dataSizeCell = header.querySelector('.tree-data-size');
        if (dataSizeCell) dataSizeCell.style.width = colWidths.dataSize + "px";
      }
      
      setData(treeData) {
        this.treeData = treeData || [];
        this.refresh();
      }
      
      refresh() {
        this.flatData = this.flattenTree(this.treeData);
        console.log("Total rows:", this.flatData.length);
        this.updateVisibleNodes();
      }
      
      flattenTree(nodes, level = 0) {
        let flat = [];
        for (let node of nodes) {
          flat.push({ node, level });
          if (node.expanded) {
            if (node.properties && node.properties.length) {
              for (let prop of node.properties) {
                flat.push({
                  node: {
                    id: `prop-${node.id}-${prop.line}-${prop.code}`,
                    isProperty: true,
                    line: prop.line,
                    code: prop.code,
                    data: prop.value
                  },
                  level: level + 1
                });
              }
            }
            if (node.children && node.children.length) {
              flat = flat.concat(this.flattenTree(node.children, level + 1));
            }
          }
        }
        return flat;
      }
      
      computeObjectCount(node) {
        if (!node.children || node.children.length === 0) return 0;
        let count = 0;
        for (let child of node.children) {
          if (!child.isProperty) {
            count++;
            if (child.children && child.children.length) { 
              count += this.computeObjectCount(child);
            }
          }
        }
        return count;
      }
      
      computeDataSize(node) {
        let size = 0;
        if (node.isProperty) {
          size += node.data ? node.data.length : 0;
        } else {
          size += node.type ? node.type.length : 0;
          if (node.properties && node.properties.length) {
            for (let prop of node.properties) {
              size += prop.value ? prop.value.length : 0;
            }
          }
          if (node.children && node.children.length) {
            for (let child of node.children) {
              size += this.computeDataSize(child);
            }
          }
        }
        return size;
      }
      
      updateVisibleNodes() {
        const scrollTop = this.container.scrollTop;
        const containerHeight = this.container.clientHeight;
        const totalRows = this.flatData.length;
        const fullHeight = totalRows * this.itemHeight;
        this.content.style.height = fullHeight + "px";
        
        const colWidths = this.computeColumnFinalWidths();
        const lineWidth = colWidths.line;
        const codeWidth = colWidths.code;
        const dataWidth = colWidths.type;
        const objectCountWidth = colWidths.objectCount;
        const dataSizeWidth = colWidths.dataSize;
        const totalWidth = lineWidth + codeWidth + dataWidth + objectCountWidth + dataSizeWidth;
        
        const containerElem = document.createElement("div");
        containerElem.style.width = totalWidth + "px";
        
        const startIndex = Math.floor(scrollTop / this.itemHeight);
        const visibleCount = Math.ceil(containerHeight / this.itemHeight) + 1;
        const endIndex = Math.min(startIndex + visibleCount, totalRows);
        
        const topSpacer = document.createElement("div");
        topSpacer.style.height = (startIndex * this.itemHeight) + "px";
        containerElem.appendChild(topSpacer);
        
        const fragment = document.createDocumentFragment();
        for (let i = startIndex; i < endIndex; i++) {
          const { node, level } = this.flatData[i];
          const row = document.createElement("div");
          row.className = "tree-row tree-node";
          row.style.display = "flex";
          row.style.position = "relative";
          row.style.height = this.itemHeight + "px";
          row.dataset.id = node.id;
          if (String(node.id) === String(this.selectedRowId)) {
            row.classList.add("selected");
          }
          row.addEventListener("click", (e) => {
            this.selectedRowId = node.id;
            this.updateVisibleNodes();
            if (this.onRowSelect) { this.onRowSelect(node.id); }
          });
          
          // Line column.
          const lineDiv = document.createElement("div");
          lineDiv.className = "tree-line";
          lineDiv.style.width = lineWidth + "px";
          const lineContent = document.createElement("div");
          lineContent.style.display = "flex";
          lineContent.style.alignItems = "center";
          lineContent.style.marginLeft = (level * 20) + "px";
          if (!node.isProperty && ((node.properties && node.properties.length) || (node.children && node.children.length))) {
            const toggleSpan = document.createElement("span");
            toggleSpan.className = "toggle";
            toggleSpan.textContent = node.expanded ? "▼" : "►";
            toggleSpan.addEventListener("click", (e) => {
              e.stopPropagation();
              if (this.onToggleExpand) { this.onToggleExpand(node.id); }
            });
            lineContent.appendChild(toggleSpan);
          } else {
            const spacer = document.createElement("span");
            spacer.style.width = "16px";
            spacer.style.display = "inline-block";
            lineContent.appendChild(spacer);
          }
          const lineNumberSpan = document.createElement("span");
          lineNumberSpan.textContent = node.line || "";
          lineContent.appendChild(lineNumberSpan);
          lineDiv.appendChild(lineContent);
          row.appendChild(lineDiv);
          
          // Code column.
          const codeDiv = document.createElement("div");
          codeDiv.className = "tree-code";
          codeDiv.style.width = codeWidth + "px";
          codeDiv.style.textAlign = "left";
          if (node.isProperty) { 
            codeDiv.textContent = node.code; 
          } else { 
            codeDiv.textContent = ((node.properties && node.properties.length) || (node.children && node.children.length)) ? "0" : ""; 
          }
          row.appendChild(codeDiv);
          
          // Data column.
          const dataDiv = document.createElement("div");
          dataDiv.className = "tree-data";
          dataDiv.style.width = dataWidth + "px";
          dataDiv.style.flex = "0 0 auto";
          const handleCodes = [5, 105, 330, 350, 360];
          if (node.isProperty) {
            if (handleCodes.includes(Number(node.code))) {
              const a = document.createElement("a");
              a.href = "#";
              a.textContent = node.data;
              a.style.textDecoration = "underline";
              a.style.color = "blue";
              a.addEventListener("click", (e) => {
                e.preventDefault();
                if (this.onHandleClick) { this.onHandleClick(node.data); }
              });
              dataDiv.appendChild(a);
            } else { 
              dataDiv.textContent = node.data; 
            }
          } else {
            dataDiv.textContent = node.type || "";
            if (node.handle) {
              const spanHandle = document.createElement("span");
              spanHandle.textContent = " (" + node.handle + ")";
              spanHandle.style.textDecoration = "underline";
              spanHandle.style.color = "blue";
              spanHandle.style.cursor = "pointer";
              spanHandle.addEventListener("click", (e) => {
                e.preventDefault();
                if (this.onHandleClick) { this.onHandleClick(node.handle); }
              });
              dataDiv.appendChild(spanHandle);
            }
            if (this.copyCallback && !node.isProperty) {
              const copyButton = document.createElement("button");
              copyButton.textContent = "Copy";
              copyButton.className = "copy-button";
              copyButton.addEventListener("click", (e) => {
                e.stopPropagation();
                this.copyCallback(node.id);
              });
              dataDiv.appendChild(copyButton);
            }
            if (!node.isProperty && node.properties) {
              const binaryProps = node.properties.filter(prop => Number(prop.code) === 310);
              if (binaryProps.length > 0) {
                const combinedData = binaryProps.map(prop => prop.value).join("");
                const hexButton = document.createElement("button");
                hexButton.textContent = "Hex Viewer";
                hexButton.className = "hex-button";
                hexButton.addEventListener("click", (e) => {
                  e.stopPropagation();
                  if (this.hexViewerCallback) { this.hexViewerCallback(combinedData); }
                });
                dataDiv.appendChild(hexButton);
              }
            }
          }
          row.appendChild(dataDiv);
          
          // Object Count column.
          const objectCountDiv = document.createElement("div");
          objectCountDiv.className = "tree-object-count";
          objectCountDiv.style.width = objectCountWidth + "px";
          objectCountDiv.style.textAlign = "right";
          if (!node.isProperty && node.children && node.children.length) { 
            objectCountDiv.textContent = this.computeObjectCount(node); 
          } else { 
            objectCountDiv.textContent = ""; 
          }
          row.appendChild(objectCountDiv);
          
          // Data Size column.
          const dataSizeDiv = document.createElement("div");
          dataSizeDiv.className = "tree-data-size";
          dataSizeDiv.style.width = dataSizeWidth + "px";
          dataSizeDiv.style.textAlign = "right";
          dataSizeDiv.textContent = this.computeDataSize(node);
          row.appendChild(dataSizeDiv);
          
          fragment.appendChild(row);
        }
        containerElem.appendChild(fragment);
        const bottomSpacer = document.createElement("div");
        const bottomHeight = Math.max(0, fullHeight - (startIndex + visibleCount) * this.itemHeight);
        bottomSpacer.style.height = bottomHeight + "px";
        containerElem.appendChild(bottomSpacer);
        this.content.innerHTML = "";
        this.content.appendChild(containerElem);
        this.syncHeaderWidths();
      }
    }
  </script>
  <!-- Application Code -->
  <script>
    class App {
      constructor() {
        // Define column widths – these will be passed into the TreeDataGrid constructor.
        this.columnWidths = {
          line: 100,
          code: 100,
          type: "*", // Star sizing: takes up remaining space.
          objectCount: 100,
          dataSize: 100
        };
        this.dxfParser = new DxfParser();
        this.treeViewContainer = document.getElementById("treeViewContainer");
        this.treeViewContent = document.getElementById("treeViewContent");
        this.tabs = [];
        this.activeTabId = null;
        this.currentBinaryData = null;
        this.currentDetectedType = null;
        // Create the TreeDataGrid instance and pass columnWidths via the constructor.
        this.myTreeGrid = new TreeDataGrid(this.treeViewContainer, this.treeViewContent, {
          itemHeight: 24,
          copyCallback: (nodeId) => this.handleCopy(nodeId),
          onToggleExpand: (nodeId) => this.handleToggleExpand(nodeId),
          onHandleClick: (handle) => this.handleLinkToHandle(handle),
          onRowSelect: (nodeId) => console.log("Row selected:", nodeId),
          columnWidths: this.columnWidths,
          hexViewerCallback: (combinedHexString) => this.showHexViewer(combinedHexString)
        });
        this.initEventListeners();
      }
      initEventListeners() {
        document.getElementById("parseBtn").addEventListener("click", () => this.handleParse());
        document.getElementById("expandAllBtn").addEventListener("click", () => this.handleExpandAll());
        document.getElementById("collapseAllBtn").addEventListener("click", () => this.handleCollapseAll());
        document.querySelectorAll('.header-cell').forEach(headerCell => {
          headerCell.addEventListener('click', (e) => {
            if (e.target.classList.contains('resizer')) return;
            this.handleHeaderClick(headerCell);
          });
        });
        document.querySelectorAll('.header-cell .resizer').forEach(resizer => {
          resizer.addEventListener('mousedown', (e) => this.handleResizerMouseDown(e));
        });
        this.setupTagInput("codeSearchInput", "code");
        this.setupTagInput("dataSearchInput", "data");
        document.getElementById("searchBtn").addEventListener("click", () => this.handleSearch());
        document.getElementById("clearSearchBtn").addEventListener("click", () => this.handleClearSearch());
        document.getElementById("showCloudOverlayBtn").addEventListener("click", () => {
          this.updateClouds();
          document.getElementById("cloudOverlay").style.display = "block";
        });
        document.getElementById("closeCloudOverlay").addEventListener("click", () => {
          document.getElementById("cloudOverlay").style.display = "none";
        });
        document.getElementById("showStatsOverlayBtn").addEventListener("click", () => {
          this.updateStats();
          document.getElementById("statsOverlay").style.display = "block";
        });
        document.getElementById("closeStatsOverlay").addEventListener("click", () => {
          document.getElementById("statsOverlay").style.display = "none";
        });
        document.getElementById("showDepsOverlayBtn").addEventListener("click", () => {
          this.updateDependencies();
          document.getElementById("depsOverlay").style.display = "block";
        });
        document.getElementById("closeDepsOverlay").addEventListener("click", () => {
          document.getElementById("depsOverlay").style.display = "none";
        });
        document.getElementById("showBinaryObjectsOverlayBtn").addEventListener("click", () => {
          this.showBinaryObjectsOverlay();
        });
        document.getElementById("closeBinaryObjectsOverlay").addEventListener("click", () => {
          document.getElementById("binaryObjectsOverlay").style.display = "none";
        });
        document.getElementById("showHandleMapOverlayBtn").addEventListener("click", () => {
          this.updateHandleMap();
          document.getElementById("handleMapOverlay").style.display = "block";
        });
        document.getElementById("closeHandleMapOverlay").addEventListener("click", () => {
          document.getElementById("handleMapOverlay").style.display = "none";
        });
        // New event listeners for Proxy Objects overlay
        document.getElementById("showProxyObjectsOverlayBtn").addEventListener("click", () => {
          this.showProxyObjectsOverlay();
        });
        document.getElementById("closeProxyObjectsOverlay").addEventListener("click", () => {
          document.getElementById("proxyObjectsOverlay").style.display = "none";
        });
        document.getElementById("dataExactCheckbox").addEventListener("change", () => this.handleSearchOptionChange());
        document.getElementById("dataCaseCheckbox").addEventListener("change", () => this.handleSearchOptionChange());
        document.getElementById("codeSearchInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("dataSearchInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("minLineInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("maxLineInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("goToHandleBtn").addEventListener("click", () => this.handleGoToHandle());
        document.getElementById("backBtn").addEventListener("click", () => this.navigateBack());
        document.getElementById("forwardBtn").addEventListener("click", () => this.navigateForward());
        document.getElementById("clearHistoryBtn").addEventListener("click", () => this.clearNavigationHistory());
        this.treeViewContainer.addEventListener("scroll", (e) => {
          const scrollLeft = e.target.scrollLeft;
          document.getElementById("treeGridHeader").style.transform = "translateX(-" + scrollLeft + "px)";
        });
        window.addEventListener("resize", () => { this.myTreeGrid.updateVisibleNodes(); });
        document.getElementById("closeHexViewerOverlay").addEventListener("click", () => {
          document.getElementById("hexViewerOverlay").style.display = "none";
          document.getElementById("imagePreviewContainer").innerHTML = "";
          document.getElementById("zipContentsContainer").innerHTML = "";
        });
        document.getElementById("saveBinaryBtn").addEventListener("click", () => {
          if (this.currentBinaryData) {
            const typeExtensions = {
              "PNG Image": "png",
              "GIF Image": "gif",
              "JPEG Image": "jpg",
              "BMP Image": "bmp",
              "PDF Document": "pdf",
              "ZIP Archive": "zip"
            };
            let ext = "bin";
            if (this.currentDetectedType && typeExtensions[this.currentDetectedType]) {
              ext = typeExtensions[this.currentDetectedType];
            }
            const blob = new Blob([this.currentBinaryData], { type: "application/octet-stream" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "binary_data." + ext;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }
        });
        document.getElementById("previewImageBtn").addEventListener("click", () => { this.previewImage(); });
        document.querySelectorAll(".backToTreeBtn").forEach(btn => {
          btn.addEventListener("click", (e) => {
            const overlayId = btn.getAttribute("data-overlay");
            document.getElementById(overlayId).style.display = "none";
            this.treeViewContainer.focus();
          });
        });
        const resizer = document.querySelector('.pane-resizer');
        const sidebar = document.querySelector('.sidebar');
        const contentWrapper = document.querySelector('.content-wrapper');
        resizer.addEventListener('mousedown', (e) => {
          e.preventDefault();
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
          function onMouseMove(e) {
            const newWidth = e.clientX - contentWrapper.getBoundingClientRect().left;
            if(newWidth > 150 && newWidth < contentWrapper.clientWidth - 100) {
              sidebar.style.width = newWidth + 'px';
            }
          }
          function onMouseUp() {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          }
        });
      }
      updateEffectiveSearchTerms() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const codeInput = document.getElementById("codeSearchInput");
        const dataInput = document.getElementById("dataSearchInput");
        const codeText = codeInput.value.trim();
        const dataText = dataInput.value.trim();
        const effectiveCodeSearchTerms = activeTab.codeSearchTerms.slice();
        const effectiveDataSearchTerms = activeTab.dataSearchTerms.slice();
        if (codeText !== "" && !effectiveCodeSearchTerms.includes(codeText)) {
          effectiveCodeSearchTerms.push(codeText);
        }
        if (dataText !== "" && !effectiveDataSearchTerms.includes(dataText)) {
          effectiveDataSearchTerms.push(dataText);
        }
        const minLine = document.getElementById("minLineInput").value.trim() !== "" ? parseInt(document.getElementById("minLineInput").value.trim(), 10) : null;
        const maxLine = document.getElementById("maxLineInput").value.trim() !== "" ? parseInt(document.getElementById("maxLineInput").value.trim(), 10) : null;
        activeTab.minLine = minLine;
        activeTab.maxLine = maxLine;
        activeTab.dataExact = document.getElementById("dataExactCheckbox").checked;
        activeTab.dataCase = document.getElementById("dataCaseCheckbox").checked;
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeGrid.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      handleSearchOptionChange() { this.updateEffectiveSearchTerms(); }
      getActiveTab() { return this.tabs.find(t => t.id === this.activeTabId); }
      updateTabUI() {
        const tabContainer = document.getElementById("tabContainer");
        tabContainer.innerHTML = "";
        this.tabs.forEach(tab => {
          const tabElem = document.createElement("div");
          tabElem.className = "tab" + (tab.id === this.activeTabId ? " active" : "");
          tabElem.textContent = tab.name;
          tabElem.dataset.tabId = tab.id;
          tabElem.addEventListener("click", () => {
            this.activeTabId = tab.id;
            document.getElementById("codeSearchInput").value = "";
            document.getElementById("dataSearchInput").value = "";
            this.updateTagContainer("codeSearchTags", tab.codeSearchTerms, "code");
            this.updateTagContainer("dataSearchTags", tab.dataSearchTerms, "data");
            document.getElementById("minLineInput").value = tab.minLine !== null ? tab.minLine : "";
            document.getElementById("maxLineInput").value = tab.maxLine !== null ? tab.maxLine : "";
            document.getElementById("dataExactCheckbox").checked = tab.dataExact || false;
            document.getElementById("dataCaseCheckbox").checked = tab.dataCase || false;
            this.myTreeGrid.setData(tab.currentTreeData);
            this.updateTabUI();
          });
          const closeBtn = document.createElement("span");
          closeBtn.className = "close-tab";
          closeBtn.textContent = "×";
          closeBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            this.tabs = this.tabs.filter(t => t.id !== tab.id);
            if (this.activeTabId === tab.id) { this.activeTabId = this.tabs.length ? this.tabs[0].id : null; }
            this.updateTabUI();
            if (this.activeTabId) { this.myTreeGrid.setData(this.getActiveTab().currentTreeData); }
            else { this.myTreeGrid.setData([]); }
          });
          tabElem.appendChild(closeBtn);
          tabContainer.appendChild(tabElem);
        });
        this.updateNavHistoryUI();
        this.updateNavButtons();
      }
      expandAllNodes(nodes) {
        nodes.forEach(node => {
          if ((node.properties && node.properties.length) || (node.children && node.children.length)) {
            node.expanded = true;
            this.expandAllNodes(node.children);
          }
        });
      }
      collapseAllNodes(nodes) {
        nodes.forEach(node => {
          node.expanded = false;
          this.collapseAllNodes(node.children);
        });
      }
      handleExpandAll() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        this.expandAllNodes(activeTab.originalTreeData);
        if (activeTab.currentSortField) {
          this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
        }
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeGrid.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      handleCollapseAll() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        this.collapseAllNodes(activeTab.originalTreeData);
        if (activeTab.currentSortField) {
          this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
        }
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeGrid.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      handleToggleExpand(nodeId) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const node = this.dxfParser.findNodeById(activeTab.originalTreeData, nodeId);
        if (node) {
          node.expanded = !node.expanded;
          if (activeTab.currentSortField) {
            this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
          }
          activeTab.currentTreeData = this.filterTree(
            activeTab.originalTreeData,
            activeTab.codeSearchTerms,
            activeTab.dataSearchTerms,
            activeTab.dataExact,
            activeTab.dataCase,
            activeTab.minLine,
            activeTab.maxLine
          );
          this.myTreeGrid.setData(activeTab.currentTreeData);
        }
      }
      getSortValue(node, field) {
        if (field === "line") { return node.line ? Number(node.line) : 0; }
        else if (field === "code") {
          if (node.isProperty) {
            const c = parseInt(node.code, 10);
            return isNaN(c) ? Number.MAX_SAFE_INTEGER : c;
          }
          return 0;
        } else if (field === "type") { return node.isProperty ? (node.data || "") : (node.type || ""); }
        else if (field === "objectCount") {
          if (node.isProperty) return 0;
          function countDescendants(n) {
            if (!n.children || n.children.length === 0) return 0;
            let count = 0;
            for (let child of n.children) {
              if (!child.isProperty) {
                count++;
                if (child.children && child.children.length) { count += countDescendants(child); }
              }
            }
            return count;
          }
          return countDescendants(node);
        } else if (field === "dataSize") {
          function computeSize(n) {
            if (n.isProperty) { return n.data ? n.data.length : 0; }
            else {
              let size = n.type ? n.type.length : 0;
              if (n.properties && n.properties.length) {
                for (let prop of n.properties) { size += prop.value ? prop.value.length : 0; }
              }
              if (n.children && n.children.length) {
                for (let child of n.children) { size += computeSize(child); }
              }
              return size;
            }
          }
          return computeSize(node);
        }
        return "";
      }
      sortTreeNodes(nodes, field, ascending) {
        nodes.sort((a, b) => {
          const aVal = this.getSortValue(a, field);
          const bVal = this.getSortValue(b, field);
          if (field === "code" || field === "line" || field === "objectCount" || field === "dataSize") {
            return (aVal - bVal) * (ascending ? 1 : -1);
          } else { return aVal.localeCompare(bVal) * (ascending ? 1 : -1); }
        });
        nodes.forEach(node => {
          if (node.properties && node.properties.length) {
            node.properties.sort((aProp, bProp) => {
              if (field === "code") {
                const aC = parseInt(aProp.code, 10) || 0;
                const bC = parseInt(bProp.code, 10) || 0;
                return (aC - bC) * (ascending ? 1 : -1);
              } else if (field === "line") {
                const aL = aProp.line || 0;
                const bL = bProp.line || 0;
                return (aL - bL) * (ascending ? 1 : -1);
              } else if (field === "type") {
                const aV = aProp.value || "";
                const bV = bProp.value || "";
                return aV.localeCompare(bV) * (ascending ? 1 : -1);
              }
              return 0;
            });
          }
          if (node.children && node.children.length) { this.sortTreeNodes(node.children, field, ascending); }
        });
      }
      handleHeaderClick(headerCell) {
        const field = headerCell.getAttribute('data-field');
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        let currentSort = headerCell.getAttribute('data-sort');
        let ascending = true;
        if (currentSort === 'asc') {
          ascending = false;
          headerCell.setAttribute('data-sort', 'desc');
          headerCell.querySelector('.sort-indicator').textContent = ' ▼';
        } else {
          ascending = true;
          headerCell.setAttribute('data-sort', 'asc');
          headerCell.querySelector('.sort-indicator').textContent = ' ▲';
        }
        activeTab.currentSortField = field;
        activeTab.currentSortAscending = ascending;
        document.querySelectorAll('.header-cell').forEach(cell => {
          if (cell !== headerCell) {
            cell.setAttribute('data-sort', 'none');
            cell.querySelector('.sort-indicator').textContent = '';
          }
        });
        this.sortTreeNodes(activeTab.originalTreeData, field, ascending);
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeGrid.setData(activeTab.currentTreeData);
      }
      handleResizerMouseDown(e) {
        e.stopPropagation();
        const headerCell = e.target.parentElement;
        const field = headerCell.getAttribute('data-field');
        const startX = e.clientX;
        const startWidth = headerCell.offsetWidth;
        const onMouseMove = (eMove) => {
          const newWidth = startWidth + (eMove.clientX - startX);
          this.columnWidths[field] = newWidth;
          headerCell.style.width = newWidth + "px";
          headerCell.style.flex = "none";
          this.myTreeGrid.updateVisibleNodes();
        };
        const onMouseUp = () => {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        };
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      }
      filterTree(objects, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine) {
        const filtered = [];
        objects.forEach(obj => {
          const filteredObj = this.filterObject(obj, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine);
          if (filteredObj !== null) { filtered.push(filteredObj); }
        });
        return filtered;
      }
      filterObject(obj, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine) {
        let nodeLine = parseInt(obj.line, 10);
        let lineMatches = true;
        if (minLine != null && !isNaN(minLine)) {
          if (isNaN(nodeLine) || nodeLine < minLine) lineMatches = false;
        }
        if (maxLine != null && !isNaN(maxLine)) {
          if (isNaN(nodeLine) || nodeLine > maxLine) lineMatches = false;
        }
        const filteredProperties = obj.properties.filter(prop => {
          let propLine = parseInt(prop.line, 10);
          if (minLine != null && !isNaN(minLine)) {
            if (isNaN(propLine) || propLine < minLine) return false;
          }
          if (maxLine != null && !isNaN(maxLine)) {
            if (isNaN(propLine) || propLine > maxLine) return false;
          }
          const codeMatch = (codeTerms.length === 0) ||
            codeTerms.some(term => String(prop.code) === term);
          let dataMatch = true;
          if (dataTerms.length > 0) {
            if (dataExact) {
              dataMatch = dataTerms.some(term =>
                dataCase ? (prop.value === term)
                         : (prop.value.toLowerCase() === term.toLowerCase())
              );
            } else {
              dataMatch = dataTerms.some(term =>
                dataCase ? prop.value.includes(term)
                         : prop.value.toLowerCase().includes(term.toLowerCase())
              );
            }
          }
          return codeMatch && dataMatch;
        });
        const filteredChildren = obj.children
          .map(child => this.filterObject(child, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine))
          .filter(child => child !== null);
        const codeFilterActive = codeTerms.length > 0;
        const dataFilterActive = dataTerms.length > 0;
        let typeMatchesData = false;
        if (dataFilterActive) {
          if (dataExact) {
            typeMatchesData = dataTerms.some(term =>
              dataCase ? (obj.type === term)
                       : (obj.type.toLowerCase() === term.toLowerCase())
            );
          } else {
            typeMatchesData = dataTerms.some(term =>
              dataCase ? obj.type.includes(term)
                       : obj.type.toLowerCase().includes(term.toLowerCase())
            );
          }
        }
        if (!codeFilterActive && !dataFilterActive) {
          if (!lineMatches && filteredProperties.length === 0 && filteredChildren.length === 0) {
            return null;
          }
          return {
            ...obj,
            properties: filteredProperties,
            children: filteredChildren
          };
        }
        if (codeFilterActive && filteredProperties.length === 0 && filteredChildren.length === 0) {
          return null;
        }
        if (dataFilterActive && !(typeMatchesData || filteredProperties.length > 0 || filteredChildren.length > 0)) {
          return null;
        }
        if (!lineMatches && filteredProperties.length === 0 && filteredChildren.length === 0) {
          return null;
        }
        return {
          ...obj,
          properties: filteredProperties,
          children: filteredChildren
        };
      }
      handleCopy(nodeId) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const node = this.dxfParser.findNodeById(activeTab.originalTreeData, nodeId);
        if (!node) { alert("Node not found in original data."); return; }
        const serialized = this.dxfParser.serializeNode(node);
        navigator.clipboard.writeText(serialized).then(() => {
          alert("Copied node to clipboard as valid DXF tags.");
        }, () => {
          alert("Failed to copy to clipboard.");
        });
      }
      async parseFileStream(file) {
        const reader = file.stream().getReader();
        const decoder = new TextDecoder("ascii");
        let leftover = "";
        const lines = [];
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          const chunkText = decoder.decode(value, { stream: true });
          const text = leftover + chunkText;
          const parts = text.split(/\r?\n/);
          leftover = parts.pop();
          lines.push(...parts);
        }
        if (leftover) { lines.push(leftover); }
        const tags = this.dxfParser.parseDxfLines(lines);
        const grouped = this.dxfParser.groupObjects(tags, 0);
        return grouped.objects;
      }
      handleParse() {
        const fileInput = document.getElementById("fileInput");
        const useStream = document.getElementById("useStreamCheckbox").checked;
        if (!fileInput.files || fileInput.files.length === 0) {
          alert("Please select at least one DXF file.");
          return;
        }
        Array.from(fileInput.files).forEach(file => {
          if (useStream && file.stream) {
            this.parseFileStream(file)
              .then(objects => {
                const newTab = {
                  id: Date.now() + Math.random(),
                  name: file.name,
                  originalTreeData: objects,
                  currentTreeData: objects,
                  codeSearchTerms: [],
                  dataSearchTerms: [],
                  currentSortField: "line",
                  currentSortAscending: true,
                  minLine: null,
                  maxLine: null,
                  dataExact: false,
                  dataCase: false,
                  navigationHistory: [],
                  currentHistoryIndex: -1
                };
                this.tabs.push(newTab);
                this.activeTabId = newTab.id;
                this.updateTabUI();
                this.myTreeGrid.setData(newTab.currentTreeData);
              })
              .catch(err => {
                console.error("Error during streamed parsing:", err);
                alert("Error during streamed parsing.");
              });
          } else {
            const reader = new FileReader();
            reader.onload = (event) => {
              const text = event.target.result;
              const objects = this.dxfParser.parse(text);
              const newTab = {
                id: Date.now() + Math.random(),
                name: file.name,
                originalTreeData: objects,
                currentTreeData: objects,
                codeSearchTerms: [],
                dataSearchTerms: [],
                currentSortField: "line",
                currentSortAscending: true,
                minLine: null,
                maxLine: null,
                dataExact: false,
                dataCase: false,
                navigationHistory: [],
                currentHistoryIndex: -1
              };
              this.tabs.push(newTab);
              this.activeTabId = newTab.id;
              this.updateTabUI();
              this.myTreeGrid.setData(newTab.currentTreeData);
            };
            reader.readAsText(file, "ascii");
          }
        });
      }
      createTagElement(text, type) {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = text;
        const removeBtn = document.createElement("span");
        removeBtn.className = "remove";
        removeBtn.textContent = "×";
        removeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          const activeTab = this.getActiveTab();
          if (!activeTab) return;
          if (type === "code") {
            activeTab.codeSearchTerms = activeTab.codeSearchTerms.filter(term => term !== text);
            this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
          } else if (type === "data") {
            activeTab.dataSearchTerms = activeTab.dataSearchTerms.filter(term => term !== text);
            this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
          }
          activeTab.currentTreeData = this.filterTree(
            activeTab.originalTreeData,
            activeTab.codeSearchTerms,
            activeTab.dataSearchTerms,
            activeTab.dataExact,
            activeTab.dataCase,
            activeTab.minLine,
            activeTab.maxLine
          );
          this.myTreeGrid.setData(activeTab.currentTreeData);
          this.treeViewContainer.scrollTop = 0;
        });
        tag.appendChild(removeBtn);
        return tag;
      }
      updateTagContainer(containerId, termsArray, type) {
        const container = document.getElementById(containerId);
        Array.from(container.querySelectorAll(".tag")).forEach(tag => tag.remove());
        termsArray.forEach(term => {
          const tagElem = this.createTagElement(term, type);
          container.insertBefore(tagElem, container.querySelector("input"));
        });
      }
      setupTagInput(inputId, type) {
        const input = document.getElementById(inputId);
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === ",") {
            e.preventDefault();
            const text = input.value.trim();
            if (text !== "") {
              const activeTab = this.getActiveTab();
              if (!activeTab) return;
              if (type === "code") {
                if (!activeTab.codeSearchTerms.includes(text)) {
                  activeTab.codeSearchTerms.push(text);
                }
                this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
              } else {
                if (!activeTab.dataSearchTerms.includes(text)) {
                  activeTab.dataSearchTerms.push(text);
                }
                this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
              }
              input.value = "";
              this.updateEffectiveSearchTerms();
            }
          }
        });
        input.addEventListener("blur", () => {
          const text = input.value.trim();
          if (text !== "") {
            const activeTab = this.getActiveTab();
            if (!activeTab) return;
            if (type === "code") {
              if (!activeTab.codeSearchTerms.includes(text)) {
                activeTab.codeSearchTerms.push(text);
              }
              this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
            } else {
              if (!activeTab.dataSearchTerms.includes(text)) {
                activeTab.dataSearchTerms.push(text);
              }
              this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
            }
            input.value = "";
            this.updateEffectiveSearchTerms();
          }
        });
      }
      handleSearch() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const codeInput = document.getElementById("codeSearchInput");
        const dataInput = document.getElementById("dataSearchInput");
        if (codeInput.value.trim() !== "") {
          const text = codeInput.value.trim();
          if (!activeTab.codeSearchTerms.includes(text)) {
            activeTab.codeSearchTerms.push(text);
          }
          this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
          codeInput.value = "";
        }
        if (dataInput.value.trim() !== "") {
          const text = dataInput.value.trim();
          if (!activeTab.dataSearchTerms.includes(text)) {
            activeTab.dataSearchTerms.push(text);
          }
          this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
          dataInput.value = "";
        }
        this.updateEffectiveSearchTerms();
      }
      handleClearSearch() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        activeTab.codeSearchTerms = [];
        activeTab.dataSearchTerms = [];
        activeTab.minLine = null;
        activeTab.maxLine = null;
        this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
        this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
        document.getElementById("codeSearchInput").value = "";
        document.getElementById("dataSearchInput").value = "";
        document.getElementById("dataExactCheckbox").checked = false;
        document.getElementById("dataCaseCheckbox").checked = false;
        document.getElementById("minLineInput").value = "";
        document.getElementById("maxLineInput").value = "";
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          false,
          false,
          null,
          null
        );
        this.myTreeGrid.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      findPathByHandle(nodes, handle) {
        for (const node of nodes) {
          if (node.handle && node.handle.toUpperCase() === handle.toUpperCase()) {
            return [node];
          }
          if (node.children && node.children.length) {
            const subPath = this.findPathByHandle(node.children, handle);
            if (subPath) { return [node, ...subPath]; }
          }
        }
        return null;
      }
      navigateToHandle(handle, addHistory = true) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const path = this.findPathByHandle(activeTab.originalTreeData, handle);
        if (!path) { alert("Definition not found for handle: " + handle); return; }
        path.forEach(node => node.expanded = true);
        activeTab.currentTreeData = activeTab.originalTreeData;
        this.myTreeGrid.setData(activeTab.currentTreeData);
        setTimeout(() => {
          const targetNodeId = path[path.length - 1].id;
          const flatData = this.myTreeGrid.flatData;
          const targetIndex = flatData.findIndex(item => String(item.node.id) === String(targetNodeId));
          if (targetIndex >= 0) {
            this.treeViewContainer.scrollTop = targetIndex * this.myTreeGrid.itemHeight;
            const element = this.treeViewContent.querySelector(`[data-id="${targetNodeId}"]`);
            if (element) {
              element.style.backgroundColor = "yellow";
              setTimeout(() => { element.style.backgroundColor = ""; }, 2000);
            }
          }
        }, 300);
        if (addHistory) {
          if (activeTab.currentHistoryIndex < activeTab.navigationHistory.length - 1) {
            activeTab.navigationHistory.splice(activeTab.currentHistoryIndex + 1);
          }
          activeTab.navigationHistory.push(handle);
          activeTab.currentHistoryIndex = activeTab.navigationHistory.length - 1;
          this.updateNavHistoryUI();
          this.updateNavButtons();
        }
      }
      handleGoToHandle() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const handleValue = document.getElementById("handleSearchInput").value.trim();
        if (!handleValue) return;
        this.navigateToHandle(handleValue, true);
      }
      handleLinkToHandle(handle) { this.navigateToHandle(handle, true); }
      updateNavHistoryUI() {
        const activeTab = this.getActiveTab();
        const listContainer = document.getElementById("navHistoryList");
        listContainer.innerHTML = "";
        if (!activeTab) return;
        activeTab.navigationHistory.forEach((handle, index) => {
          const span = document.createElement("span");
          span.textContent = handle;
          span.style.cursor = "pointer";
          span.style.marginRight = "8px";
          if (index === activeTab.currentHistoryIndex) {
            span.style.fontWeight = "bold";
            span.style.textDecoration = "underline";
          }
          span.addEventListener("click", () => {
            activeTab.currentHistoryIndex = index;
            this.navigateToHandle(handle, false);
            this.updateNavHistoryUI();
            this.updateNavButtons();
          });
          listContainer.appendChild(span);
        });
      }
      updateNavButtons() {
        const activeTab = this.getActiveTab();
        const backBtn = document.getElementById("backBtn");
        const forwardBtn = document.getElementById("forwardBtn");
        if (!activeTab) { backBtn.disabled = true; forwardBtn.disabled = true; return; }
        backBtn.disabled = activeTab.currentHistoryIndex <= 0;
        forwardBtn.disabled = activeTab.currentHistoryIndex >= activeTab.navigationHistory.length - 1;
      }
      navigateBack() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        if (activeTab.currentHistoryIndex > 0) {
          activeTab.currentHistoryIndex--;
          const handle = activeTab.navigationHistory[activeTab.currentHistoryIndex];
          this.navigateToHandle(handle, false);
          this.updateNavHistoryUI();
          this.updateNavButtons();
        }
      }
      navigateForward() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        if (activeTab.currentHistoryIndex < activeTab.navigationHistory.length - 1) {
          activeTab.currentHistoryIndex++;
          const handle = activeTab.navigationHistory[activeTab.currentHistoryIndex];
          this.navigateToHandle(handle, false);
          this.updateNavHistoryUI();
          this.updateNavButtons();
        }
      }
      clearNavigationHistory() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        activeTab.navigationHistory = [];
        activeTab.currentHistoryIndex = -1;
        this.updateNavHistoryUI();
        this.updateNavButtons();
      }
      updateClouds() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayObjectCloud").innerHTML = "";
          document.getElementById("overlayCodeCloud").innerHTML = "";
          return;
        }
        const objectCounts = {};
        const codeCounts = {};
        function traverse(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty) {
              objectCounts[node.type] = (objectCounts[node.type] || 0) + 1;
              node.properties.forEach(prop => {
                codeCounts[prop.code] = (codeCounts[prop.code] || 0) + 1;
              });
              if (node.children && node.children.length > 0) { traverse(node.children); }
            }
          });
        }
        traverse(activeTab.originalTreeData);
        const populateCloud = (element, counts, minFont, maxFont, cloudType) => {
          element.innerHTML = "";
          const maxCount = Math.max(...Object.values(counts), 1);
          for (const key in counts) {
            const count = counts[key];
            const fontSize = minFont + ((count / maxCount) * (maxFont - minFont));
            const span = document.createElement("span");
            span.className = "cloud-tag";
            span.style.fontSize = fontSize + "px";
            span.textContent = `${key} (${count})`;
            span.style.cursor = "pointer";
            span.addEventListener("click", () => {
              document.getElementById("cloudOverlay").style.display = "none";
              this.handleCloudTagClick(cloudType, key);
            });
            element.appendChild(span);
          }
        };
        const minFont = 12, maxFont = 36;
        const overlayObjectCloudElem = document.getElementById("overlayObjectCloud");
        const overlayCodeCloudElem = document.getElementById("overlayCodeCloud");
        populateCloud(overlayObjectCloudElem, objectCounts, minFont, maxFont, "object");
        populateCloud(overlayCodeCloudElem, codeCounts, minFont, maxFont, "code");
      }
      handleCloudTagClick(cloudType, key) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        if (cloudType === "object") {
          function search(nodes) {
            for (const node of nodes) {
              if (node.type && node.type.toLowerCase().includes(key.toLowerCase())) {
                return node;
              }
              if (node.children && node.children.length) {
                const result = search(node.children);
                if (result) return result;
              }
            }
            return null;
          }
          const found = search(activeTab.originalTreeData);
          if (found && found.handle) {
            this.handleLinkToHandle(found.handle);
          } else {
            alert("No matching object found for type: " + key);
          }
        } else if (cloudType === "code") {
          function search(nodes) {
            for (const node of nodes) {
              if (node.properties && node.properties.length) {
                for (const prop of node.properties) {
                  if (String(prop.code) === key) {
                    return node;
                  }
                }
              }
              if (node.children && node.children.length) {
                const result = search(node.children);
                if (result) return result;
              }
            }
            return null;
          }
          const found = search(activeTab.originalTreeData);
          if (found && found.handle) {
            this.handleLinkToHandle(found.handle);
          } else {
            alert("No matching object found for code: " + key);
          }
        }
      }
      updateStats() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayStatsContent").innerHTML = "No DXF data loaded.";
          return;
        }
        function computeStats(nodes, depth = 1) {
          let stats = {
            totalObjects: 0,
            totalProperties: 0,
            maxDepth: depth,
            totalDataSize: 0,
            countByType: {}
          };
          nodes.forEach(node => {
            if (!node.isProperty) {
              stats.totalObjects++;
              stats.countByType[node.type] = (stats.countByType[node.type] || 0) + 1;
              let nodeDataSize = node.type ? node.type.length : 0;
              if (node.properties && node.properties.length) {
                stats.totalProperties += node.properties.length;
                node.properties.forEach(prop => { nodeDataSize += prop.value ? prop.value.length : 0; });
              }
              stats.totalDataSize += nodeDataSize;
              if (node.children && node.children.length) {
                const childStats = computeStats(node.children, depth + 1);
                stats.totalObjects += childStats.totalObjects;
                stats.totalProperties += childStats.totalProperties;
                stats.totalDataSize += childStats.totalDataSize;
                for (let type in childStats.countByType) {
                  stats.countByType[type] = (stats.countByType[type] || 0) + childStats.countByType[type];
                }
                if (childStats.maxDepth > stats.maxDepth) { stats.maxDepth = childStats.maxDepth; }
              }
            }
          });
          return stats;
        }
        const stats = computeStats(activeTab.originalTreeData);
        const avgProps = stats.totalObjects > 0 ? (stats.totalProperties / stats.totalObjects).toFixed(2) : 0;
        const statsHtml = `
          <ul>
            <li><strong>Total Objects:</strong> ${stats.totalObjects}</li>
            <li><strong>Total Properties:</strong> ${stats.totalProperties}</li>
            <li><strong>Maximum Nesting Depth:</strong> ${stats.maxDepth}</li>
            <li><strong>Total Data Size:</strong> ${stats.totalDataSize} characters</li>
            <li><strong>Average Properties per Object:</strong> ${avgProps}</li>
            <li><strong>Object Type Counts:</strong>
              <ul>
                ${Object.entries(stats.countByType)
                  .map(([type, count]) => `<li><a href="#" class="stats-type" data-type="${type}">${type}: ${count}</a></li>`)
                  .join('')}
              </ul>
            </li>
          </ul>
        `;
        document.getElementById("overlayStatsContent").innerHTML = statsHtml;
        document.querySelectorAll(".stats-type").forEach(link => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            const type = link.getAttribute("data-type");
            document.getElementById("statsOverlay").style.display = "none";
            this.handleCloudTagClick("object", type);
          });
        });
      }
      updateDependencies() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayDepsContent").innerHTML = "No DXF data loaded.";
          return;
        }
        const dependencyTypes = ["LTYPE", "STYLE", "APPID", "LAYER", "DIMSTYLE", "VPORT", "XREF", "SHAPE"];
        const dependencies = {};
        dependencyTypes.forEach(type => dependencies[type] = []);
        function traverse(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty) {
              const type = node.type.toUpperCase();
              if (dependencyTypes.includes(type)) { dependencies[type].push(node); }
              if (node.children && node.children.length) { traverse(node.children); }
            }
          });
        }
        traverse(activeTab.originalTreeData);
        let html = "";
        dependencyTypes.forEach(depType => {
          if (dependencies[depType].length > 0) {
            html += `<h3>${depType} (${dependencies[depType].length})</h3><ul>`;
            dependencies[depType].forEach(dep => {
              let depInfo = `${dep.type} (Line ${dep.line})`;
              if (dep.properties && dep.properties.length) {
                const propSummary = dep.properties.map(p => `${p.code}:${p.value}`).join(", ");
                depInfo += ` [${propSummary}]`;
              }
              if (dep.handle) {
                html += `<li><a href="#" class="dep-link" data-handle="${dep.handle}">${depInfo}</a></li>`;
              } else {
                html += `<li>${depInfo}</li>`;
              }
            });
            html += "</ul>";
          }
        });
        if (!html) { html = "No external dependency objects found."; }
        document.getElementById("overlayDepsContent").innerHTML = html;
        const self = this;
        document.querySelectorAll(".dep-link").forEach(link => {
          link.addEventListener("click", function(e) {
            e.preventDefault();
            document.getElementById("depsOverlay").style.display = "none";
            const handle = this.getAttribute("data-handle");
            self.handleLinkToHandle(handle);
          });
        });
      }
      showHexViewer(combinedHexString) {
        const binaryArray = hexStringToByteArray(combinedHexString);
        const dump = hexDump(binaryArray);
        const hexContentElem = document.getElementById("hexContent");
        const headerInfoElem = document.getElementById("headerInfo");
        hexContentElem.textContent = dump;
        const detectedType = detectHeader(binaryArray);
        headerInfoElem.textContent = detectedType ? "Detected file type: " + detectedType : "Unknown file type";
        this.currentBinaryData = binaryArray;
        this.currentDetectedType = detectedType;
        document.getElementById("hexViewerOverlay").style.display = "block";
        if (detectedType === "ZIP Archive") {
          document.getElementById("imagePreviewContainer").innerHTML = "";
          this.browseZip(binaryArray);
        } else if (detectedType === "PNG Image" || detectedType === "GIF Image" ||
                   detectedType === "JPEG Image" || detectedType === "BMP Image") {
          this.previewImage();
          document.getElementById("zipContentsContainer").innerHTML = "";
        } else {
          document.getElementById("imagePreviewContainer").innerHTML = "";
          document.getElementById("zipContentsContainer").innerHTML = "";
        }
      }
      previewImage() {
        if (!this.currentBinaryData) { alert("No binary data available."); return; }
        const imageTypes = {
          "PNG Image": "image/png",
          "GIF Image": "image/gif",
          "JPEG Image": "image/jpeg",
          "BMP Image": "image/bmp"
        };
        if (!this.currentDetectedType || !imageTypes[this.currentDetectedType]) {
          alert("Preview not available for this file type.");
          return;
        }
        const mimeType = imageTypes[this.currentDetectedType];
        const blob = new Blob([this.currentBinaryData], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const container = document.getElementById("imagePreviewContainer");
        container.innerHTML = "";
        const img = document.createElement("img");
        img.src = url;
        img.style.maxWidth = "100%";
        img.style.maxHeight = "300px";
        container.appendChild(img);
      }
      browseZip(binaryArray) {
        const blob = new Blob([binaryArray], { type: "application/zip" });
        JSZip.loadAsync(blob).then(zip => {
          const container = document.getElementById("zipContentsContainer");
          container.innerHTML = "<h3>ZIP Contents</h3>";
          Object.keys(zip.files).forEach(filename => {
            const file = zip.files[filename];
            const fileDiv = document.createElement("div");
            fileDiv.style.borderBottom = "1px solid #ccc";
            fileDiv.style.padding = "5px";
            fileDiv.innerHTML = `<strong>${filename}</strong> (${file._data.uncompressedSize || 0} bytes) `;
            if (!file.dir) {
              const previewBtn = document.createElement("button");
              previewBtn.textContent = "Preview";
              previewBtn.addEventListener("click", () => {
                const lowerName = filename.toLowerCase();
                if (lowerName.endsWith(".png") || lowerName.endsWith(".jpg") ||
                    lowerName.endsWith(".jpeg") || lowerName.endsWith(".gif") ||
                    lowerName.endsWith(".bmp")) {
                  file.async("base64").then(content => {
                    const img = document.createElement("img");
                    let mimeType = "image/png";
                    if(lowerName.endsWith(".jpg") || lowerName.endsWith(".jpeg")) mimeType = "image/jpeg";
                    else if(lowerName.endsWith(".gif")) mimeType = "image/gif";
                    else if(lowerName.endsWith(".bmp")) mimeType = "image/bmp";
                    img.src = `data:${mimeType};base64,${content}`;
                    const previewContainer = document.createElement("div");
                    previewContainer.style.marginTop = "10px";
                    previewContainer.appendChild(img);
                    fileDiv.appendChild(previewContainer);
                  });
                } else {
                  file.async("string").then(content => {
                    const pre = document.createElement("pre");
                    pre.textContent = content;
                    pre.style.maxHeight = "200px";
                    pre.style.overflow = "auto";
                    fileDiv.appendChild(pre);
                  });
                }
              });
              fileDiv.appendChild(previewBtn);
              const downloadBtn = document.createElement("button");
              downloadBtn.textContent = "Download";
              downloadBtn.addEventListener("click", () => {
                file.async("blob").then(blobContent => {
                  const url = URL.createObjectURL(blobContent);
                  const a = document.createElement("a");
                  a.href = url;
                  a.download = filename;
                  document.body.appendChild(a);
                  a.click();
                  document.body.removeChild(a);
                  URL.revokeObjectURL(url);
                });
              });
              fileDiv.appendChild(downloadBtn);
            }
            container.appendChild(fileDiv);
          });
        }).catch(err => {
          alert("Failed to load ZIP file: " + err);
        });
      }
      updateHandleMap() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayHandleMapContent").innerHTML = "No DXF data loaded.";
          return;
        }
        const nodesByHandle = {};
        function traverse(nodes) {
          nodes.forEach(node => {
            if (node.handle) {
              nodesByHandle[node.handle] = { handle: node.handle, type: node.type, line: node.line, children: [] };
            }
            if (node.children && node.children.length > 0) { traverse(node.children); }
          });
        }
        traverse(activeTab.originalTreeData);
        const roots = [];
        function assignOwner(nodes) {
          nodes.forEach(node => {
            const current = node.handle ? nodesByHandle[node.handle] : null;
            const ownerProp = node.properties.find(prop => Number(prop.code) === 330);
            if (ownerProp && ownerProp.value && nodesByHandle[ownerProp.value]) {
              const parent = nodesByHandle[ownerProp.value];
              if (current) { parent.children.push(current); }
            } else {
              if (current) { roots.push(current); }
            }
            if (node.children && node.children.length > 0) { assignOwner(node.children); }
          });
        }
        assignOwner(activeTab.originalTreeData);
        const uniqueRoots = Array.from(new Set(roots));
        function buildList(items) {
          const ul = document.createElement("ul");
          items.forEach(item => {
            const li = document.createElement("li");
            if (item.handle) {
              const a = document.createElement("a");
              a.href = "#";
              a.textContent = `Handle: ${item.handle} | Type: ${item.type} | Line: ${item.line}`;
              a.addEventListener("click", (e) => {
                e.preventDefault();
                document.getElementById("handleMapOverlay").style.display = "none";
                this.handleLinkToHandle(item.handle);
              });
              li.appendChild(a);
            } else {
              li.textContent = `Type: ${item.type} | Line: ${item.line}`;
            }
            if (item.children && item.children.length > 0) {
              li.appendChild(buildList.call(this, item.children));
            }
            ul.appendChild(li);
          });
          return ul;
        }
        const container = document.getElementById("overlayHandleMapContent");
        container.innerHTML = "";
        if (uniqueRoots.length === 0) {
          container.textContent = "No owner relationships (code 330) found.";
        } else {
          container.appendChild(buildList.call(this, uniqueRoots));
        }
      }
      showBinaryObjectsOverlay() {
        const activeTab = this.getActiveTab();
        const listContainer = document.getElementById("binaryObjectsList");
        listContainer.innerHTML = "";
        if (!activeTab) {
          listContainer.textContent = "No DXF data loaded.";
          document.getElementById("binaryObjectsOverlay").style.display = "block";
          return;
        }
        let binaryNodes = [];
        function findBinaryNodes(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty && node.properties) {
              const binaryProps = node.properties.filter(prop => Number(prop.code) === 310);
              if (binaryProps.length > 0) { binaryNodes.push(node); }
            }
            if (node.children && node.children.length > 0) { findBinaryNodes(node.children); }
          });
        }
        findBinaryNodes(activeTab.originalTreeData);
        if (binaryNodes.length === 0) {
          listContainer.textContent = "No binary data objects found.";
        } else {
          binaryNodes.forEach(node => {
            const div = document.createElement("div");
            div.style.borderBottom = "1px solid #ccc";
            div.style.padding = "5px";
            let info = `Type: ${node.type} | Line: ${node.line}`;
            if (node.handle) { info += ` | Handle: ${node.handle}`; }
            const infoSpan = document.createElement("span");
            infoSpan.textContent = info + " ";
            div.appendChild(infoSpan);
            const binaryProps = node.properties.filter(prop => Number(prop.code) === 310);
            const combinedData = binaryProps.map(prop => prop.value).join("");
            const hexBtn = document.createElement("button");
            hexBtn.textContent = "Hex Viewer";
            hexBtn.addEventListener("click", () => { this.showHexViewer(combinedData); });
            div.appendChild(hexBtn);
            if (node.handle) {
              const showLink = document.createElement("a");
              showLink.href = "#";
              showLink.textContent = "Show in Tree";
              showLink.style.marginLeft = "10px";
              showLink.addEventListener("click", (e) => {
                e.preventDefault();
                document.getElementById("binaryObjectsOverlay").style.display = "none";
                this.handleLinkToHandle(node.handle);
              });
              div.appendChild(showLink);
            }
            listContainer.appendChild(div);
          });
        }
        document.getElementById("binaryObjectsOverlay").style.display = "block";
      }
      // New method to analyze proxy objects in detail.
      analyzeProxyObject(node) {
        let html = `<h3>Proxy Object Analysis</h3>`;
        html += `<p><strong>Total Properties:</strong> ${node.properties.length}. `;
        html += `<strong>Total Child Objects:</strong> ${node.children ? node.children.length : 0}.</p>`;
        html += `<table border="1" cellspacing="0" cellpadding="4" style="border-collapse: collapse; width: 100%;">`;
        html += `<tr><th>DXF Code</th><th>Value</th></tr>`;
        node.properties.forEach(prop => {
          if (Number(prop.code) === 330) {
            html += `<tr><td>${prop.code}</td><td><a href="#" onclick="window.app.handleLinkToHandle('${prop.value}'); return false;">${prop.value}</a></td></tr>`;
          } else if (Number(prop.code) === 310) {
            html += `<tr><td>${prop.code}</td><td>Binary Data (length: ${prop.value.length})</td></tr>`;
          } else {
            html += `<tr><td>${prop.code}</td><td>${prop.value}</td></tr>`;
          }
        });
        html += `</table>`;
        // If there are any binary segments (code 310), show combined information.
        const binaryProps = node.properties.filter(p => Number(p.code) === 310);
        if (binaryProps.length > 0) {
          const combinedData = binaryProps.map(p => p.value).join("");
          html += `<p><strong>Combined Binary Data:</strong> ${combinedData.length} characters. <a href="#" onclick="window.app.showHexViewer('${combinedData}'); return false;">View Hex</a></p>`;
        }
        // If there are child objects, list them recursively.
        if (node.children && node.children.length > 0) {
          html += `<h4>Child Objects:</h4>`;
          html += `<ul>`;
          node.children.forEach(child => {
            html += `<li>`;
            html += `Type: ${child.type} (Line: ${child.line}`;
            if (child.handle) {
              html += `, Handle: <a href="#" onclick="window.app.handleLinkToHandle('${child.handle}'); return false;">${child.handle}</a>`;
            }
            html += `)`;
            // Recursively include analysis for child objects.
            html += window.app.analyzeProxyObject(child);
            html += `</li>`;
          });
          html += `</ul>`;
        }
        return html;
      }
      // Updated method for Proxy Objects overlay.
      showProxyObjectsOverlay() {
        const activeTab = this.getActiveTab();
        const listContainer = document.getElementById("proxyObjectsList");
        listContainer.innerHTML = "";
        if (!activeTab) {
          listContainer.textContent = "No DXF data loaded.";
          document.getElementById("proxyObjectsOverlay").style.display = "block";
          return;
        }
        let proxyNodes = [];
        function findProxyNodes(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty && node.type && node.type.toUpperCase() === "ACAD_PROXY_OBJECT") {
              proxyNodes.push(node);
            }
            if (node.children && node.children.length > 0) { findProxyNodes(node.children); }
          });
        }
        findProxyNodes(activeTab.originalTreeData);
        if (proxyNodes.length === 0) {
          listContainer.textContent = "No proxy objects found.";
        } else {
          proxyNodes.forEach(node => {
            const div = document.createElement("div");
            div.style.borderBottom = "1px solid #ccc";
            div.style.padding = "5px";
            let info = `Type: ${node.type} | Line: ${node.line}`;
            if (node.handle) { info += ` | Handle: ${node.handle}`; }
            const infoSpan = document.createElement("span");
            infoSpan.textContent = info + " ";
            div.appendChild(infoSpan);
            // Copy button
            const copyBtn = document.createElement("button");
            copyBtn.textContent = "Copy DXF";
            copyBtn.addEventListener("click", () => {
              const serialized = this.dxfParser.serializeNode(node);
              navigator.clipboard.writeText(serialized).then(() => {
                alert("Copied proxy object to clipboard as valid DXF tags.");
              }, () => {
                alert("Failed to copy to clipboard.");
              });
            });
            div.appendChild(copyBtn);
            // Existing "Show Details" toggle button (raw DXF text)
            const detailsBtn = document.createElement("button");
            detailsBtn.textContent = "Show Details";
            const detailsDiv = document.createElement("pre");
            detailsDiv.style.display = "none";
            detailsDiv.style.background = "#f9f9f9";
            detailsDiv.style.padding = "5px";
            detailsDiv.textContent = this.dxfParser.serializeNode(node);
            detailsBtn.addEventListener("click", () => {
              if (detailsDiv.style.display === "none") {
                detailsDiv.style.display = "block";
                detailsBtn.textContent = "Hide Details";
              } else {
                detailsDiv.style.display = "none";
                detailsBtn.textContent = "Show Details";
              }
            });
            div.appendChild(detailsBtn);
            div.appendChild(detailsDiv);
            // New "Analyze" button for structured analysis
            const analyzeBtn = document.createElement("button");
            analyzeBtn.textContent = "Analyze";
            const analyzeDiv = document.createElement("div");
            analyzeDiv.style.display = "none";
            analyzeDiv.style.background = "#eef";
            analyzeDiv.style.padding = "5px";
            analyzeBtn.addEventListener("click", () => {
              if (analyzeDiv.style.display === "none") {
                analyzeDiv.innerHTML = window.app.analyzeProxyObject(node);
                analyzeDiv.style.display = "block";
                analyzeBtn.textContent = "Hide Analysis";
              } else {
                analyzeDiv.style.display = "none";
                analyzeBtn.textContent = "Analyze";
              }
            });
            div.appendChild(analyzeBtn);
            div.appendChild(analyzeDiv);
            // "Show in Tree" link if a handle exists
            if (node.handle) {
              const showLink = document.createElement("a");
              showLink.href = "#";
              showLink.textContent = "Show in Tree";
              showLink.style.marginLeft = "10px";
              showLink.addEventListener("click", (e) => {
                e.preventDefault();
                document.getElementById("proxyObjectsOverlay").style.display = "none";
                this.handleLinkToHandle(node.handle);
              });
              div.appendChild(showLink);
            }
            listContainer.appendChild(div);
          });
        }
        document.getElementById("proxyObjectsOverlay").style.display = "block";
      }
    }
    document.addEventListener("DOMContentLoaded", () => { window.app = new App(); });
  </script>
</body>
</html>
