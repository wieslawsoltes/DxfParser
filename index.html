<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>DXF Parser</title>
  <style>
    /* ======= STYLES ======= */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .main-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      box-sizing: border-box;
      padding: 1em;
    }
    body {
      font-family: sans-serif;
    }
    #tabContainer {
      display: flex;
      border-bottom: 1px solid #ccc;
      margin: 1em 0;
    }
    .tab {
      padding: 0.5em 1em;
      border: 1px solid #ccc;
      border-bottom: none;
      cursor: pointer;
      margin-right: 2px;
      position: relative;
      background: #eee;
    }
    .tab.active {
      background: #fff;
      font-weight: bold;
    }
    .tab .close-tab {
      position: absolute;
      top: 0;
      right: 2px;
      cursor: pointer;
      padding: 0 4px;
    }
    .tree-header {
      display: flex;
      font-weight: bold;
      border-bottom: 1px solid #ccc;
      padding-bottom: 4px;
      margin-bottom: 4px;
      background: #eee;
      user-select: none;
    }
    .tree-header > div {
      display: flex;
      align-items: center;
      position: relative;
      padding: 0 4px;
      border-right: 1px solid #ccc;
    }
    .tree-header > div:last-child {
      border-right: none;
    }
    .header-cell {
      cursor: pointer;
    }
    .header-cell .resizer {
      position: absolute;
      right: 0;
      top: 0;
      width: 5px;
      height: 100%;
      cursor: col-resize;
    }
    .header-cell .sort-indicator {
      margin-left: 4px;
      font-size: 0.8em;
    }
    .tree-line, .tree-code {
      width: 100px;
      text-align: left;
    }
    .tree-data {
      flex: 1;
    }
    #treeViewContainer {
      position: relative;
      flex: 1;
      overflow-y: auto;
      border: 1px solid #ccc;
    }
    #treeViewContent {
      position: relative;
    }
    .tree-row {
      display: flex;
      align-items: center;
      padding: 0;
      position: absolute;
      left: 0;
      right: 0;
      border-bottom: 1px solid #eee;
      box-sizing: border-box;
    }
    .tree-line, .tree-code, .tree-data {
      border-right: 1px solid #ccc;
      padding: 0 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .tree-line:last-child,
    .tree-code:last-child,
    .tree-data:last-child {
      border-right: none;
    }
    .toggle {
      display: inline-block;
      width: 16px;
      text-align: center;
      user-select: none;
      cursor: pointer;
    }
    .copy-button {
      margin-left: 8px;
      font-size: 0.8em;
      display: none;
    }
    .tree-row:hover .copy-button {
      display: inline;
    }
    .controls {
      margin: 1em 0;
    }
    .tag-container {
      display: inline-block;
      border: 1px solid #ccc;
      padding: 2px;
      min-width: 200px;
      margin-right: 8px;
      vertical-align: middle;
      border-radius: 4px;
    }
    .tag-container input {
      border: none;
      outline: none;
      font-family: inherit;
    }
    .tag {
      display: inline-block;
      background-color: #ddd;
      padding: 2px 6px;
      margin: 2px;
      border-radius: 4px;
      font-size: 0.9em;
    }
    .tag .remove {
      margin-left: 4px;
      cursor: pointer;
      font-weight: bold;
    }
  </style>
</head>
<body>
<div class="main-container">
  <h1>DXF Parser</h1>

  <!-- File Input -->
  <input type="file" id="fileInput" accept=".dxf" multiple>
  <button id="parseBtn">Parse File(s)</button>

  <!-- Tab Container -->
  <div id="tabContainer"></div>

  <!-- Search Controls -->
  <div class="controls">
    <div id="codeSearchTags" class="tag-container">
      <input type="text" id="codeSearchInput" placeholder="Search by Code">
    </div>
    <div id="dataSearchTags" class="tag-container">
      <input type="text" id="dataSearchInput" placeholder="Search by Data value">
    </div>
    <label>
      <input type="checkbox" id="dataExactCheckbox">
      Exact Data Match
    </label>
    <label>
      <input type="checkbox" id="dataCaseCheckbox">
      Case Sensitive
    </label>
    <button id="searchBtn">Search</button>
    <button id="clearSearchBtn">Clear Search</button>
    <button id="expandAllBtn">Expand All</button>
    <button id="collapseAllBtn">Collapse All</button>
  </div>

  <!-- Tree Grid Header -->
  <div id="treeGridHeader" class="tree-header">
    <div class="tree-line header-cell" data-field="line" data-sort="none" data-size="100px">
      Line <span class="sort-indicator"></span>
      <div class="resizer"></div>
    </div>
    <div class="tree-code header-cell" data-field="code" data-sort="none" data-size="100px">
      Code <span class="sort-indicator"></span>
      <div class="resizer"></div>
    </div>
    <div class="tree-data header-cell" data-field="type" data-sort="none" data-size="auto">
      Data <span class="sort-indicator"></span>
      <div class="resizer"></div>
    </div>
  </div>

  <!-- Virtual Scroll Container -->
  <div id="treeViewContainer">
    <div id="treeViewContent"></div>
  </div>
</div>

<!-- 1) DxfParser Class -->
<script>
class DxfParser {
  constructor() {
    // Map container objects to their ending markers
    this.containerMapping = {
      "SECTION": "ENDSEC",
      "BLOCK":   "ENDBLK",
      "TABLE":   "ENDTAB",
      "OBJECT":  "ENDOBJ",
      "POLYLINE":"SEQEND"
    };
    this.nextId = 1;
  }

  /**
   * Main entry point to parse a DXF text:
   *   1) parse text into tags
   *   2) group into hierarchical objects
   *   3) returns an array of top-level objects
   */
  parse(text) {
    const tags = this.parseDxf(text);
    const grouped = this.groupObjects(tags, 0);
    return grouped.objects;
  }

  /**
   * Splits the text into lines, forms { line, code, value }
   * @param {string} text - entire DXF file contents
   * @returns {Array} list of { line, code, value }
   */
  parseDxf(text) {
    const lines = text.split(/\r?\n/);
    const tags = [];
    for (let i = 0; i < lines.length; i++) {
      const codeLine = lines[i].trim();
      if (!codeLine) continue;
      const code = parseInt(codeLine, 10);
      if (isNaN(code)) continue;
      let value = "";
      const tagLine = i + 1; // store 1-based line number
      if (i + 1 < lines.length) {
        value = lines[i + 1].trim();
      }
      i++; // skip the value line
      tags.push({ line: tagLine, code, value });
    }
    return tags;
  }

  /**
   * Converts the list of tags into a tree of objects.
   * Recursively processes container objects (SECTION, BLOCK, etc.)
   * @param {Array} tags - list of { line, code, value }
   * @param {number} startIndex
   * @param {string|null} endMarker
   * @returns { { objects, nextIndex } }
   */
  groupObjects(tags, startIndex, endMarker = null) {
    const objects = [];
    let i = startIndex;

    while (i < tags.length) {
      // If we encounter the endMarker at code==0, we stop
      if (endMarker && tags[i].code === 0 && tags[i].value.toUpperCase() === endMarker) {
        i++;
        return { objects, nextIndex: i };
      }
      // If code != 0, skip until next code==0
      if (tags[i].code !== 0) {
        i++;
        continue;
      }
      // Build a new object
      const obj = {
        id: this.nextId++,
        type: tags[i].value,
        line: tags[i].line,
        properties: [],
        children: [],
        isContainer: this.containerMapping.hasOwnProperty(tags[i].value.toUpperCase()),
        expanded: false
      };
      i++;

      // Gather properties until next code==0 or until we run out
      while (i < tags.length && tags[i].code !== 0) {
        obj.properties.push(tags[i]);
        i++;
      }

      // If container, recursively parse children
      if (obj.isContainer) {
        const marker = this.containerMapping[obj.type.toUpperCase()];
        const result = this.groupObjects(tags, i, marker);
        obj.children = result.objects;
        i = result.nextIndex;
      }

      objects.push(obj);
    }
    return { objects, nextIndex: i };
  }

  /**
   * Find a node by ID in the entire tree (recursively).
   */
  findNodeById(tree, id) {
    for (const obj of tree) {
      if (String(obj.id) === String(id)) {
        return obj;
      }
      if (obj.children && obj.children.length) {
        const result = this.findNodeById(obj.children, id);
        if (result) return result;
      }
    }
    return null;
  }

  /**
   * Serialize a node (and its children) back to DXF text.
   * @param {Object} node
   * @returns {string} multiline DXF
   */
  serializeNode(node) {
    let lines = [];
    lines.push("0");
    lines.push(node.type);

    node.properties.forEach(prop => {
      lines.push(prop.code.toString());
      lines.push(prop.value);
    });

    // If container, recursively serialize children
    if (node.isContainer && node.children && node.children.length) {
      node.children.forEach(child => {
        lines.push(this.serializeNode(child));
      });
      const endMarker = this.containerMapping[node.type.toUpperCase()];
      if (endMarker) {
        lines.push("0");
        lines.push(endMarker);
      }
    }

    return lines.join("\n");
  }
}
</script>

<!-- 2) VirtualTreeView Class -->
<script>
class VirtualTreeView {
  constructor(container, content, options = {}) {
    this.container = container;
    this.content = content;
    this.itemHeight = options.itemHeight || 24;
    this.copyCallback = options.copyCallback || null;
    this.onToggleExpand = options.onToggleExpand || null;

    // Column width getters
    this.getLineWidth = options.getLineWidth || (() => 100);
    this.getCodeWidth = options.getCodeWidth || (() => 100);
    this.getDataWidth = options.getDataWidth || (() => null);

    this.flatData = [];
    this.treeData = [];

    // Listen for scrolling
    this.container.addEventListener("scroll", this.updateVisibleNodes.bind(this));

    // Click handling (toggle expand)
    this.content.addEventListener("click", (e) => {
      if (e.target.classList.contains("toggle")) {
        const row = e.target.closest(".tree-row");
        if (row) {
          const nodeId = row.dataset.id;
          // Let the outside code handle toggling
          if (this.onToggleExpand) {
            this.onToggleExpand(nodeId);
          }
        }
      }
      // Copy is handled in the button's click
    });
  }

  setData(treeData) {
    this.treeData = treeData || [];
    this.refresh();
  }

  refresh() {
    this.flatData = this.flattenTree(this.treeData);
    this.content.style.height = (this.flatData.length * this.itemHeight) + "px";
    this.updateVisibleNodes();
  }

  flattenTree(nodes, level = 0) {
    let flat = [];
    for (let node of nodes) {
      flat.push({ node, level });
      if (node.expanded) {
        // Properties as pseudo-children
        if (node.properties && node.properties.length) {
          for (let prop of node.properties) {
            flat.push({
              node: {
                id: `prop-${node.id}-${prop.line}-${prop.code}`,
                isProperty: true,
                line: prop.line,
                code: prop.code,
                data: prop.value
              },
              level: level + 1
            });
          }
        }
        // Real children
        if (node.children && node.children.length) {
          flat = flat.concat(this.flattenTree(node.children, level + 1));
        }
      }
    }
    return flat;
  }

  updateVisibleNodes() {
    const scrollTop = this.container.scrollTop;
    const containerHeight = this.container.clientHeight;
    const totalRows = this.flatData.length;
    const fullHeight = totalRows * this.itemHeight;

    // Define a safe maximum height for the scrollable content.
    // For example, 3,000,000 pixels.
    const MAX_HEIGHT = 3000000;
    const scale = fullHeight > MAX_HEIGHT ? MAX_HEIGHT / fullHeight : 1;

    // Set the content's height to the capped value.
    this.content.style.height = Math.min(fullHeight, MAX_HEIGHT) + "px";

    // Map the container's scrollTop to the effective scroll position in the full-height space.
    const effectiveScrollTop = scrollTop / scale;
    const startIndex = Math.floor(effectiveScrollTop / this.itemHeight);
    const visibleCount = Math.ceil(containerHeight / this.itemHeight) + 1;
    const endIndex = Math.min(startIndex + visibleCount, totalRows);

    // Clear the existing rows.
    this.content.innerHTML = "";
    const fragment = document.createDocumentFragment();

    // Render only the visible rows.
    for (let i = startIndex; i < endIndex; i++) {
      const { node, level } = this.flatData[i];
      const row = document.createElement("div");
      row.className = "tree-row tree-node";

      // Compute the top offset using the scale factor.
      row.style.top = (i * this.itemHeight * scale) + "px";
      row.style.height = this.itemHeight + "px";
      row.style.position = "absolute";
      row.dataset.id = node.id;

      // --- LINE Column ---
      const lineDiv = document.createElement("div");
      lineDiv.className = "tree-line";
      const lineWidth = this.getLineWidth();
      if (lineWidth) {
        lineDiv.style.width = lineWidth + "px";
      }
      lineDiv.style.textAlign = "left";

      const lineContent = document.createElement("div");
      lineContent.style.display = "flex";
      lineContent.style.alignItems = "center";
      lineContent.style.marginLeft = (level * 20) + "px";

      // Only add a toggle if the node has properties or children.
      if (!node.isProperty && ((node.properties && node.properties.length) || (node.children && node.children.length))) {
        const toggleSpan = document.createElement("span");
        toggleSpan.className = "toggle";
        toggleSpan.textContent = node.expanded ? "▼" : "►";
        lineContent.appendChild(toggleSpan);
      } else {
        const spacer = document.createElement("span");
        spacer.style.width = "16px";
        spacer.style.display = "inline-block";
        lineContent.appendChild(spacer);
      }
      const lineNumberSpan = document.createElement("span");
      lineNumberSpan.textContent = node.line || "";
      lineContent.appendChild(lineNumberSpan);
      lineDiv.appendChild(lineContent);
      row.appendChild(lineDiv);

      // --- CODE Column ---
      const codeDiv = document.createElement("div");
      codeDiv.className = "tree-code";
      const codeWidth = this.getCodeWidth();
      if (codeWidth) {
        codeDiv.style.width = codeWidth + "px";
      }
      codeDiv.style.textAlign = "left";
      if (node.isProperty) {
        codeDiv.textContent = node.code;
      } else {
        codeDiv.textContent = ((node.properties && node.properties.length) || (node.children && node.children.length))
          ? "0"
          : "";
      }
      row.appendChild(codeDiv);

      // --- DATA Column ---
      const dataDiv = document.createElement("div");
      dataDiv.className = "tree-data";
      const dataWidth = this.getDataWidth();
      if (dataWidth) {
        dataDiv.style.width = dataWidth + "px";
        dataDiv.style.flex = "0 0 auto";
      } else {
        dataDiv.style.flex = "1";
      }
      dataDiv.textContent = node.isProperty ? node.data : node.type || "";

      // Append a copy button if applicable and if not a property row.
      if (this.copyCallback && !node.isProperty) {
        const copyButton = document.createElement("button");
        copyButton.textContent = "Copy";
        copyButton.className = "copy-button";
        copyButton.addEventListener("click", (e) => {
          e.stopPropagation();
          this.copyCallback(node.id);
        });
        dataDiv.appendChild(copyButton);
      }
      row.appendChild(dataDiv);

      fragment.appendChild(row);
    }

    this.content.appendChild(fragment);
  }

}
</script>

<!-- 3) Main App Code as a Class -->
<script>
class App {
  constructor() {
    // 1) Instantiate classes and define global-like state
    this.dxfParser = new DxfParser();

    this.treeViewContainer = document.getElementById("treeViewContainer");
    this.treeViewContent = document.getElementById("treeViewContent");

    // Column widths
    this.columnWidths = {
      line: 100,
      code: 100,
      type: null
    };

    // Tabs array
    this.tabs = [];
    this.activeTabId = null;

    // The actual tree view instance
    this.myTreeView = new VirtualTreeView(this.treeViewContainer, this.treeViewContent, {
      itemHeight: 24,
      copyCallback: (nodeId) => this.handleCopy(nodeId),
      onToggleExpand: (nodeId) => this.handleToggleExpand(nodeId),
      getLineWidth: () => this.columnWidths.line,
      getCodeWidth: () => this.columnWidths.code,
      getDataWidth: () => this.columnWidths.type
    });

    // Setup all event listeners
    this.initEventListeners();
  }

  // ----------------------
  //  Event Listeners Setup
  // ----------------------
  initEventListeners() {
    // Parse button
    document.getElementById("parseBtn").addEventListener("click", () => this.handleParse());

    // Expand/Collapse All
    document.getElementById("expandAllBtn").addEventListener("click", () => this.handleExpandAll());
    document.getElementById("collapseAllBtn").addEventListener("click", () => this.handleCollapseAll());

    // Sorting (click on headers)
    document.querySelectorAll('.header-cell').forEach(headerCell => {
      headerCell.addEventListener('click', (e) => {
        if (e.target.classList.contains('resizer')) return;
        this.handleHeaderClick(headerCell);
      });
    });

    // Column resizing
    document.querySelectorAll('.header-cell .resizer').forEach(resizer => {
      resizer.addEventListener('mousedown', (e) => this.handleResizerMouseDown(e));
    });

    // Tag-style inputs
    this.setupTagInput("codeSearchInput", "code");
    this.setupTagInput("dataSearchInput", "data");

    // Search & Clear
    document.getElementById("searchBtn").addEventListener("click", () => this.handleSearch());
    document.getElementById("clearSearchBtn").addEventListener("click", () => this.handleClearSearch());
  }

  // ----------------------
  //        Tabs
  // ----------------------
  getActiveTab() {
    return this.tabs.find(t => t.id === this.activeTabId);
  }

  updateTabUI() {
    const tabContainer = document.getElementById("tabContainer");
    tabContainer.innerHTML = "";

    this.tabs.forEach(tab => {
      const tabElem = document.createElement("div");
      tabElem.className = "tab" + (tab.id === this.activeTabId ? " active" : "");
      tabElem.textContent = tab.name;
      tabElem.dataset.tabId = tab.id;

      tabElem.addEventListener("click", () => {
        this.activeTabId = tab.id;
        this.updateTabUI();
        this.myTreeView.setData(tab.currentTreeData);
      });

      // Close button
      const closeBtn = document.createElement("span");
      closeBtn.className = "close-tab";
      closeBtn.textContent = "×";
      closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.tabs = this.tabs.filter(t => t.id !== tab.id);
        if (this.activeTabId === tab.id) {
          this.activeTabId = this.tabs.length ? this.tabs[0].id : null;
        }
        this.updateTabUI();
        if (this.activeTabId) {
          this.myTreeView.setData(this.getActiveTab().currentTreeData);
        } else {
          this.myTreeView.setData([]);
        }
      });
      tabElem.appendChild(closeBtn);

      tabContainer.appendChild(tabElem);
    });
  }

  // ----------------------
  //  Expand/Collapse Logic
  // ----------------------
  expandAllNodes(nodes) {
    nodes.forEach(node => {
      if ((node.properties && node.properties.length) || (node.children && node.children.length)) {
        node.expanded = true;
        this.expandAllNodes(node.children);
      }
    });
  }
  collapseAllNodes(nodes) {
    nodes.forEach(node => {
      node.expanded = false;
      this.collapseAllNodes(node.children);
    });
  }

  handleExpandAll() {
    const activeTab = this.getActiveTab();
    if (!activeTab) return;
    this.expandAllNodes(activeTab.originalTreeData);
    // Re-sort if needed
    if (activeTab.currentSortField) {
      this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
    }
    // Re-filter
    const dataExact = document.getElementById("dataExactCheckbox").checked;
    const dataCase = document.getElementById("dataCaseCheckbox").checked;
    activeTab.currentTreeData = (activeTab.codeSearchTerms.length || activeTab.dataSearchTerms.length)
      ? this.filterTree(activeTab.originalTreeData, activeTab.codeSearchTerms, activeTab.dataSearchTerms, dataExact, dataCase)
      : activeTab.originalTreeData;
    this.myTreeView.setData(activeTab.currentTreeData);
  }

  handleCollapseAll() {
    const activeTab = this.getActiveTab();
    if (!activeTab) return;
    this.collapseAllNodes(activeTab.originalTreeData);
    // Re-sort if needed
    if (activeTab.currentSortField) {
      this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
    }
    // Re-filter
    const dataExact = document.getElementById("dataExactCheckbox").checked;
    const dataCase = document.getElementById("dataCaseCheckbox").checked;
    activeTab.currentTreeData = (activeTab.codeSearchTerms.length || activeTab.dataSearchTerms.length)
      ? this.filterTree(activeTab.originalTreeData, activeTab.codeSearchTerms, activeTab.dataSearchTerms, dataExact, dataCase)
      : activeTab.originalTreeData;
    this.myTreeView.setData(activeTab.currentTreeData);
  }

  // ----------------------
  //     Toggling Nodes
  // ----------------------
  handleToggleExpand(nodeId) {
    const activeTab = this.getActiveTab();
    if (!activeTab) return;
    const node = this.dxfParser.findNodeById(activeTab.originalTreeData, nodeId);
    if (node) {
      node.expanded = !node.expanded;
      // Re-sort if needed
      if (activeTab.currentSortField) {
        this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
      }
      // Re-filter if necessary
      const dataExact = document.getElementById("dataExactCheckbox").checked;
      const dataCase = document.getElementById("dataCaseCheckbox").checked;
      activeTab.currentTreeData = (activeTab.codeSearchTerms.length || activeTab.dataSearchTerms.length)
        ? this.filterTree(activeTab.originalTreeData, activeTab.codeSearchTerms, activeTab.dataSearchTerms, dataExact, dataCase)
        : activeTab.originalTreeData;
      this.myTreeView.setData(activeTab.currentTreeData);
    }
  }

  // ----------------------
  //   Sorting Logic
  // ----------------------
  getSortValue(node, field) {
    if (field === "line") {
      return node.line ? Number(node.line) : 0;
    } else if (field === "code") {
      if (node.isProperty) {
        const c = parseInt(node.code, 10);
        return isNaN(c) ? Number.MAX_SAFE_INTEGER : c;
      }
      return 0; // container objects => code 0
    } else if (field === "type") {
      return node.isProperty ? (node.data || "") : (node.type || "");
    }
    return "";
  }

  sortTreeNodes(nodes, field, ascending) {
    nodes.sort((a, b) => {
      const aVal = this.getSortValue(a, field);
      const bVal = this.getSortValue(b, field);
      if (field === "code" || field === "line") {
        return (aVal - bVal) * (ascending ? 1 : -1);
      } else {
        return aVal.localeCompare(bVal) * (ascending ? 1 : -1);
      }
    });

    nodes.forEach(node => {
      // Sort node's properties if relevant
      if (node.properties && node.properties.length) {
        node.properties.sort((aProp, bProp) => {
          if (field === "code") {
            const aC = parseInt(aProp.code, 10) || 0;
            const bC = parseInt(bProp.code, 10) || 0;
            return (aC - bC) * (ascending ? 1 : -1);
          } else if (field === "line") {
            const aL = aProp.line || 0;
            const bL = bProp.line || 0;
            return (aL - bL) * (ascending ? 1 : -1);
          } else if (field === "type") {
            const aV = aProp.value || "";
            const bV = bProp.value || "";
            return aV.localeCompare(bV) * (ascending ? 1 : -1);
          }
          return 0;
        });
      }
      // Recurse
      if (node.children && node.children.length) {
        this.sortTreeNodes(node.children, field, ascending);
      }
    });
  }

  handleHeaderClick(headerCell) {
    const field = headerCell.getAttribute('data-field');
    const activeTab = this.getActiveTab();
    if (!activeTab) return;

    let currentSort = headerCell.getAttribute('data-sort');
    let ascending = true;
    if (currentSort === 'asc') {
      ascending = false;
      headerCell.setAttribute('data-sort', 'desc');
      headerCell.querySelector('.sort-indicator').textContent = ' ▼';
    } else {
      ascending = true;
      headerCell.setAttribute('data-sort', 'asc');
      headerCell.querySelector('.sort-indicator').textContent = ' ▲';
    }
    activeTab.currentSortField = field;
    activeTab.currentSortAscending = ascending;

    // Reset others
    document.querySelectorAll('.header-cell').forEach(cell => {
      if (cell !== headerCell) {
        cell.setAttribute('data-sort', 'none');
        cell.querySelector('.sort-indicator').textContent = '';
      }
    });

    this.sortTreeNodes(activeTab.originalTreeData, field, ascending);

    // Re-filter if needed
    const dataExact = document.getElementById("dataExactCheckbox").checked;
    const dataCase = document.getElementById("dataCaseCheckbox").checked;
    activeTab.currentTreeData = (activeTab.codeSearchTerms.length || activeTab.dataSearchTerms.length)
      ? this.filterTree(activeTab.originalTreeData, activeTab.codeSearchTerms, activeTab.dataSearchTerms, dataExact, dataCase)
      : activeTab.originalTreeData;

    this.myTreeView.setData(activeTab.currentTreeData);
  }

  // Column resizing
  handleResizerMouseDown(e) {
    e.stopPropagation();
    const headerCell = e.target.parentElement;
    const field = headerCell.getAttribute('data-field');
    const startX = e.clientX;
    const startWidth = headerCell.offsetWidth;

    const onMouseMove = (eMove) => {
      const newWidth = startWidth + (eMove.clientX - startX);
      this.columnWidths[field] = newWidth; // store globally
      headerCell.style.width = newWidth + 'px';
      // Trigger re-render of visible rows
      this.myTreeView.updateVisibleNodes();
    };
    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  }

  // ----------------------
  //   Filter/Search Logic
  // ----------------------
  filterObject(obj, codeTerms, dataTerms, dataExact, dataCase) {
    const searchActive = (codeTerms.length > 0 || dataTerms.length > 0);

    let typeMatchesData = false;
    if (dataTerms.length > 0) {
      if (dataExact) {
        typeMatchesData = dataTerms.some(term => dataCase
          ? (obj.type === term)
          : (obj.type.toLowerCase() === term.toLowerCase())
        );
      } else {
        typeMatchesData = dataTerms.some(term => dataCase
          ? obj.type.includes(term)
          : obj.type.toLowerCase().includes(term.toLowerCase())
        );
      }
    } else {
      typeMatchesData = true;
    }

    // Filter properties
    const filteredProperties = obj.properties.filter(prop => {
      const codeMatch = (codeTerms.length === 0) || codeTerms.some(term => String(prop.code) === term);
      let dataMatch = true;
      if (dataTerms.length > 0) {
        if (dataExact) {
          dataMatch = dataTerms.some(term => dataCase
            ? (prop.value === term)
            : (prop.value.toLowerCase() === term.toLowerCase())
          );
        } else {
          dataMatch = dataTerms.some(term => dataCase
            ? prop.value.includes(term)
            : prop.value.toLowerCase().includes(term.toLowerCase())
          );
        }
      }
      return codeMatch && dataMatch;
    });

    // Filter children
    const filteredChildren = [];
    obj.children.forEach(child => {
      const filteredChild = this.filterObject(child, codeTerms, dataTerms, dataExact, dataCase);
      if (filteredChild !== null) {
        filteredChildren.push(filteredChild);
      }
    });

    if (searchActive && obj.isContainer) {
      if (filteredProperties.length === 0 && filteredChildren.length === 0) {
        return null;
      }
      return {
        ...obj,
        properties: filteredProperties,
        children: filteredChildren
      };
    } else {
      if (typeMatchesData || filteredProperties.length > 0 || filteredChildren.length > 0) {
        return {
          ...obj,
          properties: filteredProperties,
          children: filteredChildren
        };
      }
      return null;
    }
  }

  filterTree(objects, codeTerms, dataTerms, dataExact, dataCase) {
    const filtered = [];
    objects.forEach(obj => {
      const filteredObj = this.filterObject(obj, codeTerms, dataTerms, dataExact, dataCase);
      if (filteredObj !== null) {
        filtered.push(filteredObj);
      }
    });
    return filtered;
  }

  // ----------------------
  //    Copy Node Logic
  // ----------------------
  handleCopy(nodeId) {
    const activeTab = this.getActiveTab();
    if (!activeTab) return;
    const node = this.dxfParser.findNodeById(activeTab.originalTreeData, nodeId);
    if (!node) {
      alert("Node not found in original data.");
      return;
    }
    const serialized = this.dxfParser.serializeNode(node);
    navigator.clipboard.writeText(serialized).then(() => {
      alert("Copied node to clipboard as valid DXF tags.");
    }, () => {
      alert("Failed to copy to clipboard.");
    });
  }

  // ----------------------
  //    File Input / Parse
  // ----------------------
  handleParse() {
    const fileInput = document.getElementById("fileInput");
    if (!fileInput.files || fileInput.files.length === 0) {
      alert("Please select at least one DXF file.");
      return;
    }
    Array.from(fileInput.files).forEach(file => {
      const reader = new FileReader();
      reader.onload = (event) => {
        const text = event.target.result;
        // Parse with DxfParser
        const objects = this.dxfParser.parse(text);

        // Create a new tab
        const newTab = {
          id: Date.now() + Math.random(),
          name: file.name,
          originalTreeData: objects,
          currentTreeData: objects,
          codeSearchTerms: [],
          dataSearchTerms: [],
          currentSortField: "line",
          currentSortAscending: true
        };
        this.tabs.push(newTab);
        this.activeTabId = newTab.id;
        this.updateTabUI();

        // Show this tab's data
        this.myTreeView.setData(newTab.currentTreeData);
      };
      // Read as ASCII or UTF-8, adjust if needed
      reader.readAsText(file, "ascii");
    });
  }

  // ----------------------
  //     Tag-Style Inputs
  // ----------------------
  createTagElement(text, type) {
    const tag = document.createElement("span");
    tag.className = "tag";
    tag.textContent = text;

    const removeBtn = document.createElement("span");
    removeBtn.className = "remove";
    removeBtn.textContent = "×";
    removeBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const activeTab = this.getActiveTab();
      if (!activeTab) return;
      if (type === "code") {
        activeTab.codeSearchTerms = activeTab.codeSearchTerms.filter(term => term !== text);
        this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
      } else if (type === "data") {
        activeTab.dataSearchTerms = activeTab.dataSearchTerms.filter(term => term !== text);
        this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
      }
      // Re-filter
      const dataExact = document.getElementById("dataExactCheckbox").checked;
      const dataCase = document.getElementById("dataCaseCheckbox").checked;
      activeTab.currentTreeData = (activeTab.codeSearchTerms.length || activeTab.dataSearchTerms.length)
        ? this.filterTree(activeTab.originalTreeData, activeTab.codeSearchTerms, activeTab.dataSearchTerms, dataExact, dataCase)
        : activeTab.originalTreeData;
      this.myTreeView.setData(activeTab.currentTreeData);
    });
    tag.appendChild(removeBtn);

    return tag;
  }

  updateTagContainer(containerId, termsArray, type) {
    const container = document.getElementById(containerId);
    Array.from(container.querySelectorAll(".tag")).forEach(tag => tag.remove());
    termsArray.forEach(term => {
      const tagElem = this.createTagElement(term, type);
      container.insertBefore(tagElem, container.querySelector("input"));
    });
  }

  setupTagInput(inputId, type) {
    const input = document.getElementById(inputId);
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === ",") {
        e.preventDefault();
        const text = input.value.trim();
        if (text !== "") {
          const activeTab = this.getActiveTab();
          if (!activeTab) return;
          if (type === "code") {
            if (!activeTab.codeSearchTerms.includes(text)) {
              activeTab.codeSearchTerms.push(text);
            }
            this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
          } else {
            if (!activeTab.dataSearchTerms.includes(text)) {
              activeTab.dataSearchTerms.push(text);
            }
            this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
          }
          input.value = "";
        }
      }
    });
    // Also handle blur (leaving the input)
    input.addEventListener("blur", () => {
      const text = input.value.trim();
      if (text !== "") {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        if (type === "code") {
          if (!activeTab.codeSearchTerms.includes(text)) {
            activeTab.codeSearchTerms.push(text);
          }
          this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
        } else {
          if (!activeTab.dataSearchTerms.includes(text)) {
            activeTab.dataSearchTerms.push(text);
          }
          this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
        }
        input.value = "";
      }
    });
  }

  // Search & Clear
  handleSearch() {
    const activeTab = this.getActiveTab();
    if (!activeTab) return;
    const codeInput = document.getElementById("codeSearchInput");
    const dataInput = document.getElementById("dataSearchInput");

    if (codeInput.value.trim() !== "") {
      const text = codeInput.value.trim();
      if (!activeTab.codeSearchTerms.includes(text)) {
        activeTab.codeSearchTerms.push(text);
      }
      this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
      codeInput.value = "";
    }
    if (dataInput.value.trim() !== "") {
      const text = dataInput.value.trim();
      if (!activeTab.dataSearchTerms.includes(text)) {
        activeTab.dataSearchTerms.push(text);
      }
      this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
      dataInput.value = "";
    }

    const dataExact = document.getElementById("dataExactCheckbox").checked;
    const dataCase = document.getElementById("dataCaseCheckbox").checked;
    activeTab.currentTreeData = (activeTab.codeSearchTerms.length || activeTab.dataSearchTerms.length)
      ? this.filterTree(activeTab.originalTreeData, activeTab.codeSearchTerms, activeTab.dataSearchTerms, dataExact, dataCase)
      : activeTab.originalTreeData;
    this.myTreeView.setData(activeTab.currentTreeData);
  }

  handleClearSearch() {
    const activeTab = this.getActiveTab();
    if (!activeTab) return;

    activeTab.codeSearchTerms = [];
    activeTab.dataSearchTerms = [];
    this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
    this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
    document.getElementById("codeSearchInput").value = "";
    document.getElementById("dataSearchInput").value = "";
    document.getElementById("dataExactCheckbox").checked = false;
    document.getElementById("dataCaseCheckbox").checked = false;
    activeTab.currentTreeData = activeTab.originalTreeData;
    this.myTreeView.setData(activeTab.currentTreeData);
  }
}

// Finally, instantiate the main app
document.addEventListener("DOMContentLoaded", () => {
  new App();
});
</script>
</body>
</html>
