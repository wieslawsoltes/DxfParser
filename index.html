<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- This meta tag makes the app responsive on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DXF Parser</title>
  <style>
    /* Base Styles */
    html, body { height: 100%; margin: 0; padding: 0; }
    *, *:before, *:after { box-sizing: border-box; }
    body { font-family: sans-serif; }
    .main-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 1em;
    }
    .header-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1em;
    }
    /* File input row (for file input, streamed parsing check box, and parse button on the same line) */
    .file-input-row {
      display: inline-flex;
      align-items: center;
      gap: 0.5em;
      margin-bottom: 1em;
    }
    #parseBtn { padding: 0.3em 0.6em; white-space: nowrap; }
    .top-right-buttons {
      display: flex;
      gap: 0.5em;
      flex-wrap: wrap;
    }
    #navHistoryContainer {
      margin-bottom: 1em;
      padding: 0.5em;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #navHistoryControls { margin-bottom: 0.5em; }
    #navHistoryControls button { margin-right: 4px; }
    #navHistoryList { overflow-x: auto; white-space: nowrap; }
    #tabContainer {
      display: flex;
      flex-wrap: wrap;
      border-bottom: 1px solid #ccc;
      margin: 0.5em 0;
    }
    .tab {
      padding: 0.5em 1em;
      border: 1px solid #ccc;
      border-bottom: none;
      cursor: pointer;
      margin-right: 2px;
      margin-bottom: 2px;
      background: #eee;
      position: relative;
    }
    .tab.active { background: #fff; font-weight: bold; }
    .tab .close-tab {
      position: absolute;
      top: 0;
      right: 2px;
      cursor: pointer;
      padding: 0 4px;
    }
    /* Tree Grid Header */
    #treeGridHeader {
      display: flex;
      align-items: center;
      height: 24px;
      font-weight: bold;
      border-bottom: 1px solid #ccc;
      background: #eee;
      user-select: none;
      position: sticky;
      top: 0;
      z-index: 2;
      will-change: transform;
    }
    .header-cell {
      display: flex;
      align-items: center;
      height: 100%;
      position: relative;
      padding: 0 4px;
      border-right: 1px solid #ccc;
      cursor: pointer;
    }
    .header-cell.flex-fixed { flex: none; }
    .header-cell.flex-grow { flex: 1; }
    .header-cell:last-child { border-right: none; }
    .header-cell .resizer {
      position: absolute;
      right: 0;
      top: 0;
      width: 5px;
      height: 100%;
      cursor: col-resize;
    }
    .header-cell .sort-indicator {
      margin-left: 4px;
      font-size: 0.8em;
    }
    .tree-line,
    .tree-code,
    .tree-object-count,
    .tree-data-size {
      flex: none;
      padding: 0 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: left;
      border-right: 1px solid #ccc;
      height: 100%;
    }
    .tree-data {
      flex: 1;
      padding: 0 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border-right: 1px solid #ccc;
      height: 100%;
    }
    .tree-line:last-child,
    .tree-code:last-child,
    .tree-data:last-child,
    .tree-object-count:last-child,
    .tree-data-size:last-child { border-right: none; }
    /* Tree View Container */
    #treeViewContainer {
      position: relative;
      flex: 1;
      overflow: auto;
      border: 1px solid #ccc;
      clip-path: inset(0);
    }
    #treeViewContent { position: relative; overflow: hidden; }
    .tree-row {
      display: flex;
      align-items: center;
      height: 24px;
      border-bottom: 1px solid #eee;
      overflow: hidden;
    }
    .toggle {
      display: inline-block;
      width: 16px;
      text-align: center;
      user-select: none;
      cursor: pointer;
    }
    .copy-button, .hex-button {
      margin-left: 8px;
      font-size: 0.8em;
      display: none;
    }
    .tree-row:hover .copy-button,
    .tree-row:hover .hex-button { display: inline; }
    /* Filter Panel */
    .filter-panel {
      border: 1px solid #ccc;
      border-radius: 4px;
      margin: 0.5em 0;
      overflow: hidden;
    }
    .filter-toggle {
      background: #eee;
      padding: 0.5em;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .filter-panel .filter-content { display: none; }
    .filter-panel.expanded .filter-content { display: block; }
    .filter-row {
      margin-bottom: 0.5em;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.5em;
    }
    .filter-row label,
    .filter-row input,
    .filter-row button { margin-right: 0.5em; }
    .tag-container {
      display: inline-block;
      border: 1px solid #ccc;
      padding: 2px;
      min-width: 200px;
      margin-right: 8px;
      border-radius: 4px;
      vertical-align: middle;
    }
    .tag-container input {
      border: none;
      outline: none;
      font-family: inherit;
    }
    .tag {
      display: inline-block;
      background: #ddd;
      padding: 2px 6px;
      margin: 2px;
      border-radius: 4px;
      font-size: 0.9em;
    }
    .tag .remove {
      margin-left: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    /* Overlays */
    #cloudOverlay,
    #statsOverlay,
    #depsOverlay,
    #hexViewerOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
    }
    .overlay-content {
      background: #fff;
      margin: 20px;
      padding: 1em;
      width: calc(100% - 40px);
      height: calc(100% - 40px);
      border: 4px solid rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      position: relative;
      overflow-y: auto;
    }
    #closeCloudOverlay,
    #closeStatsOverlay,
    #closeDepsOverlay,
    #closeHexViewerOverlay,
    #saveBinaryBtn {
      position: absolute;
      top: 10px;
      cursor: pointer;
    }
    #closeCloudOverlay,
    #closeStatsOverlay,
    #closeDepsOverlay,
    #closeHexViewerOverlay { right: 10px; }
    #saveBinaryBtn { right: 80px; }
    .cloud-tag {
      display: inline-block;
      margin: 4px;
      padding: 2px 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #f9f9f9;
    }
    #overlayStatsContent ul,
    #overlayDepsContent ul {
      list-style: none;
      padding: 0;
    }
    #overlayStatsContent li,
    #overlayDepsContent li {
      padding: 0.5em 0;
      border-bottom: 1px solid #eee;
    }
    /* Responsive adjustments for mobile */
    @media (max-width: 600px) {
      .filter-panel .filter-content > * {
        margin-bottom: 0.5em;
        width: 100%;
      }
      .tag-container { min-width: 100%; }
      #treeGridHeader .header-cell { padding: 0 2px; }
      .tree-row { height: 32px; }
      .tree-row .toggle { width: 20px; }
      .header-container {
        flex-direction: column;
        align-items: flex-start;
      }
      .top-right-buttons { margin-top: 0.5em; }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <!-- Header: Logo and top-right buttons -->
    <div class="header-container">
      <h1>DXF Parser</h1>
      <div class="top-right-buttons">
        <button id="expandAllBtn">Expand All</button>
        <button id="collapseAllBtn">Collapse All</button>
        <button id="showCloudOverlayBtn">Show Cloud Data</button>
        <button id="showStatsOverlayBtn">Show DXF Statistics</button>
        <button id="showDepsOverlayBtn">Show DXF Dependencies</button>
      </div>
    </div>
    <!-- File input row with streaming option -->
    <div class="file-input-row">
      <input type="file" id="fileInput" accept=".dxf" multiple>
      <label>
        <input type="checkbox" id="useStreamCheckbox">
        Use Streamed Parsing
      </label>
      <button id="parseBtn">Parse File(s)</button>
    </div>
    <!-- Navigation History -->
    <div id="navHistoryContainer">
      <div id="navHistoryControls">
        <button id="backBtn" disabled>Back</button>
        <button id="forwardBtn" disabled>Forward</button>
        <button id="clearHistoryBtn">Clear</button>
      </div>
      <div id="navHistoryList"></div>
    </div>
    <!-- Tabs -->
    <div id="tabContainer"></div>
    <!-- Filter Panel -->
    <div class="filter-panel expanded" id="filterPanel">
      <div class="filter-toggle">
        <span>Filters</span>
        <span class="toggle-icon">▲</span>
      </div>
      <div class="filter-content">
        <div class="filter-row">
          <div id="codeSearchTags" class="tag-container">
            <input type="text" id="codeSearchInput" placeholder="Search by Code">
          </div>
          <div id="dataSearchTags" class="tag-container">
            <input type="text" id="dataSearchInput" placeholder="Search by Data value">
          </div>
          <label>
            <input type="checkbox" id="dataExactCheckbox"> Exact Data Match
          </label>
          <label>
            <input type="checkbox" id="dataCaseCheckbox"> Case Sensitive
          </label>
        </div>
        <div class="filter-row">
          <label for="minLineInput">Min Line:</label>
          <input type="number" id="minLineInput" style="width:80px;">
          <label for="maxLineInput">Max Line:</label>
          <input type="number" id="maxLineInput" style="width:80px;">
          <input type="text" id="handleSearchInput" placeholder="Go to Handle">
          <button id="goToHandleBtn">Go</button>
        </div>
        <div class="filter-row">
          <button id="searchBtn">Search</button>
          <button id="clearSearchBtn">Clear Search</button>
        </div>
      </div>
    </div>
    <!-- Tree Grid Header -->
    <div id="treeGridHeader" class="tree-header">
      <div class="tree-line header-cell flex-fixed" data-field="line" data-sort="none" style="width: 100px; text-align: left;">
        Line <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
      <div class="tree-code header-cell flex-fixed" data-field="code" data-sort="none" style="width: 100px; text-align: left;">
        Code <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
      <div class="tree-data header-cell flex-grow" data-field="type" data-sort="none" style="flex: 1;">
        Data <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
      <div class="tree-object-count header-cell flex-fixed" data-field="objectCount" data-sort="none" style="width: 100px; text-align: right;">
        Object Count <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
      <div class="tree-data-size header-cell flex-fixed" data-field="dataSize" data-sort="none" style="width: 100px; text-align: right;">
        Data Size <span class="sort-indicator"></span>
        <div class="resizer"></div>
      </div>
    </div>
    <!-- Tree View Container -->
    <div id="treeViewContainer">
      <div id="treeViewContent"></div>
    </div>
  </div>
  <!-- Overlays -->
  <div id="cloudOverlay">
    <div class="overlay-content">
      <button id="closeCloudOverlay">Close</button>
      <h2>Cloud Data</h2>
      <h3>Object Cloud</h3>
      <div id="overlayObjectCloud"></div>
      <h3>Code Cloud</h3>
      <div id="overlayCodeCloud"></div>
    </div>
  </div>
  <div id="statsOverlay">
    <div class="overlay-content">
      <button id="closeStatsOverlay">Close</button>
      <h2>DXF Statistics</h2>
      <div id="overlayStatsContent"></div>
    </div>
  </div>
  <div id="depsOverlay">
    <div class="overlay-content">
      <button id="closeDepsOverlay">Close</button>
      <h2>DXF Dependencies</h2>
      <div id="overlayDepsContent"></div>
    </div>
  </div>
  <!-- New Hex Viewer Overlay -->
  <div id="hexViewerOverlay">
    <div class="overlay-content">
      <button id="closeHexViewerOverlay">Close</button>
      <button id="saveBinaryBtn">Save Binary</button>
      <h2>Hex Viewer</h2>
      <div id="headerInfo"></div>
      <pre id="hexContent" style="overflow:auto; height: calc(100% - 100px);"></pre>
    </div>
  </div>

  <!-- Utility Functions -->
  <script>
    // Convert a concatenated hex string into a Uint8Array.
    function hexStringToByteArray(hexString) {
      // Remove any whitespace
      hexString = hexString.replace(/\s+/g, "");
      const byteLength = Math.floor(hexString.length / 2);
      const result = new Uint8Array(byteLength);
      for (let i = 0; i < byteLength; i++) {
        result[i] = parseInt(hexString.substr(i * 2, 2), 16);
      }
      return result;
    }

    // Produce a hex dump from a Uint8Array.
    function hexDump(buffer) {
      const bytesPerLine = 16;
      let result = "";
      for (let i = 0; i < buffer.length; i += bytesPerLine) {
        const lineBytes = Array.from(buffer.slice(i, i + bytesPerLine));
        const hexBytes = lineBytes.map(byte => byte.toString(16).padStart(2, '0'));
        const asciiChars = lineBytes.map(byte =>
          byte >= 32 && byte < 127 ? String.fromCharCode(byte) : '.'
        );
        // Pad the last line if fewer than 16 bytes.
        while (hexBytes.length < bytesPerLine) {
          hexBytes.push("  ");
          asciiChars.push(" ");
        }
        result += i.toString(16).padStart(8, '0') + "  " +
                  hexBytes.join(" ") + "  " +
                  asciiChars.join("") + "\n";
      }
      return result;
    }

    // Attempt to detect a common file header from a Uint8Array.
    function detectHeader(buffer) {
      // BMP: "BM"
      if (buffer.length >= 2 && buffer[0] === 0x42 && buffer[1] === 0x4D) return "BMP Image";
      // PNG: 89 50 4E 47 0D 0A 1A 0A
      if (buffer.length >= 8 &&
          buffer[0] === 0x89 && buffer[1] === 0x50 &&
          buffer[2] === 0x4E && buffer[3] === 0x47 &&
          buffer[4] === 0x0D && buffer[5] === 0x0A &&
          buffer[6] === 0x1A && buffer[7] === 0x0A)
        return "PNG Image";
      // GIF: "GIF87a" or "GIF89a"
      if (buffer.length >= 6) {
        const header = String.fromCharCode(...buffer.slice(0,6));
        if (header === "GIF87a" || header === "GIF89a") return "GIF Image";
      }
      // JPEG: FF D8 FF
      if (buffer.length >= 3 && buffer[0] === 0xFF && buffer[1] === 0xD8 && buffer[2] === 0xFF)
        return "JPEG Image";
      // PDF: "%PDF"
      if (buffer.length >= 4) {
        const header = String.fromCharCode(...buffer.slice(0,4));
        if (header === "%PDF") return "PDF Document";
      }
      // ZIP: "PK\x03\x04"
      if (buffer.length >= 4 &&
          buffer[0] === 0x50 && buffer[1] === 0x4B &&
          buffer[2] === 0x03 && buffer[3] === 0x04)
        return "ZIP Archive";
      return null;
    }
  </script>

  <!-- JavaScript Classes -->
  <script>
    class DxfParser {
      constructor() {
        this.containerMapping = {
          "SECTION": "ENDSEC",
          "BLOCK":   "ENDBLK",
          "TABLE":   "ENDTAB",
          "OBJECT":  "ENDOBJ",
          "POLYLINE": "SEQEND"
        };
        this.nextId = 1;
        this.handleCodes = [5, 105, 330, 350, 360];
      }
      parse(text) {
        const tags = this.parseDxf(text);
        const grouped = this.groupObjects(tags, 0);
        return grouped.objects;
      }
      parseDxf(text) {
        const lines = text.split(/\r?\n/);
        const tags = [];
        for (let i = 0; i < lines.length; i++) {
          const codeLine = lines[i].trim();
          if (!codeLine) continue;
          const code = parseInt(codeLine, 10);
          if (isNaN(code)) continue;
          let value = "";
          if (i + 1 < lines.length) {
            value = lines[i + 1].trim();
          }
          i++;
          tags.push({ line: i, code, value });
        }
        return tags;
      }
      // New method: parse an array of lines.
      parseDxfLines(lines) {
        const tags = [];
        for (let i = 0; i < lines.length; i++) {
          const codeLine = lines[i].trim();
          if (!codeLine) continue;
          const code = parseInt(codeLine, 10);
          if (isNaN(code)) continue;
          let value = "";
          if (i + 1 < lines.length) {
            value = lines[i + 1].trim();
          }
          i++;
          tags.push({ line: i, code, value });
        }
        return tags;
      }
      groupObjects(tags, startIndex, endMarker = null) {
        const objects = [];
        let i = startIndex;
        while (i < tags.length) {
          if (endMarker && tags[i].code === 0 && tags[i].value.toUpperCase() === endMarker) {
            i++;
            return { objects, nextIndex: i };
          }
          if (tags[i].code !== 0) {
            i++;
            continue;
          }
          const obj = {
            id: this.nextId++,
            type: tags[i].value,
            line: tags[i].line,
            properties: [],
            children: [],
            isContainer: this.containerMapping.hasOwnProperty(tags[i].value.toUpperCase()),
            expanded: false
          };
          i++;
          while (i < tags.length && tags[i].code !== 0) {
            obj.properties.push(tags[i]);
            i++;
          }
          const handleProp = obj.properties.find(prop => this.handleCodes.includes(prop.code));
          if (handleProp) { obj.handle = handleProp.value; }
          if (obj.isContainer) {
            const marker = this.containerMapping[obj.type.toUpperCase()];
            const result = this.groupObjects(tags, i, marker);
            obj.children = result.objects;
            i = result.nextIndex;
          }
          objects.push(obj);
        }
        return { objects, nextIndex: i };
      }
      findNodeById(tree, id) {
        for (const obj of tree) {
          if (String(obj.id) === String(id)) return obj;
          if (obj.children && obj.children.length) {
            const result = this.findNodeById(obj.children, id);
            if (result) return result;
          }
        }
        return null;
      }
      serializeNode(node) {
        let lines = [];
        lines.push("0");
        lines.push(node.type);
        node.properties.forEach(prop => {
          lines.push(prop.code.toString());
          lines.push(prop.value);
        });
        if (node.isContainer && node.children && node.children.length) {
          node.children.forEach(child => {
            lines.push(this.serializeNode(child));
          });
          const endMarker = this.containerMapping[node.type.toUpperCase()];
          if (endMarker) {
            lines.push("0");
            lines.push(endMarker);
          }
        }
        return lines.join("\n");
      }
    }
  </script>
  <script>
    class VirtualTreeView {
      constructor(container, content, options = {}) {
        this.container = container;
        this.content = content;
        this.itemHeight = options.itemHeight || 24;
        this.copyCallback = options.copyCallback || null;
        this.onToggleExpand = options.onToggleExpand || null;
        this.onHandleClick = options.onHandleClick || null;
        this.hexViewerCallback = options.hexViewerCallback || null;
        this.getLineWidth = options.getLineWidth || (() => 100);
        this.getCodeWidth = options.getCodeWidth || (() => 100);
        this.getDataWidth = options.getDataWidth || (() => null);
        this.columnWidths = options.columnWidths || {};
        this.flatData = [];
        this.treeData = [];
        this.container.addEventListener("scroll", () => {
          requestAnimationFrame(() => this.updateVisibleNodes());
        });
        this.content.addEventListener("click", (e) => {
          if (e.target.classList.contains("toggle")) {
            const row = e.target.closest(".tree-row");
            if (row) {
              const nodeId = row.dataset.id;
              if (this.onToggleExpand) { this.onToggleExpand(nodeId); }
            }
          }
        });
      }
      setData(treeData) {
        this.treeData = treeData || [];
        this.refresh();
      }
      refresh() {
        this.flatData = this.flattenTree(this.treeData);
        console.log("Total rows:", this.flatData.length);
        this.updateVisibleNodes();
      }
      flattenTree(nodes, level = 0) {
        let flat = [];
        for (let node of nodes) {
          flat.push({ node, level });
          if (node.expanded) {
            if (node.properties && node.properties.length) {
              for (let prop of node.properties) {
                flat.push({
                  node: {
                    id: `prop-${node.id}-${prop.line}-${prop.code}`,
                    isProperty: true,
                    line: prop.line,
                    code: prop.code,
                    data: prop.value
                  },
                  level: level + 1
                });
              }
            }
            if (node.children && node.children.length) {
              flat = flat.concat(this.flattenTree(node.children, level + 1));
            }
          }
        }
        return flat;
      }
      computeObjectCount(node) {
        if (!node.children || node.children.length === 0) return 0;
        let count = 0;
        for (let child of node.children) {
          if (!child.isProperty) {
            count++;
            if (child.children && child.children.length) { count += this.computeObjectCount(child); }
          }
        }
        return count;
      }
      computeDataSize(node) {
        let size = 0;
        if (node.isProperty) { size += node.data ? node.data.length : 0; }
        else {
          size += node.type ? node.type.length : 0;
          if (node.properties && node.properties.length) {
            for (let prop of node.properties) { size += prop.value ? prop.value.length : 0; }
          }
          if (node.children && node.children.length) {
            for (let child of node.children) { size += this.computeDataSize(child); }
          }
        }
        return size;
      }
      syncHeaderWidths() {
        const header = document.getElementById("treeGridHeader");
        if (!header) return;
        const lineCell = header.querySelector('.tree-line');
        if (lineCell && this.columnWidths.line) { lineCell.style.width = this.columnWidths.line + "px"; }
        const codeCell = header.querySelector('.tree-code');
        if (codeCell && this.columnWidths.code) { codeCell.style.width = this.columnWidths.code + "px"; }
        const typeCell = header.querySelector('.tree-data');
        if (typeCell) {
          if (this.columnWidths.type) {
            typeCell.style.width = this.columnWidths.type + "px";
            typeCell.style.flex = "0 0 auto";
          } else { typeCell.style.width = ""; typeCell.style.flex = "1"; }
        }
        const objectCountCell = header.querySelector('.tree-object-count');
        if (objectCountCell && this.columnWidths.objectCount) { objectCountCell.style.width = this.columnWidths.objectCount + "px"; }
        const dataSizeCell = header.querySelector('.tree-data-size');
        if (dataSizeCell && this.columnWidths.dataSize) { dataSizeCell.style.width = this.columnWidths.dataSize + "px"; }
      }
      updateVisibleNodes() {
        const scrollTop = this.container.scrollTop;
        const containerHeight = this.container.clientHeight;
        const totalRows = this.flatData.length;
        const fullHeight = totalRows * this.itemHeight;
        this.content.style.height = fullHeight + "px";
        const startIndex = Math.floor(scrollTop / this.itemHeight);
        const visibleCount = Math.ceil(containerHeight / this.itemHeight) + 1;
        const endIndex = Math.min(startIndex + visibleCount, totalRows);
        const containerElem = document.createElement("div");
        const topSpacer = document.createElement("div");
        topSpacer.style.height = (startIndex * this.itemHeight) + "px";
        containerElem.appendChild(topSpacer);
        const fragment = document.createDocumentFragment();
        for (let i = startIndex; i < endIndex; i++) {
          const { node, level } = this.flatData[i];
          const row = document.createElement("div");
          row.className = "tree-row tree-node";
          row.style.display = "flex";
          row.style.position = "relative";
          row.style.height = this.itemHeight + "px";
          row.dataset.id = node.id;
          const lineDiv = document.createElement("div");
          lineDiv.className = "tree-line";
          const lineWidth = this.getLineWidth();
          if (lineWidth) { lineDiv.style.width = lineWidth + "px"; }
          const lineContent = document.createElement("div");
          lineContent.style.display = "flex";
          lineContent.style.alignItems = "center";
          lineContent.style.marginLeft = (level * 20) + "px";
          if (!node.isProperty && ((node.properties && node.properties.length) || (node.children && node.children.length))) {
            const toggleSpan = document.createElement("span");
            toggleSpan.className = "toggle";
            toggleSpan.textContent = node.expanded ? "▼" : "►";
            lineContent.appendChild(toggleSpan);
          } else {
            const spacer = document.createElement("span");
            spacer.style.width = "16px";
            spacer.style.display = "inline-block";
            lineContent.appendChild(spacer);
          }
          const lineNumberSpan = document.createElement("span");
          lineNumberSpan.textContent = node.line || "";
          lineContent.appendChild(lineNumberSpan);
          lineDiv.appendChild(lineContent);
          row.appendChild(lineDiv);
          const codeDiv = document.createElement("div");
          codeDiv.className = "tree-code";
          const codeWidth = this.getCodeWidth();
          if (codeWidth) { codeDiv.style.width = codeWidth + "px"; }
          codeDiv.style.textAlign = "left";
          if (node.isProperty) { codeDiv.textContent = node.code; }
          else { codeDiv.textContent = ((node.properties && node.properties.length) || (node.children && node.children.length)) ? "0" : ""; }
          row.appendChild(codeDiv);
          const dataDiv = document.createElement("div");
          dataDiv.className = "tree-data";
          const dataWidth = this.getDataWidth();
          if (dataWidth) { dataDiv.style.width = dataWidth + "px"; dataDiv.style.flex = "0 0 auto"; }
          else { dataDiv.style.flex = "1"; }
          const handleCodes = [5, 105, 330, 350, 360];
          if (node.isProperty) {
            if (handleCodes.includes(Number(node.code))) {
              const a = document.createElement("a");
              a.href = "#";
              a.textContent = node.data;
              a.style.textDecoration = "underline";
              a.style.color = "blue";
              a.addEventListener("click", (e) => {
                e.preventDefault();
                if (this.onHandleClick) { this.onHandleClick(node.data); }
              });
              dataDiv.appendChild(a);
            } else { dataDiv.textContent = node.data; }
          } else {
            dataDiv.textContent = node.type || "";
            if (node.handle) {
              const spanHandle = document.createElement("span");
              spanHandle.textContent = " (" + node.handle + ")";
              spanHandle.style.textDecoration = "underline";
              spanHandle.style.color = "blue";
              spanHandle.style.cursor = "pointer";
              spanHandle.addEventListener("click", (e) => {
                e.preventDefault();
                if (this.onHandleClick) { this.onHandleClick(node.handle); }
              });
              dataDiv.appendChild(spanHandle);
            }
            if (this.copyCallback && !node.isProperty) {
              const copyButton = document.createElement("button");
              copyButton.textContent = "Copy";
              copyButton.className = "copy-button";
              copyButton.addEventListener("click", (e) => {
                e.stopPropagation();
                this.copyCallback(node.id);
              });
              dataDiv.appendChild(copyButton);
            }
            // Collect all binary tags (group code 310) and concatenate their values.
            if (!node.isProperty && node.properties) {
              const binaryProps = node.properties.filter(prop => Number(prop.code) === 310);
              if (binaryProps.length > 0) {
                const combinedData = binaryProps.map(prop => prop.value).join("");
                const hexButton = document.createElement("button");
                hexButton.textContent = "Hex Viewer";
                hexButton.className = "hex-button";
                hexButton.addEventListener("click", (e) => {
                  e.stopPropagation();
                  if (this.hexViewerCallback) { this.hexViewerCallback(combinedData); }
                });
                dataDiv.appendChild(hexButton);
              }
            }
          }
          row.appendChild(dataDiv);
          const objectCountDiv = document.createElement("div");
          objectCountDiv.className = "tree-object-count";
          objectCountDiv.style.width = this.columnWidths.objectCount + "px";
          objectCountDiv.style.textAlign = "right";
          if (!node.isProperty && node.children && node.children.length) { objectCountDiv.textContent = this.computeObjectCount(node); }
          else { objectCountDiv.textContent = ""; }
          row.appendChild(objectCountDiv);
          const dataSizeDiv = document.createElement("div");
          dataSizeDiv.className = "tree-data-size";
          dataSizeDiv.style.width = this.columnWidths.dataSize + "px";
          dataSizeDiv.style.textAlign = "right";
          dataSizeDiv.textContent = this.computeDataSize(node);
          row.appendChild(dataSizeDiv);
          fragment.appendChild(row);
        }
        containerElem.appendChild(fragment);
        const bottomSpacer = document.createElement("div");
        const bottomHeight = Math.max(0, fullHeight - (startIndex + visibleCount) * this.itemHeight);
        bottomSpacer.style.height = bottomHeight + "px";
        containerElem.appendChild(bottomSpacer);
        this.content.innerHTML = "";
        this.content.appendChild(containerElem);
        this.syncHeaderWidths();
      }
      computeObjectCount(node) {
        if (!node.children || node.children.length === 0) return 0;
        let count = 0;
        for (let child of node.children) {
          if (!child.isProperty) {
            count++;
            if (child.children && child.children.length) { count += this.computeObjectCount(child); }
          }
        }
        return count;
      }
    }
  </script>
  <script>
    class App {
      constructor() {
        this.columnWidths = { line: 100, code: 100, type: null, objectCount: 100, dataSize: 100 };
        this.dxfParser = new DxfParser();
        this.treeViewContainer = document.getElementById("treeViewContainer");
        this.treeViewContent = document.getElementById("treeViewContent");
        this.tabs = [];
        this.activeTabId = null;
        this.currentBinaryData = null; // For saving binary from hex viewer
        this.myTreeView = new VirtualTreeView(this.treeViewContainer, this.treeViewContent, {
          itemHeight: 24,
          copyCallback: (nodeId) => this.handleCopy(nodeId),
          onToggleExpand: (nodeId) => this.handleToggleExpand(nodeId),
          onHandleClick: (handle) => this.handleLinkToHandle(handle),
          getLineWidth: () => this.columnWidths.line,
          getCodeWidth: () => this.columnWidths.code,
          getDataWidth: () => this.columnWidths.type,
          columnWidths: this.columnWidths,
          hexViewerCallback: (combinedHexString) => this.showHexViewer(combinedHexString)
        });
        this.initEventListeners();
      }
      initEventListeners() {
        document.getElementById("parseBtn").addEventListener("click", () => this.handleParse());
        document.getElementById("expandAllBtn").addEventListener("click", () => this.handleExpandAll());
        document.getElementById("collapseAllBtn").addEventListener("click", () => this.handleCollapseAll());
        document.querySelectorAll('.header-cell').forEach(headerCell => {
          headerCell.addEventListener('click', (e) => {
            if (e.target.classList.contains('resizer')) return;
            this.handleHeaderClick(headerCell);
          });
        });
        document.querySelectorAll('.header-cell .resizer').forEach(resizer => {
          resizer.addEventListener('mousedown', (e) => this.handleResizerMouseDown(e));
        });
        this.setupTagInput("codeSearchInput", "code");
        this.setupTagInput("dataSearchInput", "data");
        document.getElementById("searchBtn").addEventListener("click", () => this.handleSearch());
        document.getElementById("clearSearchBtn").addEventListener("click", () => this.handleClearSearch());
        document.getElementById("showCloudOverlayBtn").addEventListener("click", () => {
          this.updateClouds();
          document.getElementById("cloudOverlay").style.display = "block";
        });
        document.getElementById("closeCloudOverlay").addEventListener("click", () => {
          document.getElementById("cloudOverlay").style.display = "none";
        });
        document.getElementById("showStatsOverlayBtn").addEventListener("click", () => {
          this.updateStats();
          document.getElementById("statsOverlay").style.display = "block";
        });
        document.getElementById("closeStatsOverlay").addEventListener("click", () => {
          document.getElementById("statsOverlay").style.display = "none";
        });
        document.getElementById("showDepsOverlayBtn").addEventListener("click", () => {
          this.updateDependencies();
          document.getElementById("depsOverlay").style.display = "block";
        });
        document.getElementById("closeDepsOverlay").addEventListener("click", () => {
          document.getElementById("depsOverlay").style.display = "none";
        });
        document.getElementById("dataExactCheckbox").addEventListener("change", () => this.handleSearchOptionChange());
        document.getElementById("dataCaseCheckbox").addEventListener("change", () => this.handleSearchOptionChange());
        document.getElementById("codeSearchInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("dataSearchInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("minLineInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("maxLineInput").addEventListener("input", () => this.updateEffectiveSearchTerms());
        document.getElementById("goToHandleBtn").addEventListener("click", () => this.handleGoToHandle());
        document.getElementById("backBtn").addEventListener("click", () => this.navigateBack());
        document.getElementById("forwardBtn").addEventListener("click", () => this.navigateForward());
        document.getElementById("clearHistoryBtn").addEventListener("click", () => this.clearNavigationHistory());
        const filterToggle = document.querySelector('.filter-toggle');
        if(filterToggle) {
          filterToggle.addEventListener('click', () => {
            const panel = filterToggle.parentElement;
            panel.classList.toggle('expanded');
            const icon = filterToggle.querySelector('.toggle-icon');
            icon.textContent = panel.classList.contains('expanded') ? '▲' : '▼';
          });
        }
        this.treeViewContainer.addEventListener("scroll", (e) => {
          const scrollLeft = e.target.scrollLeft;
          document.getElementById("treeGridHeader").style.transform = "translateX(-" + scrollLeft + "px)";
        });
        window.addEventListener("resize", () => {
          this.myTreeView.updateVisibleNodes();
        });
        // Hex viewer overlay event listeners
        document.getElementById("closeHexViewerOverlay").addEventListener("click", () => {
          document.getElementById("hexViewerOverlay").style.display = "none";
        });
        document.getElementById("saveBinaryBtn").addEventListener("click", () => {
          if (this.currentBinaryData) {
            const blob = new Blob([this.currentBinaryData], { type: "application/octet-stream" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "binary_data.bin";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }
        });
      }
      updateEffectiveSearchTerms() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const codeInput = document.getElementById("codeSearchInput");
        const dataInput = document.getElementById("dataSearchInput");
        const codeText = codeInput.value.trim();
        const dataText = dataInput.value.trim();
        const effectiveCodeSearchTerms = activeTab.codeSearchTerms.slice();
        const effectiveDataSearchTerms = activeTab.dataSearchTerms.slice();
        if (codeText !== "" && !effectiveCodeSearchTerms.includes(codeText)) {
          effectiveCodeSearchTerms.push(codeText);
        }
        if (dataText !== "" && !effectiveDataSearchTerms.includes(dataText)) {
          effectiveDataSearchTerms.push(dataText);
        }
        const minLineInputVal = document.getElementById("minLineInput").value.trim();
        const maxLineInputVal = document.getElementById("maxLineInput").value.trim();
        const minLine = minLineInputVal !== "" ? parseInt(minLineInputVal, 10) : null;
        const maxLine = maxLineInputVal !== "" ? parseInt(maxLineInputVal, 10) : null;
        activeTab.minLine = minLine;
        activeTab.maxLine = maxLine;
        activeTab.dataExact = document.getElementById("dataExactCheckbox").checked;
        activeTab.dataCase = document.getElementById("dataCaseCheckbox").checked;
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          minLine,
          maxLine
        );
        this.myTreeView.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      handleSearchOptionChange() { this.updateEffectiveSearchTerms(); }
      getActiveTab() { return this.tabs.find(t => t.id === this.activeTabId); }
      updateTabUI() {
        const tabContainer = document.getElementById("tabContainer");
        tabContainer.innerHTML = "";
        this.tabs.forEach(tab => {
          const tabElem = document.createElement("div");
          tabElem.className = "tab" + (tab.id === this.activeTabId ? " active" : "");
          tabElem.textContent = tab.name;
          tabElem.dataset.tabId = tab.id;
          tabElem.addEventListener("click", () => {
            this.activeTabId = tab.id;
            document.getElementById("codeSearchInput").value = "";
            document.getElementById("dataSearchInput").value = "";
            this.updateTagContainer("codeSearchTags", tab.codeSearchTerms, "code");
            this.updateTagContainer("dataSearchTags", tab.dataSearchTerms, "data");
            document.getElementById("minLineInput").value = tab.minLine !== null ? tab.minLine : "";
            document.getElementById("maxLineInput").value = tab.maxLine !== null ? tab.maxLine : "";
            document.getElementById("dataExactCheckbox").checked = tab.dataExact || false;
            document.getElementById("dataCaseCheckbox").checked = tab.dataCase || false;
            this.myTreeView.setData(tab.currentTreeData);
            this.updateTabUI();
          });
          const closeBtn = document.createElement("span");
          closeBtn.className = "close-tab";
          closeBtn.textContent = "×";
          closeBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            this.tabs = this.tabs.filter(t => t.id !== tab.id);
            if (this.activeTabId === tab.id) { this.activeTabId = this.tabs.length ? this.tabs[0].id : null; }
            this.updateTabUI();
            if (this.activeTabId) { this.myTreeView.setData(this.getActiveTab().currentTreeData); }
            else { this.myTreeView.setData([]); }
          });
          tabElem.appendChild(closeBtn);
          tabContainer.appendChild(tabElem);
        });
        this.updateNavHistoryUI();
        this.updateNavButtons();
      }
      expandAllNodes(nodes) {
        nodes.forEach(node => {
          if ((node.properties && node.properties.length) || (node.children && node.children.length)) {
            node.expanded = true;
            this.expandAllNodes(node.children);
          }
        });
      }
      collapseAllNodes(nodes) {
        nodes.forEach(node => {
          node.expanded = false;
          this.collapseAllNodes(node.children);
        });
      }
      handleExpandAll() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        this.expandAllNodes(activeTab.originalTreeData);
        if (activeTab.currentSortField) {
          this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
        }
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeView.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      handleCollapseAll() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        this.collapseAllNodes(activeTab.originalTreeData);
        if (activeTab.currentSortField) {
          this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
        }
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeView.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      handleToggleExpand(nodeId) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const node = this.dxfParser.findNodeById(activeTab.originalTreeData, nodeId);
        if (node) {
          node.expanded = !node.expanded;
          if (activeTab.currentSortField) {
            this.sortTreeNodes(activeTab.originalTreeData, activeTab.currentSortField, activeTab.currentSortAscending);
          }
          activeTab.currentTreeData = this.filterTree(
            activeTab.originalTreeData,
            activeTab.codeSearchTerms,
            activeTab.dataSearchTerms,
            activeTab.dataExact,
            activeTab.dataCase,
            activeTab.minLine,
            activeTab.maxLine
          );
          this.myTreeView.setData(activeTab.currentTreeData);
        }
      }
      getSortValue(node, field) {
        if (field === "line") { return node.line ? Number(node.line) : 0; }
        else if (field === "code") {
          if (node.isProperty) {
            const c = parseInt(node.code, 10);
            return isNaN(c) ? Number.MAX_SAFE_INTEGER : c;
          }
          return 0;
        } else if (field === "type") { return node.isProperty ? (node.data || "") : (node.type || ""); }
        else if (field === "objectCount") {
          if (node.isProperty) return 0;
          function countDescendants(n) {
            if (!n.children || n.children.length === 0) return 0;
            let count = 0;
            for (let child of n.children) {
              if (!child.isProperty) {
                count++;
                if (child.children && child.children.length) { count += countDescendants(child); }
              }
            }
            return count;
          }
          return countDescendants(node);
        } else if (field === "dataSize") {
          function computeSize(n) {
            if (n.isProperty) { return n.data ? n.data.length : 0; }
            else {
              let size = n.type ? n.type.length : 0;
              if (n.properties && n.properties.length) {
                for (let prop of n.properties) { size += prop.value ? prop.value.length : 0; }
              }
              if (n.children && n.children.length) {
                for (let child of n.children) { size += computeSize(child); }
              }
              return size;
            }
          }
          return computeSize(node);
        }
        return "";
      }
      sortTreeNodes(nodes, field, ascending) {
        nodes.sort((a, b) => {
          const aVal = this.getSortValue(a, field);
          const bVal = this.getSortValue(b, field);
          if (field === "code" || field === "line" || field === "objectCount" || field === "dataSize") {
            return (aVal - bVal) * (ascending ? 1 : -1);
          } else { return aVal.localeCompare(bVal) * (ascending ? 1 : -1); }
        });
        nodes.forEach(node => {
          if (node.properties && node.properties.length) {
            node.properties.sort((aProp, bProp) => {
              if (field === "code") {
                const aC = parseInt(aProp.code, 10) || 0;
                const bC = parseInt(bProp.code, 10) || 0;
                return (aC - bC) * (ascending ? 1 : -1);
              } else if (field === "line") {
                const aL = aProp.line || 0;
                const bL = bProp.line || 0;
                return (aL - bL) * (ascending ? 1 : -1);
              } else if (field === "type") {
                const aV = aProp.value || "";
                const bV = bProp.value || "";
                return aV.localeCompare(bV) * (ascending ? 1 : -1);
              }
              return 0;
            });
          }
          if (node.children && node.children.length) { this.sortTreeNodes(node.children, field, ascending); }
        });
      }
      handleHeaderClick(headerCell) {
        const field = headerCell.getAttribute('data-field');
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        let currentSort = headerCell.getAttribute('data-sort');
        let ascending = true;
        if (currentSort === 'asc') {
          ascending = false;
          headerCell.setAttribute('data-sort', 'desc');
          headerCell.querySelector('.sort-indicator').textContent = ' ▼';
        } else {
          ascending = true;
          headerCell.setAttribute('data-sort', 'asc');
          headerCell.querySelector('.sort-indicator').textContent = ' ▲';
        }
        activeTab.currentSortField = field;
        activeTab.currentSortAscending = ascending;
        document.querySelectorAll('.header-cell').forEach(cell => {
          if (cell !== headerCell) {
            cell.setAttribute('data-sort', 'none');
            cell.querySelector('.sort-indicator').textContent = '';
          }
        });
        this.sortTreeNodes(activeTab.originalTreeData, field, ascending);
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          activeTab.dataExact,
          activeTab.dataCase,
          activeTab.minLine,
          activeTab.maxLine
        );
        this.myTreeView.setData(activeTab.currentTreeData);
      }
      handleResizerMouseDown(e) {
        e.stopPropagation();
        const headerCell = e.target.parentElement;
        const field = headerCell.getAttribute('data-field');
        const startX = e.clientX;
        const startWidth = headerCell.offsetWidth;
        const onMouseMove = (eMove) => {
          const newWidth = startWidth + (eMove.clientX - startX);
          this.columnWidths[field] = newWidth;
          headerCell.style.width = newWidth + "px";
          headerCell.style.flex = "none";
          this.myTreeView.updateVisibleNodes();
        };
        const onMouseUp = () => {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        };
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      }
      filterTree(objects, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine) {
        const filtered = [];
        objects.forEach(obj => {
          const filteredObj = this.filterObject(obj, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine);
          if (filteredObj !== null) { filtered.push(filteredObj); }
        });
        return filtered;
      }
      filterObject(obj, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine) {
        let nodeLine = parseInt(obj.line, 10);
        let lineMatches = true;
        if (minLine != null && !isNaN(minLine)) {
          if (isNaN(nodeLine) || nodeLine < minLine) lineMatches = false;
        }
        if (maxLine != null && !isNaN(maxLine)) {
          if (isNaN(nodeLine) || nodeLine > maxLine) lineMatches = false;
        }
        const filteredProperties = obj.properties.filter(prop => {
          let propLine = parseInt(prop.line, 10);
          if (minLine != null && !isNaN(minLine)) {
            if (isNaN(propLine) || propLine < minLine) return false;
          }
          if (maxLine != null && !isNaN(maxLine)) {
            if (isNaN(propLine) || propLine > maxLine) return false;
          }
          const codeMatch = (codeTerms.length === 0) ||
            codeTerms.some(term => String(prop.code) === term);
          let dataMatch = true;
          if (dataTerms.length > 0) {
            if (dataExact) {
              dataMatch = dataTerms.some(term =>
                dataCase ? (prop.value === term)
                         : (prop.value.toLowerCase() === term.toLowerCase())
              );
            } else {
              dataMatch = dataTerms.some(term =>
                dataCase ? prop.value.includes(term)
                         : prop.value.toLowerCase().includes(term.toLowerCase())
              );
            }
          }
          return codeMatch && dataMatch;
        });
        const filteredChildren = obj.children
          .map(child => this.filterObject(child, codeTerms, dataTerms, dataExact, dataCase, minLine, maxLine))
          .filter(child => child !== null);
        const codeFilterActive = codeTerms.length > 0;
        const dataFilterActive = dataTerms.length > 0;
        let typeMatchesData = false;
        if (dataFilterActive) {
          if (dataExact) {
            typeMatchesData = dataTerms.some(term =>
              dataCase ? (obj.type === term)
                       : (obj.type.toLowerCase() === term.toLowerCase())
            );
          } else {
            typeMatchesData = dataTerms.some(term =>
              dataCase ? obj.type.includes(term)
                       : obj.type.toLowerCase().includes(term.toLowerCase())
            );
          }
        }
        if (!codeFilterActive && !dataFilterActive) {
          if (!lineMatches && filteredProperties.length === 0 && filteredChildren.length === 0) {
            return null;
          }
          return {
            ...obj,
            properties: filteredProperties,
            children: filteredChildren
          };
        }
        if (codeFilterActive && filteredProperties.length === 0 && filteredChildren.length === 0) {
          return null;
        }
        if (dataFilterActive && !(typeMatchesData || filteredProperties.length > 0 || filteredChildren.length > 0)) {
          return null;
        }
        if (!lineMatches && filteredProperties.length === 0 && filteredChildren.length === 0) {
          return null;
        }
        return {
          ...obj,
          properties: filteredProperties,
          children: filteredChildren
        };
      }
      handleCopy(nodeId) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const node = this.dxfParser.findNodeById(activeTab.originalTreeData, nodeId);
        if (!node) { alert("Node not found in original data."); return; }
        const serialized = this.dxfParser.serializeNode(node);
        navigator.clipboard.writeText(serialized).then(() => {
          alert("Copied node to clipboard as valid DXF tags.");
        }, () => {
          alert("Failed to copy to clipboard.");
        });
      }
      // New method: stream the file and process it in chunks.
      async parseFileStream(file) {
        const reader = file.stream().getReader();
        const decoder = new TextDecoder("ascii");
        let leftover = "";
        const lines = [];
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          const chunkText = decoder.decode(value, { stream: true });
          const text = leftover + chunkText;
          const parts = text.split(/\r?\n/);
          leftover = parts.pop();
          lines.push(...parts);
        }
        if (leftover) { lines.push(leftover); }
        const tags = this.dxfParser.parseDxfLines(lines);
        const grouped = this.dxfParser.groupObjects(tags, 0);
        return grouped.objects;
      }
      // Updated handleParse() that uses streamed parsing if selected.
      handleParse() {
        const fileInput = document.getElementById("fileInput");
        const useStream = document.getElementById("useStreamCheckbox").checked;
        if (!fileInput.files || fileInput.files.length === 0) {
          alert("Please select at least one DXF file.");
          return;
        }
        Array.from(fileInput.files).forEach(file => {
          if (useStream && file.stream) {
            this.parseFileStream(file)
              .then(objects => {
                const newTab = {
                  id: Date.now() + Math.random(),
                  name: file.name,
                  originalTreeData: objects,
                  currentTreeData: objects,
                  codeSearchTerms: [],
                  dataSearchTerms: [],
                  currentSortField: "line",
                  currentSortAscending: true,
                  minLine: null,
                  maxLine: null,
                  dataExact: false,
                  dataCase: false,
                  navigationHistory: [],
                  currentHistoryIndex: -1
                };
                this.tabs.push(newTab);
                this.activeTabId = newTab.id;
                this.updateTabUI();
                this.myTreeView.setData(newTab.currentTreeData);
              })
              .catch(err => {
                console.error("Error during streamed parsing:", err);
                alert("Error during streamed parsing.");
              });
          } else {
            const reader = new FileReader();
            reader.onload = (event) => {
              const text = event.target.result;
              const objects = this.dxfParser.parse(text);
              const newTab = {
                id: Date.now() + Math.random(),
                name: file.name,
                originalTreeData: objects,
                currentTreeData: objects,
                codeSearchTerms: [],
                dataSearchTerms: [],
                currentSortField: "line",
                currentSortAscending: true,
                minLine: null,
                maxLine: null,
                dataExact: false,
                dataCase: false,
                navigationHistory: [],
                currentHistoryIndex: -1
              };
              this.tabs.push(newTab);
              this.activeTabId = newTab.id;
              this.updateTabUI();
              this.myTreeView.setData(newTab.currentTreeData);
            };
            reader.readAsText(file, "ascii");
          }
        });
      }
      createTagElement(text, type) {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = text;
        const removeBtn = document.createElement("span");
        removeBtn.className = "remove";
        removeBtn.textContent = "×";
        removeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          const activeTab = this.getActiveTab();
          if (!activeTab) return;
          if (type === "code") {
            activeTab.codeSearchTerms = activeTab.codeSearchTerms.filter(term => term !== text);
            this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
          } else if (type === "data") {
            activeTab.dataSearchTerms = activeTab.dataSearchTerms.filter(term => term !== text);
            this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
          }
          activeTab.currentTreeData = this.filterTree(
            activeTab.originalTreeData,
            activeTab.codeSearchTerms,
            activeTab.dataSearchTerms,
            activeTab.dataExact,
            activeTab.dataCase,
            activeTab.minLine,
            activeTab.maxLine
          );
          this.myTreeView.setData(activeTab.currentTreeData);
          this.treeViewContainer.scrollTop = 0;
        });
        tag.appendChild(removeBtn);
        return tag;
      }
      updateTagContainer(containerId, termsArray, type) {
        const container = document.getElementById(containerId);
        Array.from(container.querySelectorAll(".tag")).forEach(tag => tag.remove());
        termsArray.forEach(term => {
          const tagElem = this.createTagElement(term, type);
          container.insertBefore(tagElem, container.querySelector("input"));
        });
      }
      setupTagInput(inputId, type) {
        const input = document.getElementById(inputId);
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === ",") {
            e.preventDefault();
            const text = input.value.trim();
            if (text !== "") {
              const activeTab = this.getActiveTab();
              if (!activeTab) return;
              if (type === "code") {
                if (!activeTab.codeSearchTerms.includes(text)) {
                  activeTab.codeSearchTerms.push(text);
                }
                this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
              } else {
                if (!activeTab.dataSearchTerms.includes(text)) {
                  activeTab.dataSearchTerms.push(text);
                }
                this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
              }
              input.value = "";
              this.updateEffectiveSearchTerms();
            }
          }
        });
        input.addEventListener("blur", () => {
          const text = input.value.trim();
          if (text !== "") {
            const activeTab = this.getActiveTab();
            if (!activeTab) return;
            if (type === "code") {
              if (!activeTab.codeSearchTerms.includes(text)) {
                activeTab.codeSearchTerms.push(text);
              }
              this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
            } else {
              if (!activeTab.dataSearchTerms.includes(text)) {
                activeTab.dataSearchTerms.push(text);
              }
              this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
            }
            input.value = "";
            this.updateEffectiveSearchTerms();
          }
        });
      }
      handleSearch() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const codeInput = document.getElementById("codeSearchInput");
        const dataInput = document.getElementById("dataSearchInput");
        if (codeInput.value.trim() !== "") {
          const text = codeInput.value.trim();
          if (!activeTab.codeSearchTerms.includes(text)) {
            activeTab.codeSearchTerms.push(text);
          }
          this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
          codeInput.value = "";
        }
        if (dataInput.value.trim() !== "") {
          const text = dataInput.value.trim();
          if (!activeTab.dataSearchTerms.includes(text)) {
            activeTab.dataSearchTerms.push(text);
          }
          this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
          dataInput.value = "";
        }
        this.updateEffectiveSearchTerms();
      }
      handleClearSearch() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        activeTab.codeSearchTerms = [];
        activeTab.dataSearchTerms = [];
        activeTab.minLine = null;
        activeTab.maxLine = null;
        this.updateTagContainer("codeSearchTags", activeTab.codeSearchTerms, "code");
        this.updateTagContainer("dataSearchTags", activeTab.dataSearchTerms, "data");
        document.getElementById("codeSearchInput").value = "";
        document.getElementById("dataSearchInput").value = "";
        document.getElementById("dataExactCheckbox").checked = false;
        document.getElementById("dataCaseCheckbox").checked = false;
        document.getElementById("minLineInput").value = "";
        document.getElementById("maxLineInput").value = "";
        activeTab.currentTreeData = this.filterTree(
          activeTab.originalTreeData,
          activeTab.codeSearchTerms,
          activeTab.dataSearchTerms,
          false,
          false,
          null,
          null
        );
        this.myTreeView.setData(activeTab.currentTreeData);
        this.treeViewContainer.scrollTop = 0;
      }
      findPathByHandle(nodes, handle) {
        for (const node of nodes) {
          if (node.handle && node.handle.toUpperCase() === handle.toUpperCase()) {
            return [node];
          }
          if (node.children && node.children.length) {
            const subPath = this.findPathByHandle(node.children, handle);
            if (subPath) { return [node, ...subPath]; }
          }
        }
        return null;
      }
      navigateToHandle(handle, addHistory = true) {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const path = this.findPathByHandle(activeTab.originalTreeData, handle);
        if (!path) { alert("Definition not found for handle: " + handle); return; }
        path.forEach(node => node.expanded = true);
        activeTab.currentTreeData = activeTab.originalTreeData;
        this.myTreeView.setData(activeTab.currentTreeData);
        setTimeout(() => {
          const targetNodeId = path[path.length - 1].id;
          const flatData = this.myTreeView.flatData;
          const targetIndex = flatData.findIndex(item => String(item.node.id) === String(targetNodeId));
          if (targetIndex >= 0) {
            this.treeViewContainer.scrollTop = targetIndex * this.myTreeView.itemHeight;
            const element = this.treeViewContent.querySelector(`[data-id="${targetNodeId}"]`);
            if (element) {
              element.style.backgroundColor = "yellow";
              setTimeout(() => { element.style.backgroundColor = ""; }, 2000);
            }
          }
        }, 300);
        if (addHistory) {
          if (activeTab.currentHistoryIndex < activeTab.navigationHistory.length - 1) {
            activeTab.navigationHistory.splice(activeTab.currentHistoryIndex + 1);
          }
          activeTab.navigationHistory.push(handle);
          activeTab.currentHistoryIndex = activeTab.navigationHistory.length - 1;
          this.updateNavHistoryUI();
          this.updateNavButtons();
        }
      }
      handleGoToHandle() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        const handleValue = document.getElementById("handleSearchInput").value.trim();
        if (!handleValue) return;
        this.navigateToHandle(handleValue, true);
      }
      handleLinkToHandle(handle) { this.navigateToHandle(handle, true); }
      updateNavHistoryUI() {
        const activeTab = this.getActiveTab();
        const listContainer = document.getElementById("navHistoryList");
        listContainer.innerHTML = "";
        if (!activeTab) return;
        activeTab.navigationHistory.forEach((handle, index) => {
          const span = document.createElement("span");
          span.textContent = handle;
          span.style.cursor = "pointer";
          span.style.marginRight = "8px";
          if (index === activeTab.currentHistoryIndex) {
            span.style.fontWeight = "bold";
            span.style.textDecoration = "underline";
          }
          span.addEventListener("click", () => {
            activeTab.currentHistoryIndex = index;
            this.navigateToHandle(handle, false);
            this.updateNavHistoryUI();
            this.updateNavButtons();
          });
          listContainer.appendChild(span);
        });
      }
      updateNavButtons() {
        const activeTab = this.getActiveTab();
        const backBtn = document.getElementById("backBtn");
        const forwardBtn = document.getElementById("forwardBtn");
        if (!activeTab) { backBtn.disabled = true; forwardBtn.disabled = true; return; }
        backBtn.disabled = activeTab.currentHistoryIndex <= 0;
        forwardBtn.disabled = activeTab.currentHistoryIndex >= activeTab.navigationHistory.length - 1;
      }
      navigateBack() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        if (activeTab.currentHistoryIndex > 0) {
          activeTab.currentHistoryIndex--;
          const handle = activeTab.navigationHistory[activeTab.currentHistoryIndex];
          this.navigateToHandle(handle, false);
          this.updateNavHistoryUI();
          this.updateNavButtons();
        }
      }
      navigateForward() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        if (activeTab.currentHistoryIndex < activeTab.navigationHistory.length - 1) {
          activeTab.currentHistoryIndex++;
          const handle = activeTab.navigationHistory[activeTab.currentHistoryIndex];
          this.navigateToHandle(handle, false);
          this.updateNavHistoryUI();
          this.updateNavButtons();
        }
      }
      clearNavigationHistory() {
        const activeTab = this.getActiveTab();
        if (!activeTab) return;
        activeTab.navigationHistory = [];
        activeTab.currentHistoryIndex = -1;
        this.updateNavHistoryUI();
        this.updateNavButtons();
      }
      updateClouds() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayObjectCloud").innerHTML = "";
          document.getElementById("overlayCodeCloud").innerHTML = "";
          return;
        }
        const objectCounts = {};
        const codeCounts = {};
        function traverse(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty) {
              objectCounts[node.type] = (objectCounts[node.type] || 0) + 1;
              node.properties.forEach(prop => {
                codeCounts[prop.code] = (codeCounts[prop.code] || 0) + 1;
              });
              if (node.children && node.children.length > 0) { traverse(node.children); }
            }
          });
        }
        traverse(activeTab.originalTreeData);
        const populateCloud = (element, counts, minFont, maxFont, cloudType) => {
          element.innerHTML = "";
          const maxCount = Math.max(...Object.values(counts), 1);
          for (const key in counts) {
            const count = counts[key];
            const fontSize = minFont + ((count / maxCount) * (maxFont - minFont));
            const span = document.createElement("span");
            span.className = "cloud-tag";
            span.style.fontSize = fontSize + "px";
            span.textContent = `${key} (${count})`;
            span.addEventListener("click", () => {
              this.handleCloudTagClick(cloudType, key);
            });
            element.appendChild(span);
          }
        };
        const minFont = 12, maxFont = 36;
        const overlayObjectCloudElem = document.getElementById("overlayObjectCloud");
        const overlayCodeCloudElem = document.getElementById("overlayCodeCloud");
        populateCloud(overlayObjectCloudElem, objectCounts, minFont, maxFont, "object");
        populateCloud(overlayCodeCloudElem, codeCounts, minFont, maxFont, "code");
      }
      updateStats() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayStatsContent").innerHTML = "No DXF data loaded.";
          return;
        }
        function computeStats(nodes, depth = 1) {
          let stats = {
            totalObjects: 0,
            totalProperties: 0,
            maxDepth: depth,
            totalDataSize: 0,
            countByType: {}
          };
          nodes.forEach(node => {
            if (!node.isProperty) {
              stats.totalObjects++;
              stats.countByType[node.type] = (stats.countByType[node.type] || 0) + 1;
              let nodeDataSize = node.type ? node.type.length : 0;
              if (node.properties && node.properties.length) {
                stats.totalProperties += node.properties.length;
                node.properties.forEach(prop => {
                  nodeDataSize += prop.value ? prop.value.length : 0;
                });
              }
              stats.totalDataSize += nodeDataSize;
              if (node.children && node.children.length) {
                const childStats = computeStats(node.children, depth + 1);
                stats.totalObjects += childStats.totalObjects;
                stats.totalProperties += childStats.totalProperties;
                stats.totalDataSize += childStats.totalDataSize;
                for (let type in childStats.countByType) {
                  stats.countByType[type] = (stats.countByType[type] || 0) + childStats.countByType[type];
                }
                if (childStats.maxDepth > stats.maxDepth) { stats.maxDepth = childStats.maxDepth; }
              }
            }
          });
          return stats;
        }
        const stats = computeStats(activeTab.originalTreeData);
        const avgProps = stats.totalObjects > 0 ? (stats.totalProperties / stats.totalObjects).toFixed(2) : 0;
        const statsHtml = `
          <ul>
            <li><strong>Total Objects:</strong> ${stats.totalObjects}</li>
            <li><strong>Total Properties:</strong> ${stats.totalProperties}</li>
            <li><strong>Maximum Nesting Depth:</strong> ${stats.maxDepth}</li>
            <li><strong>Total Data Size:</strong> ${stats.totalDataSize} characters</li>
            <li><strong>Average Properties per Object:</strong> ${avgProps}</li>
            <li><strong>Object Type Counts:</strong>
              <ul>
                ${Object.entries(stats.countByType)
                  .map(([type, count]) => `<li>${type}: ${count}</li>`)
                  .join('')}
              </ul>
            </li>
          </ul>
        `;
        document.getElementById("overlayStatsContent").innerHTML = statsHtml;
      }
      updateDependencies() {
        const activeTab = this.getActiveTab();
        if (!activeTab) {
          document.getElementById("overlayDepsContent").innerHTML = "No DXF data loaded.";
          return;
        }
        const dependencyTypes = ["LTYPE", "STYLE", "APPID", "LAYER", "DIMSTYLE", "VPORT", "XREF", "SHAPE"];
        const dependencies = {};
        dependencyTypes.forEach(type => dependencies[type] = []);
        function traverse(nodes) {
          nodes.forEach(node => {
            if (!node.isProperty) {
              const type = node.type.toUpperCase();
              if (dependencyTypes.includes(type)) { dependencies[type].push(node); }
              if (node.children && node.children.length) { traverse(node.children); }
            }
          });
        }
        traverse(activeTab.originalTreeData);
        let html = "";
        dependencyTypes.forEach(depType => {
          if (dependencies[depType].length > 0) {
            html += `<h3>${depType} (${dependencies[depType].length})</h3><ul>`;
            dependencies[depType].forEach(dep => {
              let depInfo = `${dep.type} (Line ${dep.line})`;
              if (dep.properties && dep.properties.length) {
                const propSummary = dep.properties.map(p => `${p.code}:${p.value}`).join(", ");
                depInfo += ` [${propSummary}]`;
              }
              html += `<li>${depInfo}</li>`;
            });
            html += "</ul>";
          }
        });
        if (!html) { html = "No external dependency objects found."; }
        document.getElementById("overlayDepsContent").innerHTML = html;
      }
      // NEW: Display the hex viewer overlay using combined hex string.
      showHexViewer(combinedHexString) {
        // Convert the concatenated hex string to a binary (byte) array.
        const binaryArray = hexStringToByteArray(combinedHexString);
        // Generate a hex dump from the binary data.
        const dump = hexDump(binaryArray);
        const hexContentElem = document.getElementById("hexContent");
        const headerInfoElem = document.getElementById("headerInfo");
        hexContentElem.textContent = dump;
        // Detect a header from the binary data.
        const detectedType = detectHeader(binaryArray);
        headerInfoElem.textContent = detectedType ? "Detected file type: " + detectedType : "Unknown file type";
        // Store the binary data for possible saving.
        this.currentBinaryData = binaryArray;
        document.getElementById("hexViewerOverlay").style.display = "block";
      }
    }
    document.addEventListener("DOMContentLoaded", () => { new App(); });
  </script>
</body>
</html>
